This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
001-csv-upload/
  plan.md
  spec.md
002-research-funding-dashboard/
  plan.md
  spec.md
003-student-dashboard/
  plan.md
  spec.md
004-publication-dashboard/
  plan.md
  spec.md
005-department-kpi-dashboard/
  plan.md
  spec.md
006-dashboard-filtering/
  plan.md
  spec.md
db/
  department_kpi.csv
  publication_list.csv
  research_project_data.csv
  student_roster.csv
code_structure.md
database.md
persona.md
prd.md
requirements.md
state-management.md
techstack.md
userflow.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="001-csv-upload/plan.md">
# CSV/Excel 파일 업로드 기능 구현 계획 (TDD 기반)

**기능명:** CSV/Excel 파일 업로드 및 데이터 파싱
**작성일:** 2025-11-02
**버전:** 1.0
**작성자:** Plan Writer Agent
**기반 문서:** docs/001-csv-upload/spec.md

---

## 1. 개요

### 1.1 목표
TDD(Test-Driven Development) 원칙에 따라 CSV/Excel 파일 업로드 기능을 안정적이고 테스트 가능한 모듈로 구현합니다.

### 1.2 핵심 모듈 목록
- **Backend - Presentation Layer**: API 엔드포인트 및 권한 검증
- **Backend - Service Layer**: 비즈니스 로직 (파일 파싱, 작업 조정)
- **Backend - Infrastructure Layer**: DB 저장 및 파일 시스템
- **Frontend - Upload UI**: 파일 업로드 인터페이스
- **Frontend - Status Polling**: 작업 상태 추적

### 1.3 TDD 적용 범위
- **Unit Tests (70%)**: Pandas 파싱 로직, 검증 로직
- **Integration Tests (20%)**: DRF API 엔드포인트, DB 저장
- **Acceptance Tests (10%)**: E2E 업로드 플로우

### 1.4 MVP 간소화 전략
- UTF-8 인코딩만 지원 (자동 감지 제외)
- 메모리 기반 작업 상태 저장 (Redis 제외)
- ThreadPoolExecutor 순차 처리 (worker=1)
- 전체 교체 모드만 지원 (UPSERT 제외)

### 1.5 환경 변수 요구사항

**Backend (.env):**
- `ADMIN_API_KEY`: 하드코딩된 관리자 API 키 (예: "your-secret-key-here")
- `DATABASE_URL`: Supabase PostgreSQL 연결 문자열
- `DEBUG`: True/False (Django 디버그 모드)
- `ALLOWED_HOSTS`: 쉼표로 구분된 호스트명

**Frontend (.env.local):**
- `REACT_APP_API_BASE_URL`: 백엔드 API URL (예: "https://api.example.com")
- `REACT_APP_ADMIN_MODE`: "true"로 설정하여 관리자 업로드 페이지 접근 활성화

---

## 2. Architecture Diagram

```mermaid
graph TB
    subgraph Frontend
        A[Upload UI Component]
        B[File Validator]
        C[Status Polling Hook]
        D[API Client]
    end

    subgraph Backend - Presentation
        E[UploadViewSet]
        F[StatusViewSet]
        G[AdminAPIKeyPermission]
        H[UploadSerializer]
    end

    subgraph Backend - Service
        I[IngestionService]
        J[ExcelParser - Research]
        K[ExcelParser - Student]
        L[ExcelParser - Publication]
        M[ExcelParser - KPI]
    end

    subgraph Backend - Infrastructure
        N[ResearchRepository]
        O[StudentRepository]
        P[PublicationRepository]
        Q[KPIRepository]
        R[FileStorage]
        S[JobStatusStore]
    end

    subgraph Database
        T[(Supabase PostgreSQL)]
    end

    A --> B
    B --> D
    C --> D
    D --> E
    D --> F
    E --> G
    E --> H
    E --> I
    F --> S
    I --> J
    I --> K
    I --> L
    I --> M
    I --> R
    I --> S
    J --> N
    K --> O
    L --> P
    M --> Q
    N --> T
    O --> T
    P --> T
    Q --> T

    style J fill:#e1f5ff
    style K fill:#e1f5ff
    style L fill:#e1f5ff
    style M fill:#e1f5ff
    style I fill:#fff4e1
    style G fill:#ffe1e1
```

**레이어 색상 범례:**
- 파란색: 핵심 비즈니스 로직 (Pandas Parser - 높은 테스트 커버리지)
- 노란색: 유스케이스 조정 (Ingestion Service)
- 빨간색: 보안 계층 (Permission)

---

## 3. Implementation Plan

### 3.1 Backend - Infrastructure Layer

#### 3.1.1 Django Models
**Location:** `backend/data_ingestion/infrastructure/models.py`

**Responsibility:**
- 4개 테이블 정의 (ResearchProject, Student, Publication, DepartmentKPI)
- PK, 인덱스, 제약 조건 설정

**Test Strategy:** Integration Test (Django TestCase)

**Test Scenarios:**
- **Arrange-Act-Assert:**
  - Red: 모델 인스턴스 생성 → DB 저장 → 조회 성공
  - Red: PK 중복 삽입 시 IntegrityError 발생
  - Red: NOT NULL 제약 위반 시 ValidationError 발생

**Implementation Order:**
1. Red: 모델 정의 테스트 작성 (테이블 존재 확인)
2. Green: Django 모델 클래스 작성
3. Refactor: Meta 옵션 추가 (인덱스, verbose_name)
4. Red: 제약 조건 테스트 (UNIQUE, NOT NULL)
5. Green: validators 추가
6. Migration 생성 및 적용

**Dependencies:** None (가장 먼저 구현)

---

#### 3.1.1.1 Domain Entities

**Location:** `backend/data_ingestion/domain/entities.py`

**Responsibility:**
- 비즈니스 도메인 엔티티 정의 (Pure Python)
- 인프라 독립적 데이터 구조

**Implementation:**
```python
from dataclasses import dataclass
from datetime import date
from typing import Optional

@dataclass
class ResearchFunding:
    execution_id: str
    department: str
    total_budget: int
    execution_date: date
    execution_amount: int

@dataclass
class Student:
    student_id: str
    department: str
    grade: int
    program_type: str  # 학사/석사/박사
    enrollment_status: str  # 재학/휴학/졸업

@dataclass
class Publication:
    publication_id: str
    department: str
    journal_tier: str  # SCIE/KCI
    impact_factor: Optional[float]

@dataclass
class DepartmentKPI:
    evaluation_year: int
    department: str
    employment_rate: float  # 백분율
    tech_transfer_revenue: float  # 억원
```

---

#### 3.1.2 Repositories (Data Access Layer)
**Location:** `backend/data_ingestion/infrastructure/repositories.py`

**Responsibility:**
- Pandas DataFrame → Django Model Bulk Insert
- 전체 교체 모드 구현 (DELETE + INSERT)
- 트랜잭션 관리

**Test Strategy:** Integration Test

**Test Scenarios (TDD Cycle):**

**Red Phase:**
```python
def test_save_research_funding_replaces_existing_data():
    # Arrange: 기존 데이터 생성
    ResearchProject.objects.create(execution_id='OLD001', ...)
    df = pd.DataFrame([{'execution_id': 'NEW001', ...}])

    # Act: 전체 교체 저장
    save_research_funding_data(df, replace=True)

    # Assert: 기존 데이터 삭제, 신규 데이터만 존재
    assert ResearchProject.objects.count() == 1
    assert ResearchProject.objects.filter(execution_id='OLD001').count() == 0
    assert ResearchProject.objects.filter(execution_id='NEW001').count() == 1
```

**Green Phase:**
```python
from django.db import transaction

def save_research_funding_data(dataframe, replace=True):
    with transaction.atomic():
        if replace:
            ResearchProject.objects.all().delete()

        records = [
            ResearchProject(**row)
            for row in dataframe.to_dict('records')
        ]
        ResearchProject.objects.bulk_create(records)
```

**Refactor Phase:**
- 공통 로직 추출 (save_data_with_replace 제네릭 함수)
- 배치 크기 최적화 (bulk_create batch_size=1000)

**Edge Cases:**
- Red: DB 연결 실패 시 DatabaseError 발생
- Red: 빈 DataFrame 전달 시 데이터 삭제만 수행
- Red: 트랜잭션 롤백 동작 검증

**Implementation Order:**
1. Red: save_research_funding_data 테스트 (전체 교체)
2. Green: 기본 구현
3. Refactor: 트랜잭션 추가
4. Red: 나머지 3개 타입 테스트 (students, publications, kpis)
5. Green: 반복 구현
6. Refactor: 제네릭 함수로 통합

**Dependencies:** models.py (Django Models)

---

#### 3.1.3 File Storage
**Location:** `backend/data_ingestion/infrastructure/file_storage.py`

**Responsibility:**
- 임시 파일 저장 (`/tmp/upload_{uuid}/`)
- 파일 정리 (처리 완료 후 자동 삭제)

**Test Strategy:** Unit Test

**Test Scenarios:**
- **Red:** 파일 저장 후 경로 반환 검증
- **Red:** 임시 디렉토리 생성 권한 검증
- **Red:** 파일 정리 함수 호출 시 디렉토리 삭제 확인
- **Red:** 존재하지 않는 디렉토리 정리 시 에러 미발생

**Implementation Order:**
1. Red: save_uploaded_file 테스트
2. Green: pathlib 사용 구현
3. Refactor: UUID 생성 함수 분리
4. Red: cleanup_temp_files 테스트
5. Green: shutil.rmtree 구현
6. Refactor: Context Manager 패턴 적용 고려

**Dependencies:** None

---

#### 3.1.4 Job Status Store (Thread-safe)
**Location:** `backend/data_ingestion/infrastructure/job_status_store.py`

**Responsibility:**
- 메모리 기반 작업 상태 저장 (Dictionary)
- Thread-safe 접근 제어 (threading.Lock)
- 상태 조회/업데이트 API

**Test Strategy:** Unit Test

**Test Scenarios:**
- **Red:** 작업 상태 생성 → 조회 성공
- **Red:** 존재하지 않는 job_id 조회 시 None 반환
- **Red:** 멀티스레드 동시 업데이트 시 데이터 무결성 유지
- **Red:** 작업 상태 필드 업데이트 (status, progress, files)

**Implementation Order:**
1. Red: create_job, get_job_status 테스트
2. Green: Dictionary + Lock 구현
3. Refactor: JobStatus 클래스 정의 (TypedDict)
4. Red: update_job_status 테스트
5. Green: Lock 내부 업데이트 로직
6. Red: 동시성 테스트 (threading.Thread 10개 동시 실행)
7. Refactor: 메서드 분리 (status만 업데이트, progress만 업데이트)

**Dependencies:** None

---

### 3.2 Backend - Service Layer

#### 3.2.1 Excel Parser - Pure Pandas Logic (핵심 모듈)
**Location:** `backend/data_ingestion/services/excel_parser.py`

**Responsibility:**
- CSV/Excel 파일 → Pandas DataFrame 변환
- 필수 컬럼 검증
- 데이터 타입 변환 (날짜, 숫자, 문자열)
- 데이터 정제 (NaN 제거, 중복 제거, 범위 검증)
- 비즈니스 로직 검증 (집행금액 ≤ 총연구비 등)

**Test Strategy:** Unit Test (70% 커버리지 목표)

**Test Scenarios (Outside-In 전략):**

**파일 타입별 파서 함수:**
- `parse_research_project_data(file_path) -> (DataFrame, Stats)`
- `parse_student_roster(file_path) -> (DataFrame, Stats)`
- `parse_publication_list(file_path) -> (DataFrame, Stats)`
- `parse_department_kpi(file_path) -> (DataFrame, Stats)`

**Red Phase - Research Project Data:**

```python
# tests/unit/services/test_excel_parser.py
import pytest
import pandas as pd
from data_ingestion.services.excel_parser import parse_research_project_data

def test_parse_valid_research_project_data():
    # Arrange
    file_path = 'tests/fixtures/research_valid.csv'

    # Act
    df, stats = parse_research_project_data(file_path)

    # Assert
    assert len(df) > 0
    assert stats['rows_processed'] == stats['rows_inserted']
    assert '집행ID' in df.columns
    assert df['총연구비'].dtype in [np.int64, np.float64]
    assert df['집행일자'].dtype == 'datetime64[ns]'
```

**Green Phase:**
```python
def parse_research_project_data(file_path):
    # 1. 파일 로드
    df = pd.read_csv(file_path, encoding='utf-8')

    # 2. 필수 컬럼 검증
    required_columns = ['집행ID', '소속학과', '총연구비', '집행일자', '집행금액']
    if not all(col in df.columns for col in required_columns):
        raise ValueError("필수 컬럼 누락")

    # 3. 데이터 타입 변환
    df['집행일자'] = pd.to_datetime(df['집행일자'], errors='coerce')
    df['총연구비'] = pd.to_numeric(df['총연구비'], errors='coerce')
    df['집행금액'] = pd.to_numeric(df['집행금액'], errors='coerce')

    # 4. 결측값 제거
    df = df.dropna(subset=required_columns)

    # 5. 중복 제거
    df = df.drop_duplicates(subset=['집행ID'], keep='last')

    # 통계 반환
    stats = {
        'rows_processed': len(df),
        'rows_inserted': len(df)
    }

    return df, stats
```

**Refactor Phase:**
- 컬럼명 상수화
- 타입 변환 함수 분리
- 에러 메시지 개선

**추가 Red Phase 시나리오 (Edge Cases):**

```python
def test_parse_missing_required_column():
    # Arrange: '집행ID' 컬럼 누락된 CSV
    file_path = 'tests/fixtures/research_missing_column.csv'

    # Act & Assert
    with pytest.raises(ValueError, match="필수 컬럼 누락"):
        parse_research_project_data(file_path)

def test_parse_invalid_date_format():
    # Arrange: 날짜 컬럼에 'abc' 값
    file_path = 'tests/fixtures/research_invalid_date.csv'

    # Act
    df, stats = parse_research_project_data(file_path)

    # Assert: 해당 행 제외
    assert stats['rows_processed'] > stats['rows_inserted']

def test_parse_duplicate_pk():
    # Arrange: 동일 집행ID 2건
    file_path = 'tests/fixtures/research_duplicate.csv'

    # Act
    df, stats = parse_research_project_data(file_path)

    # Assert: 마지막 행만 유지
    assert df['집행ID'].nunique() == len(df)

def test_parse_business_logic_validation():
    # Arrange: 집행금액 > 총연구비
    file_path = 'tests/fixtures/research_invalid_amount.csv'

    # Act
    df, stats = parse_research_project_data(file_path)

    # Assert: 해당 행 제외
    assert all(df['집행금액'] <= df['총연구비'])
```

**Implementation Order (TDD Cycle):**
1. Red: parse_valid_research_project_data 테스트
2. Green: 최소 구현 (파일 로드 + 컬럼 검증)
3. Refactor: 타입 변환 추가
4. Red: parse_missing_required_column 테스트
5. Green: ValueError 예외 발생
6. Red: parse_invalid_date_format 테스트
7. Green: errors='coerce' + dropna 구현
8. Red: parse_duplicate_pk 테스트
9. Green: drop_duplicates 추가
10. Red: parse_business_logic_validation 테스트
11. Green: 비즈니스 로직 필터링
12. Refactor: 공통 로직 함수 분리
13. Red ~ Refactor: 나머지 3개 파서 반복 구현

**Dependencies:** None (인프라 독립적)

---

#### 3.2.2 Ingestion Service - Orchestration
**Location:** `backend/data_ingestion/services/ingestion_service.py`

**Responsibility:**
- 파일 업로드 → 파싱 → 저장 플로우 조정
- 백그라운드 작업 관리 (ThreadPoolExecutor)
- 작업 상태 업데이트
- 에러 핸들링 및 임시 파일 정리

**Test Strategy:** Integration Test (Mock 사용)

**Test Scenarios:**

**Red Phase:**
```python
from unittest.mock import patch, MagicMock
from data_ingestion.services.ingestion_service import submit_upload_job

def test_submit_upload_job_returns_job_id():
    # Arrange
    files = {'research_funding': MagicMock()}

    # Act
    job_id = submit_upload_job(files)

    # Assert
    assert job_id is not None
    assert isinstance(job_id, str)
    assert len(job_id) == 36  # UUID 길이

def test_process_upload_updates_job_status():
    # Arrange
    job_id = 'test-job-id'
    files = {'research_funding': 'tests/fixtures/research_valid.csv'}

    # Act
    process_upload(job_id, files)

    # Assert
    status = get_job_status(job_id)
    assert status['status'] == 'completed'
    assert status['progress'] == 100
```

**Green Phase:**
```python
from concurrent.futures import ThreadPoolExecutor
import uuid

executor = ThreadPoolExecutor(max_workers=1)

def submit_upload_job(files):
    job_id = str(uuid.uuid4())
    create_job(job_id, status='processing', progress=0)

    executor.submit(process_upload, job_id, files)

    return job_id

def process_upload(job_id, files):
    try:
        # 1. 파일 저장
        temp_dir = save_uploaded_files(files)

        # 2. 파싱
        df, stats = parse_research_project_data(temp_dir + '/research.csv')

        # 3. DB 저장
        save_research_funding_data(df, replace=True)

        # 4. 상태 업데이트
        update_job_status(job_id, status='completed', progress=100)
    except Exception as e:
        update_job_status(job_id, status='failed', error=str(e))
    finally:
        cleanup_temp_files(temp_dir)
```

**Refactor Phase:**
- 파일 타입별 처리 루프
- 부분 성공 처리 (파일별 독립 트랜잭션)
- 에러 로깅 추가

**Edge Cases:**
- Red: DB 에러 발생 시 status='failed' 업데이트
- Red: 파싱 에러 발생 시 에러 메시지 저장
- Red: 임시 파일 정리 실패 시 로그만 기록 (작업은 성공 처리)

**Implementation Order:**
1. Red: submit_upload_job 테스트
2. Green: ThreadPoolExecutor 기본 구현
3. Red: process_upload 성공 시나리오
4. Green: 파싱 + 저장 통합
5. Refactor: try-except-finally 구조
6. Red: 파싱 에러 시나리오
7. Green: 에러 핸들링
8. Refactor: 4개 파일 타입 루프 처리

**Dependencies:**
- excel_parser.py
- repositories.py
- file_storage.py
- job_status_store.py

---

### 3.3 Backend - Presentation Layer

#### 3.3.1 Admin API Key Permission
**Location:** `backend/data_ingestion/api/permissions.py`

**Responsibility:**
- HTTP 헤더 `X-Admin-Key` 검증
- 환경 변수와 비교하여 권한 확인

**Test Strategy:** Unit Test

**Test Scenarios:**
```python
def test_admin_api_key_permission_valid_key():
    # Arrange
    request = MagicMock()
    request.META = {'HTTP_X_ADMIN_KEY': settings.ADMIN_API_KEY}
    permission = AdminAPIKeyPermission()

    # Act
    result = permission.has_permission(request, None)

    # Assert
    assert result is True

def test_admin_api_key_permission_invalid_key():
    # Arrange
    request = MagicMock()
    request.META = {'HTTP_X_ADMIN_KEY': 'wrong_key'}
    permission = AdminAPIKeyPermission()

    # Act
    result = permission.has_permission(request, None)

    # Assert
    assert result is False
```

**Implementation Order:**
1. Red: 테스트 작성
2. Green: BasePermission 상속 구현
3. Refactor: 에러 메시지 추가

**Dependencies:** None

---

#### 3.3.1.1 API Response Schema

**Upload API Response (POST /api/upload/)**

**202 Accepted:**
```json
{
  "status": "processing",
  "job_id": "uuid-v4-string",
  "message": "파일 업로드가 시작되었습니다.",
  "estimated_time": "약 30초 소요 예상"
}
```

**Status API Response (GET /api/upload/status/{job_id}/)**

**200 OK:**
```json
{
  "job_id": "uuid-v4-string",
  "status": "completed",
  "progress": 100,
  "files": [
    {
      "file_type": "research_funding",
      "status": "completed",
      "rows_processed": 1523,
      "rows_inserted": 1498,
      "rows_skipped": 25,
      "errors": []
    }
  ],
  "completed_at": "2025-11-02T14:35:22Z"
}
```

---

#### 3.3.2 Upload Serializer
**Location:** `backend/data_ingestion/api/serializers.py`

**Responsibility:**
- 파일 업로드 요청 데이터 검증
- 파일 크기, 형식 검증
- MIME 타입 검증

**Test Strategy:** Unit Test

**Test Scenarios:**
```python
def test_upload_serializer_valid_file():
    # Arrange
    file = SimpleUploadedFile('test.csv', b'data', content_type='text/csv')
    data = {'research_funding': file}

    # Act
    serializer = UploadSerializer(data=data)

    # Assert
    assert serializer.is_valid()

def test_upload_serializer_file_too_large():
    # Arrange: 11MB 파일
    file = SimpleUploadedFile('test.csv', b'x' * 11 * 1024 * 1024)
    data = {'research_funding': file}

    # Act
    serializer = UploadSerializer(data=data)

    # Assert
    assert not serializer.is_valid()
    assert 'research_funding' in serializer.errors
```

**Implementation Order:**
1. Red: 파일 크기 검증 테스트
2. Green: validate_file_size 메서드
3. Red: MIME 타입 검증 테스트
4. Green: python-magic 사용 구현
5. Refactor: 검증 로직 분리

**Dependencies:** None

---

#### 3.3.2.1 보안 검증 체크리스트

**Security Validations:**
- ✅ CSRF Token: DRF `@csrf_exempt` for API endpoints (JWT/API Key auth)
- ✅ XSS Prevention: DRF auto-escapes JSON responses
- ✅ File Upload Validation: MIME type check + file extension whitelist (.csv, .xlsx)
- ✅ SQL Injection: Django ORM parameterized queries (no raw SQL)
- ✅ API Rate Limiting: `[POST-MVP]` DRF throttling

**Test Scenarios:**
```python
def test_invalid_api_key_returns_403():
    """Assert: 잘못된 API Key로 403 Forbidden 응답"""
    client = APIClient()
    client.credentials(HTTP_X_ADMIN_KEY='wrong_key')
    response = client.post('/api/upload/', {})
    assert response.status_code == 403

def test_file_mime_type_validation():
    """Assert: .exe 파일 업로드 시 ValidationError"""
    file = SimpleUploadedFile('malware.exe', b'binary_data', content_type='application/x-msdownload')
    data = {'research_funding': file}
    serializer = UploadSerializer(data=data)
    assert not serializer.is_valid()
    assert 'research_funding' in serializer.errors
```

---

#### 3.3.3 Upload ViewSet
**Location:** `backend/data_ingestion/api/views.py`

**Responsibility:**
- POST /api/upload/ 엔드포인트
- 파일 수신 및 Serializer 검증
- IngestionService 호출
- HTTP 202 응답 반환

**Test Strategy:** Integration Test (DRF TestCase)

**Test Scenarios:**
```python
from django.test import TestCase
from rest_framework.test import APIClient

class UploadViewSetTest(TestCase):
    def setUp(self):
        self.client = APIClient()
        self.client.credentials(HTTP_X_ADMIN_KEY=settings.ADMIN_API_KEY)

    def test_upload_api_success(self):
        # Arrange
        file = open('tests/fixtures/research_valid.csv', 'rb')

        # Act
        response = self.client.post('/api/upload/', {
            'research_funding': file
        }, format='multipart')

        # Assert
        assert response.status_code == 202
        assert 'job_id' in response.data
        assert response.data['status'] == 'processing'

    def test_upload_api_no_api_key(self):
        # Arrange
        self.client.credentials()  # 헤더 제거

        # Act
        response = self.client.post('/api/upload/', {})

        # Assert
        assert response.status_code == 403
```

**Implementation Order:**
1. Red: 성공 시나리오 테스트
2. Green: ViewSet 기본 구현
3. Refactor: Permission 적용
4. Red: 권한 없음 시나리오
5. Green: AdminAPIKeyPermission 적용
6. Refactor: 에러 응답 통일

**Dependencies:**
- permissions.py
- serializers.py
- ingestion_service.py

---

#### 3.3.4 Status ViewSet
**Location:** `backend/data_ingestion/api/views.py`

**Responsibility:**
- GET /api/upload/status/{job_id}/ 엔드포인트
- JobStatusStore에서 상태 조회
- 상태 응답 반환

**Test Strategy:** Integration Test

**Test Scenarios:**
```python
def test_status_api_processing():
    # Arrange
    job_id = create_job('test-job', status='processing', progress=50)

    # Act
    response = self.client.get(f'/api/upload/status/{job_id}/')

    # Assert
    assert response.status_code == 200
    assert response.data['status'] == 'processing'
    assert response.data['progress'] == 50

def test_status_api_job_not_found():
    # Act
    response = self.client.get('/api/upload/status/invalid-id/')

    # Assert
    assert response.status_code == 404
```

**Implementation Order:**
1. Red: 상태 조회 성공 테스트
2. Green: ViewSet 구현
3. Red: 존재하지 않는 job_id 테스트
4. Green: 404 응답 처리
5. Refactor: Serializer 추가 (응답 구조화)

**Dependencies:** job_status_store.py

---

### 3.4 Frontend - Upload UI

#### 3.4.1 File Upload Component
**Location:** `frontend/src/components/upload/FileUploadForm.jsx`

**Responsibility:**
- 파일 선택 UI (드래그앤드롭 또는 버튼)
- 클라이언트 검증 (크기, 확장자)
- API 호출 (dataApiClient)

**Test Strategy:** Unit Test (React Testing Library)

**Test Scenarios:**
```javascript
import { render, screen, fireEvent } from '@testing-library/react'
import FileUploadForm from './FileUploadForm'

test('renders file upload form', () => {
  render(<FileUploadForm />)
  expect(screen.getByText(/파일 선택/i)).toBeInTheDocument()
})

test('shows error for file too large', () => {
  const file = new File(['x'.repeat(11 * 1024 * 1024)], 'test.csv')
  render(<FileUploadForm />)

  const input = screen.getByLabelText(/파일 선택/i)
  fireEvent.change(input, { target: { files: [file] } })

  expect(screen.getByText(/파일 크기가 10MB를 초과합니다/i)).toBeInTheDocument()
})
```

**Implementation Order:**
1. Red: 기본 렌더링 테스트
2. Green: 컴포넌트 기본 구조
3. Red: 파일 크기 검증 테스트
4. Green: 검증 로직 추가
5. Refactor: Custom Hook 분리 (useFileValidator)

**Dependencies:** None

---

#### 3.4.2 Status Polling Hook
**Location:** `frontend/src/hooks/useUploadStatus.js`

**Responsibility:**
- 3초 간격 상태 폴링
- 완료/실패 시 폴링 중단
- 상태 데이터 반환

**Test Strategy:** Unit Test (jest 타이머 Mock)

**Test Scenarios:**
```javascript
import { renderHook, waitFor } from '@testing-library/react'
import useUploadStatus from './useUploadStatus'

test('polls status every 3 seconds', async () => {
  jest.useFakeTimers()
  const mockFetch = jest.fn().mockResolvedValue({ status: 'processing' })

  const { result } = renderHook(() => useUploadStatus('job-id', mockFetch))

  jest.advanceTimersByTime(3000)
  await waitFor(() => expect(mockFetch).toHaveBeenCalledTimes(1))

  jest.advanceTimersByTime(3000)
  await waitFor(() => expect(mockFetch).toHaveBeenCalledTimes(2))
})

test('stops polling when status is completed', async () => {
  const mockFetch = jest.fn()
    .mockResolvedValueOnce({ status: 'processing' })
    .mockResolvedValueOnce({ status: 'completed' })

  const { result } = renderHook(() => useUploadStatus('job-id', mockFetch))

  await waitFor(() => expect(result.current.status).toBe('completed'))

  jest.advanceTimersByTime(3000)
  expect(mockFetch).toHaveBeenCalledTimes(2) // 더 이상 호출 안 됨
})
```

**Implementation Order:**
1. Red: 폴링 간격 테스트
2. Green: setInterval 구현
3. Red: 완료 시 폴링 중단 테스트
4. Green: clearInterval 조건 추가
5. Refactor: useEffect cleanup

**Dependencies:** dataApiClient.js

---

### 3.5 QA Sheet (Manual Testing - Presentation Layer)

| 시나리오 | 단계 | 기대 결과 | 상태 |
|---------|------|----------|------|
| 파일 업로드 성공 | 1. 관리자 페이지 접근<br>2. 유효한 CSV 파일 4개 선택<br>3. 업로드 시작 클릭<br>4. 상태 폴링 대기<br>5. 완료 메시지 확인 | 모든 파일 성공, "총 XXX건의 데이터가 등록되었습니다" 표시 | ☐ |
| 권한 없는 접근 차단 | 1. 잘못된 API Key로 접근 시도 | 403 Forbidden 에러, "관리자 권한이 없습니다" 메시지 | ☐ |
| 파일 크기 초과 검증 | 1. 11MB 파일 업로드 시도 | "파일 크기가 10MB를 초과합니다" 에러 표시, 업로드 중단 | ☐ |
| 필수 컬럼 누락 처리 | 1. '학과' 컬럼 없는 CSV 업로드 | "필수 컬럼 '학과'가 누락되었습니다" 에러 표시 | ☐ |
| 부분 성공 시나리오 | 1. 4개 파일 중 1개 실패<br>2. 재업로드 옵션 확인 | 3개 성공 표시, 실패한 1개 파일만 재업로드 가능 | ☐ |
| 네트워크 단절 복구 | 1. 업로드 중 네트워크 차단<br>2. 재연결 후 수동 재시도 | "네트워크 연결을 확인하세요" 메시지, 재시도 버튼 활성화 | ☐ |

---

## 4. TDD Workflow

### 4.1 구현 순서 (Inside-Out 전략)

**Phase 1: Infrastructure (1-2일)**
1. Django Models (테스트 → 구현 → Migration)
2. Repositories (전체 교체 모드)
3. File Storage (임시 파일 관리)
4. Job Status Store (Thread-safe)

**Phase 2: Core Logic (2-3일)**
1. Excel Parser - Research (TDD 사이클 5회 이상)
2. Excel Parser - Student
3. Excel Parser - Publication
4. Excel Parser - KPI
5. 공통 로직 Refactoring

**Phase 3: Service Orchestration (1-2일)**
1. Ingestion Service (Mock 기반 테스트)
2. 백그라운드 작업 통합
3. 에러 핸들링 추가

**Phase 4: API Layer (1일)**
1. Admin API Key Permission
2. Upload Serializer
3. Upload ViewSet (Integration Test)
4. Status ViewSet

**Phase 5: Frontend (2-3일)**
1. File Upload Component
2. Status Polling Hook
3. UI 통합 및 QA

**Phase 6: E2E Testing (1일)**
1. Happy Path E2E 테스트
2. 버그 수정 및 최종 검증

### 4.2 Commit 포인트 제안

- ✅ Red: Models 테스트 작성
- ✅ Green: Models 구현 완료
- ✅ Refactor: Migration 생성
- ✅ Red: Repository 테스트 추가
- ✅ Green: Repository 구현 완료
- ✅ Red: ExcelParser - Research 첫 테스트
- ✅ Green: ExcelParser - Research 기본 구현
- ✅ Refactor: 타입 변환 로직 분리
- ✅ Red: ExcelParser - 모든 Edge Case 테스트
- ✅ Green: ExcelParser - 완전 구현
- ✅ Refactor: 4개 파서 공통 로직 통합
- ✅ Red: IngestionService 테스트
- ✅ Green: IngestionService 구현
- ✅ Red: Upload API Integration Test
- ✅ Green: Upload API 완료
- ✅ Red: Frontend 테스트
- ✅ Green: Frontend 구현
- ✅ E2E: Happy Path 통과

### 4.3 완료 기준

**All Tests Green:**
- Unit Tests: 50개 이상, 모두 통과
- Integration Tests: 10개 이상, 모두 통과
- E2E Tests: 1개 (Happy Path), 통과

**Code Quality:**
- ExcelParser 코드 커버리지 90% 이상
- Refactoring 완료 (중복 코드 제거)
- 에러 메시지 명확성 확인

**Manual QA:**
- QA Sheet 6개 시나리오 모두 통과

---

## 5. Risk Mitigation (TDD 기반)

### 5.1 높은 리스크 영역

| 영역 | 리스크 | TDD 완화 전략 |
|------|--------|--------------|
| Pandas 파싱 | 예상치 못한 데이터 형식 | Edge Case 테스트 15개 이상 작성 |
| 동시성 | 멀티스레드 데이터 경합 | Threading Lock 단위 테스트 |
| DB 트랜잭션 | 부분 저장 또는 롤백 실패 | Integration Test로 트랜잭션 검증 |
| 네트워크 | 폴링 중 연결 끊김 | Mock 기반 네트워크 실패 시뮬레이션 |

### 5.2 테스트 우선순위

**P0 (구현 전 필수):**
- ExcelParser 모든 Edge Case
- Repository 트랜잭션 테스트
- JobStatusStore Thread-safe 테스트

**P1 (구현 중 필수):**
- Upload API Integration Test
- Frontend 파일 검증 테스트

**P2 (구현 후 선택):**
- E2E 네트워크 실패 시나리오
- 성능 테스트 (10MB 파일 처리 시간)

---

## 6. 핵심 원칙 재확인

### FIRST Principles
- ✅ **Fast**: Unit Tests < 100ms, Integration Tests < 3s
- ✅ **Independent**: 각 테스트 격리 (DB Fixture 초기화)
- ✅ **Repeatable**: Mock 기반 외부 의존성 제거
- ✅ **Self-validating**: assert 명확, 수동 확인 불필요
- ✅ **Timely**: 코드보다 테스트 먼저 작성

### Test Pyramid
- Unit Tests: 50-60개 (70%)
- Integration Tests: 10-15개 (20%)
- E2E Tests: 1-2개 (10%)

### Red → Green → Refactor
- **Small Steps**: 한 번에 하나의 시나리오만
- **Fast Feedback**: 테스트 실행 < 5초
- **Commit Frequently**: Green 상태마다 커밋

---

## 문서 변경 이력

| 버전 | 날짜 | 변경 사항 | 작성자 |
|------|------|-----------|--------|
| 1.0 | 2025-11-02 | TDD 기반 모듈화 설계 초안 작성 | Plan Writer Agent |

---

## 승인 및 검토

**작성자:** Plan Writer Agent
**검토자:** CTO
**승인일:** 2025-11-02

본 구현 계획은 TDD 원칙에 따라 테스트 우선 접근 방식으로 설계되었으며, MVP에 필요한 최소한의 기능만 포함합니다.

---

**문서 끝**
</file>

<file path="001-csv-upload/spec.md">
# CSV/Excel 파일 업로드 기능 상세 유스케이스 명세

**기능명:** CSV/Excel 파일 업로드 및 데이터 파싱 (P0-MVP)
**작성일:** 2025-11-02
**버전:** 1.2 (CTO 검증 피드백 반영)
**작성자:** Spec Writer Agent
**수정자:** Claude Code

---

## 1. 기능 개요

### 1.1 목적
관리자가 Ecount 시스템에서 추출한 4가지 타입의 CSV/Excel 데이터 파일을 웹 대시보드에 업로드하고, 백그라운드에서 비동기 파싱/검증/저장하여 시각화 대시보드에 최신 데이터를 제공하는 기능

### 1.2 범위
- **포함:**
  - 관리자 페이지 접근 제어 (하드코딩 API Key)
  - 4가지 파일 타입 업로드: research_project_data.csv, student_roster.csv, publication_list.csv, department_kpi.csv
  - 클라이언트/서버 파일 검증 (크기, 형식, 필수 컬럼)
  - 비동기 백그라운드 처리 (Python threading)
  - Pandas 데이터 파싱/정제/검증
  - Supabase 저장 (전체 교체 모드)
  - 작업 상태 폴링 (3초 간격)
  - 업로드 성공/실패 피드백

- **제외 (POST-MVP):**
  - DB 기반 사용자 인증 시스템
  - 증분 업데이트 (UPSERT)
  - 파일 프리뷰 기능
  - 부분 성공 처리
  - 에러 로그 다운로드
  - 자동 백업/롤백

### 1.3 제약 사항
- 최대 파일 크기: 10MB
- 지원 형식: .csv, .xlsx, .xls
- 비동기 처리 필수 (Non-blocking UI)
- 인증: 하드코딩된 API Key만 사용

---

## 2. 구현 전 필수 검증 사항

### 2.1 Ecount CSV 샘플 데이터 검증 (P0 - 구현 시작 전 필수)

**목적:** 스펙에 정의된 컬럼명/타입이 실제 Ecount 추출 CSV와 일치하는지 검증

**작업 절차:**
1. **샘플 데이터 확보**
   - 관리자에게 Ecount 시스템에서 4가지 CSV 파일 추출 요청
   - 각 파일은 최소 10~50행의 실제 데이터 포함
   - 저장 경로: `docs/db/samples/`

2. **Pandas 로드 테스트**
   ```python
   import pandas as pd

   # 각 CSV 파일 로드 테스트
   files = [
       'research_project_data.csv',
       'student_roster.csv',
       'publication_list.csv',
       'department_kpi.csv'
   ]

   for file in files:
       try:
           df = pd.read_csv(f'docs/db/samples/{file}', encoding='utf-8')
           print(f"\n=== {file} ===")
           print(f"컬럼: {df.columns.tolist()}")
           print(f"데이터 타입:\n{df.dtypes}")
           print(f"샘플 데이터:\n{df.head(3)}")
           print(f"결측값:\n{df.isnull().sum()}")
       except Exception as e:
           print(f"ERROR loading {file}: {e}")
   ```

3. **검증 체크리스트**
   - [ ] 컬럼명이 스펙(5.2.1절)과 정확히 일치
   - [ ] 데이터 타입이 예상과 일치 (날짜, 숫자, 문자열)
   - [ ] 인코딩이 UTF-8인지 확인 (또는 EUC-KR/CP949)
   - [ ] 숨겨진 컬럼/행이 없는지 확인 (Excel에서 확인)
   - [ ] 예상치 못한 특수문자/공백이 없는지 확인

4. **불일치 발견 시 조치**
   - 컬럼명 불일치: 스펙 5.2.1절 CSV-Django 매핑 테이블 수정
   - 데이터 타입 불일치: 파서 로직 조정 (excel_parser.py)
   - 인코딩 문제: 인코딩 전략 재검토 (UTF-8 외 지원 필요 여부)

**완료 조건:**
- 4개 CSV 샘플 파일 확보 완료
- Pandas 로드 성공 확인 (에러 없음)
- 컬럼명 정확성 검증 완료
- 스펙 업데이트 필요 시 반영 완료

**책임자:** 백엔드 개발자 + 데이터 관리자
**기한:** 구현 시작 전 (1일 이내)

---

## 3. 사용자 스토리

### 3.1 Primary Actor
**관리자 (Admin User)**
- Ecount 시스템 데이터 추출 권한 보유
- 대시보드 데이터 업로드 책임
- 기술적 숙련도: 중급

### 3.2 사용자 스토리 (GIVEN-WHEN-THEN)

**Story 1: 파일 업로드 성공**
```
GIVEN 관리자가 관리자 페이지에 접근 권한이 있고
  AND 유효한 4가지 CSV 파일을 준비했을 때
WHEN 파일 선택 후 "업로드 시작" 버튼을 클릭하면
THEN 파일이 비동기로 처리되고
  AND 처리 진행 상태가 실시간 표시되며
  AND 완료 시 성공 메시지와 함께 처리 결과를 확인할 수 있다
```

**Story 2: 파일 검증 실패**
```
GIVEN 관리자가 잘못된 형식의 파일을 선택했을 때
WHEN 파일 선택 시점 또는 업로드 요청 시
THEN 구체적인 에러 메시지가 표시되고
  AND 업로드가 중단되며
  AND 파일 수정 후 재시도할 수 있다
```

**Story 3: 데이터 파싱 실패**
```
GIVEN 파일 업로드는 성공했으나
  AND 데이터에 필수 컬럼 누락 또는 타입 오류가 있을 때
WHEN 백그라운드 파싱 중
THEN 작업 상태가 "failed"로 변경되고
  AND 구체적인 에러 정보(파일명, 행 번호, 에러 내용)가 표시되며
  AND 관리자가 데이터 수정 후 재업로드할 수 있다
```

---

## 3. 상세 유스케이스

### 3.1 관리자 페이지 접근 및 인증

#### Precondition
- 사용자: 관리자 권한 보유
- 시스템: 백엔드 API 서버 및 Supabase 정상 작동

#### Trigger
- 관리자가 `/admin/upload` URL 직접 접근
- 또는 메인 대시보드에서 "데이터 업로드" 버튼 클릭 (관리자 모드 활성화 시)

#### Main Scenario
1. 사용자가 데이터 업로드 페이지 URL 접근
2. React 앱에서 `process.env.ADMIN_MODE === 'true'` 또는 하드코딩된 API Key 검증
3. 권한 확인 성공 시 파일 업로드 UI 렌더링
   - 4가지 파일 타입별 업로드 영역 표시
   - 드래그앤드롭 또는 파일 선택 버튼 제공
   - 지원 형식 및 크기 제한 안내 표시

#### Edge Cases
- **권한 없음:** 메인 대시보드로 리디렉션 + "관리자 권한이 필요합니다" 토스트 알림
- **환경 변수 미설정:** "시스템 관리자에게 문의하세요" 에러 페이지
- **API Key 만료/변경:** "인증 정보가 유효하지 않습니다" 에러 메시지

#### Business Rules
- BR-001: 관리자 접근 제어는 환경 변수 또는 하드코딩된 API Key로만 구현 (DB 기반 인증 금지)
- BR-002: 권한 없는 사용자는 업로드 페이지 접근 불가

---

### 3.2 파일 선택 및 클라이언트 검증

#### Precondition
- 사용자: 데이터 업로드 페이지 접근 완료
- 시스템: 파일 업로드 UI 렌더링 완료

#### Trigger
- 사용자가 파일 선택 다이얼로그에서 파일 선택
- 또는 파일을 업로드 영역에 드래그앤드롭

#### Main Scenario
1. 사용자가 CSV/Excel 파일 선택 (1~4개)
2. 프런트엔드에서 즉시 검증:
   - 파일 확장자: `.csv`, `.xlsx`, `.xls`만 허용
   - 파일 크기: 최대 10MB
   - (선택적) 파일명 패턴 매칭
3. 검증 통과 시:
   - 선택된 파일 정보 카드 표시 (파일명, 크기, 타입)
   - "준비됨" 상태 아이콘 표시
   - "업로드 시작" 버튼 활성화
4. 검증 실패 시:
   - 해당 파일 하이라이트
   - 구체적인 에러 메시지 표시
   - "업로드 시작" 버튼 비활성화

#### Edge Cases
- **동일 파일 중복 선택:** 최신 선택 파일로 교체 + "기존 파일이 교체됩니다" 경고
- **비표준 인코딩 (EUC-KR, CP949):** UTF-8, EUC-KR, CP949 순서로 자동 감지 시도
- **빈 파일 (0 byte):** "빈 파일입니다. 데이터가 포함된 파일을 선택하세요" 경고
- **숨겨진 행/컬럼 (Excel):** Pandas에서 자동으로 숨겨진 데이터 포함하여 파싱

#### Business Rules
- BR-003: 지원 형식: CSV (.csv), Excel (.xlsx, .xls)만 허용
- BR-004: 최대 파일 크기: 10MB (초과 시 업로드 거부)
- BR-005: 클라이언트 검증은 사용자 경험 개선용, 서버 검증 필수

---

### 3.3 파일 업로드 요청 및 백그라운드 처리 시작

#### Precondition
- 사용자: 1개 이상의 유효한 파일 선택 완료
- 시스템: "업로드 시작" 버튼 활성화 상태

#### Trigger
- 사용자가 "업로드 시작" 버튼 클릭

#### Main Scenario
1. 프런트엔드에서 FormData 객체 생성
   - 각 파일 바이너리 데이터 추가
   - 파일 타입 정보 (research_funding, students, publications, kpi) 포함
   - 업로드 타임스탬프 추가
2. HTTP 요청 헤더에 하드코딩된 API Key 포함: `X-Admin-Key: <키값>`
3. `POST /api/upload/` 엔드포인트 호출 (Content-Type: multipart/form-data, Timeout: 60초)
4. DRF View에서 요청 수신 및 처리:
   - **API Key 검증 (View 레벨 Custom Permission Class 사용)**
   - Request Serializer를 통한 파일 형식 재검증
   - 파일을 임시 저장 경로에 저장 (`/tmp/upload_{uuid4()}/` - UUID로 충돌 방지)
5. 비동기 백그라운드 작업 등록:
   - **`concurrent.futures.ThreadPoolExecutor`에 파싱 작업 제출 (최대 3개 worker)**
   - 고유한 `job_id` (UUID) 생성
   - **작업 상태 저장소: 메모리 기반 Dictionary** (`job_status_store = {}`)
   - 작업 상태 초기화: `job_status_store[job_id] = {"status": "processing", "progress": 0}`
6. 즉시 HTTP 202 Accepted 응답 반환 (Non-blocking)
   ```json
   {
     "status": "processing",
     "job_id": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
     "message": "파일 업로드가 시작되었습니다. 처리가 완료되면 알려드리겠습니다.",
     "estimated_time": "약 30초 소요 예상"
   }
   ```
7. 프런트엔드 UI 변경:
   - "업로드 중... 데이터를 처리하고 있습니다" 메시지
   - 각 파일별 프로그레스 바 애니메이션
   - 작업 상태 폴링 시작 (3초 간격, `GET /api/upload/status/{job_id}/`)

#### 3.3.1 기술 구현 세부사항

**API Key 검증 (View 레벨):**
```python
# api/permissions.py
from rest_framework.permissions import BasePermission
from django.conf import settings

class AdminAPIKeyPermission(BasePermission):
    def has_permission(self, request, view):
        api_key = request.META.get('HTTP_X_ADMIN_KEY')
        return api_key == settings.ADMIN_API_KEY
```

**백그라운드 작업 관리 (ThreadPoolExecutor):**
```python
# services/ingestion_service.py
from concurrent.futures import ThreadPoolExecutor
import uuid

# 모듈 레벨 변수
executor = ThreadPoolExecutor(max_workers=3)
job_status_store = {}  # {job_id: {"status": "...", "progress": 0, ...}}

def submit_upload_job(files):
    job_id = str(uuid.uuid4())
    job_status_store[job_id] = {"status": "processing", "progress": 0}

    # 백그라운드 작업 제출
    executor.submit(process_upload, job_id, files)

    return job_id
```

**작업 상태 저장소 (MVP - 메모리 기반):**
- **저장소**: Python Dictionary (메모리 기반)
- **제약**: 서버 재시작 시 상태 손실 (POST-MVP에서 Redis/DB 전환 고려)
- **동시성 제어**: Dictionary는 Thread-safe하지 않으므로 `threading.Lock()` 사용 필수 (아래 구현 예시 참조)
- **임시 파일 경로**: `/tmp/upload_{uuid4()}/` (UUID v4로 충돌 방지, 디렉토리 권한 0o700)

#### 3.3.2 메모리 기반 저장소 제약 사항 및 동시성 제어

**MVP 허용 제약:**
1. **서버 재시작 시 진행 중인 작업 상태 손실**
   - 백그라운드 처리는 계속 진행되지만, UI에서 상태 추적 불가
   - 사용자 액션: 새로고침 후 "작업 정보를 찾을 수 없습니다" 메시지 표시
   - 해결: POST-MVP에서 Redis/DB 전환

2. **동시성 제어 구현 (필수)**
   - Dictionary는 Thread-safe하지 않으므로 `threading.Lock()` 사용
   ```python
   import threading

   # 모듈 레벨 변수
   job_status_store = {}
   job_lock = threading.Lock()

   def update_job_status(job_id, status_data):
       """Thread-safe하게 작업 상태 업데이트"""
       with job_lock:
           job_status_store[job_id] = status_data

   def get_job_status(job_id):
       """Thread-safe하게 작업 상태 조회"""
       with job_lock:
           return job_status_store.get(job_id)
   ```

**CTO 승인 사항:**
- 내부 베타 테스트 기간 중 서버 재배포는 업무 외 시간에만 수행
- 작업 진행 중 재배포 필요 시 사전 공지

#### Edge Cases
- **API Key 불일치 (403 Forbidden):** "관리자 권한이 없습니다" 에러 모달 + 메인 대시보드 리디렉션
- **파일 검증 실패 (400 Bad Request):** 구체적인 검증 에러 메시지 표시 (파일명, 누락 컬럼 등)
- **서버 에러 (500 Internal Server Error):** "서버 오류가 발생했습니다. 잠시 후 다시 시도하세요" 토스트 + "재시도" 버튼
- **네트워크 단절:** 타임아웃 → "네트워크 연결을 확인하세요" 메시지 + 수동 재시도 버튼 (자동 재시도는 POST-MVP)
- **동시 다중 업로드:** 작업 큐에서 순차 또는 병렬 처리 (서버 리소스 기반)
- **파일 전송 중 사용자 이탈:** 브라우저 새로고침/이탈 확인 모달, 백그라운드 처리는 계속 진행

#### Business Rules
- BR-006: 비동기 백그라운드 처리 필수 (사용자 UI 블로킹 금지)
- BR-007: 작업 ID (UUID)로 진행 상태 추적 가능
- BR-008: HTTP 202 Accepted 즉시 반환 (처리 완료 대기 금지)
- BR-009: API Key 검증 실패 시 403 Forbidden 반환

---

### 3.4 백그라운드 데이터 파싱 (Pandas 로직)

#### Precondition
- 시스템: 파일이 임시 저장 경로에 저장 완료
- 시스템: 백그라운드 작업 큐에 파싱 작업 등록 완료

#### Trigger
- 백그라운드 Thread에서 파싱 함수 자동 실행

#### Main Scenario
1. 파일 타입별 전용 파서 선택 (`excel_parser.py`):
   - `parse_research_project_data(file_path)`
   - `parse_student_roster(file_path)`
   - `parse_publication_list(file_path)`
   - `parse_department_kpi(file_path)`

2. Pandas DataFrame 로드:
   - `pd.read_csv()` 또는 `pd.read_excel()` 사용
   - **MVP: UTF-8 인코딩만 지원** (실패 시 "UTF-8 인코딩으로 저장 후 재업로드" 안내)
   - POST-MVP: Ecount 기본 인코딩 확인 후 EUC-KR/CP949 지원 고려
   - 헤더 행 자동 감지 및 컬럼명 정규화

3. 필수 컬럼 존재 여부 검증:
   - **research_project_data:** `['집행ID', '소속학과', '총연구비', '집행일자', '집행금액']`
   - **student_roster:** `['학번', '학과', '학년', '과정구분', '학적상태']`
   - **publication_list:** `['논문ID', '학과', '저널등급', 'Impact Factor']`
   - **department_kpi:** `['평가년도', '학과', '졸업생 취업률(%)', '연간 기술이전 수입액(억원)']`
   - 누락 시 즉시 예외 발생 → 작업 상태 "failed"

4. 데이터 타입 변환:
   - 날짜 컬럼: `pd.to_datetime(df['집행일자'], errors='coerce')`
   - 금액/숫자: 쉼표 제거 → `pd.to_numeric(df['총연구비'], errors='coerce')`
   - 문자열: 양쪽 공백 제거 `df['소속학과'].str.strip()`

5. 데이터 정제 (Cleaning):
   - **결측값(NaN) 처리:**
     - 필수 컬럼: NaN 존재 시 해당 행 제외 + 경고 로그
     - 선택적 컬럼 (Impact Factor): NaN 허용 (NULL 저장)
   - **중복 제거:**
     - PK 기준 중복 검사 (학번, 논문ID, 집행ID)
     - 중복 발견 시 마지막 행 유지 (`df.drop_duplicates(subset=['PK'], keep='last')`)
     - 경고 로그: "중복 데이터 X건 발견, 최신 데이터로 유지"
   - **데이터 범위 검증:**
     - 학년: 1~4, 날짜: 미래 날짜 불허, 금액: 음수 불허, 취업률: 0~100%
     - 범위 위반 시 해당 행 제외 + 상세 에러 로그

6. 비즈니스 로직 검증:
   - 연구비: `집행금액 <= 총연구비`
   - 학생: `학적상태 IN ('재학', '휴학', '졸업')`
   - 논문: `저널등급 IN ('SCIE', 'KCI', ...)`

7. 정제 완료된 DataFrame 반환 + 파싱 통계 (총 행 수, 유효 행 수, 제외 행 수, 에러 로그)

#### Edge Cases
- **파싱 중 메모리 부족:** MVP에서는 10MB 제한으로 발생 가능성 낮음. 발생 시 "파일이 너무 큽니다" 에러 반환 (청크 처리는 POST-MVP)
- **인코딩 감지 실패:** UTF-8 파싱 실패 시 "UTF-8 인코딩으로 저장 후 재업로드하세요" 에러
- **빈 DataFrame (헤더만):** "데이터 행이 없습니다" 에러 반환
- **수십만 행 데이터:** POST-MVP (MVP는 10MB 제한으로 방지)

#### Business Rules
- BR-010: Pandas 파싱 로직은 인프라 독립적 (높은 테스트 용이성)
- BR-011: 필수 컬럼 누락 시 전체 파일 처리 실패
- BR-012: 데이터 타입 변환 실패 시 해당 행 제외 (전체 실패 아님)
- BR-013: 중복 PK는 최신 데이터 유지 (Last-Write-Wins)
- BR-014: Impact Factor는 NULL 허용 (필수 아님)

---

### 3.5 데이터베이스 저장 (Repositories 레이어)

#### Precondition
- 시스템: Pandas 파싱 성공 및 정제된 DataFrame 준비
- 시스템: Supabase (PostgreSQL) 정상 작동

#### Trigger
- `ingestion_service.py`에서 파싱 완료 후 Repository 함수 자동 호출

#### Main Scenario
1. Repository 함수 호출:
   - `repositories.py`의 `save_research_funding_data(dataframe, replace=True)`
   - (각 파일 타입별 저장 함수 존재)

2. 데이터 저장 전략 (MVP: 파일별 독립 트랜잭션):
   - **트랜잭션 범위**: 파일별 독립 트랜잭션 (4개 파일 → 4개 트랜잭션)
   - **이유**: 부분 성공 허용 (3개 성공, 1개 실패 시나리오 대응), 대용량 파일 처리 시 타임아웃 방지
   - Django ORM 트랜잭션 시작
   ```python
   from django.db import transaction

   with transaction.atomic():
       # 기존 데이터 삭제
       ResearchProject.objects.all().delete()
       # Bulk Insert
       ResearchProject.objects.bulk_create([
           ResearchProject(**row) for row in dataframe.to_dict('records')
       ])
   ```

3. 저장 결과 검증:
   - 삽입된 행 수 확인
   - 예상 행 수와 실제 삽입 행 수 비교
   - 불일치 시 경고 로그

4. 작업 상태 업데이트:
   - 성공 시: `status = "completed"`, 메타데이터 저장 (처리 행 수, 삽입 행 수, 소요 시간)
   - 실패 시: 트랜잭션 롤백, `status = "failed"`, 에러 정보 저장

5. 임시 파일 정리 (`finally` 블록):
   ```python
   import shutil
   import os

   temp_dir = f"/tmp/upload_{job_id}/"
   try:
       # 파싱 및 저장 로직
       pass
   finally:
       # 성공/실패 무관하게 임시 파일 정리
       if os.path.exists(temp_dir):
           try:
               shutil.rmtree(temp_dir)
           except Exception as e:
               logger.warning(f"임시 파일 정리 실패: {temp_dir}, 오류: {e}")
               # 정리 실패해도 작업 자체는 성공 처리
   ```

#### Edge Cases
- **DB 연결 실패:** 재시도 로직 (지수 백오프, 최대 3회), 모두 실패 시 에러 상태
- **DB 저장 공간 부족:** "데이터베이스 용량이 부족합니다" 에러 메시지
- **중복 PK 충돌:** 전체 교체 모드에서는 발생하지 않음 (기존 데이터 삭제 후 삽입)
- **외래 키 제약 위반:** 관련 데이터 누락 시 에러 메시지와 함께 실패 처리
- **트랜잭션 타임아웃:** 대용량 데이터 삽입 시 배치 크기 조정 (1000건씩)

#### Business Rules
- BR-015: MVP에서는 전체 교체 모드만 지원 (증분 업데이트 POST-MVP)
- BR-016: Django ORM 트랜잭션으로 원자성 보장 (All-or-Nothing)
- BR-017: 트랜잭션 실패 시 자동 롤백 (데이터 무결성 유지)
- BR-018: 재업로드 시 기존 데이터 전체 삭제 후 교체

---

### 3.5.1 부분 성공 시 UX 플로우

#### Precondition
- 사용자: 4개 파일 업로드 요청 완료
- 시스템: 파일별 독립 트랜잭션 처리 진행

#### Trigger
- 백그라운드 처리 결과: 일부 파일 성공, 일부 파일 실패

#### Main Scenario (부분 성공: 3개 성공, 1개 실패)

1. **상태 폴링 응답:**
   ```json
   {
     "job_id": "...",
     "status": "partial_success",
     "progress": 100,
     "files": [
       {
         "file_type": "research_funding",
         "status": "completed",
         "rows_inserted": 1498
       },
       {
         "file_type": "students",
         "status": "failed",
         "error_message": "필수 컬럼 '학과'가 누락되었습니다.",
         "error_details": "3번째 행부터 '학과' 컬럼 값이 비어있습니다."
       },
       {
         "file_type": "publications",
         "status": "completed",
         "rows_inserted": 856
       },
       {
         "file_type": "kpi",
         "status": "completed",
         "rows_inserted": 120
       }
     ]
   }
   ```

2. **프런트엔드 UI 표시:**
   - 주황색 경고 아이콘 + "업로드가 부분적으로 완료되었습니다"
   - 성공 파일 리스트: "research_funding, publications, kpi (총 3개)"
   - 실패 파일 상세:
     ```
     ❌ students.csv 처리 실패
     원인: 필수 컬럼 '학과'가 누락되었습니다.
     상세: 3번째 행부터 '학과' 컬럼 값이 비어있습니다.
     ```
   - 권장 조치: "Excel에서 해당 파일을 수정한 후 다시 업로드하세요"

3. **액션 옵션 제공:**
   - **[실패한 파일만 재업로드]** 버튼 (권장)
     - 클릭 시: 파일 선택 다이얼로그 열림 (students.csv만 선택 가능하도록 안내)
     - 업로드 시: 기존 성공한 3개 파일 데이터는 유지
     - 실패한 1개 파일만 다시 파싱/저장
   - **[전체 다시 업로드]** 버튼
     - 클릭 시: 페이지 초기화, 4개 파일 모두 재선택 가능

4. **실패한 파일만 재업로드 시 처리:**
   - POST 요청에 `retry_mode=true&file_type=students` 파라미터 추가
   - 백엔드에서 students 테이블만 DELETE → INSERT
   - 나머지 3개 테이블 데이터는 변경 없음

#### Edge Cases
- **4개 모두 실패:** `status: "failed"` (전체 실패 UI 표시)
- **4개 모두 성공:** `status: "completed"` (성공 UI 표시)
- **재업로드 중 또 실패:** 동일한 부분 성공 UI 반복, 무제한 재시도 가능

#### Business Rules
- BR-022: 파일별 독립 트랜잭션으로 부분 성공 허용
- BR-023: 부분 성공 시 실패한 파일만 재업로드 옵션 제공 (사용자 편의성)
- BR-024: 재업로드 시 성공한 파일 데이터는 변경하지 않음

---

### 3.6 업로드 상태 확인 및 사용자 피드백

#### Precondition
- 사용자: 파일 업로드 요청 완료 및 `job_id` 수신
- 시스템: 백그라운드 작업 진행 중 또는 완료

#### Trigger
- 프런트엔드에서 3초 간격 자동 폴링 시작
- 또는 사용자가 "상태 새로고침" 버튼 클릭 (선택적)

#### Main Scenario
1. 상태 조회 API 호출:
   - `GET /api/upload/status/<job_id>/`
   - 백엔드에서 작업 ID에 해당하는 현재 상태 조회

2. 상태 응답 구조:
   ```json
   {
     "job_id": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
     "status": "completed",  // "processing", "failed"
     "progress": 100,  // 0~100
     "files": [
       {
         "file_type": "research_funding",
         "status": "completed",
         "rows_processed": 1523,
         "rows_inserted": 1498,
         "rows_skipped": 25,
         "errors": []
       },
       {
         "file_type": "students",
         "status": "failed",
         "error_message": "필수 컬럼 '학과'가 누락되었습니다.",
         "error_details": "3번째 행부터 '학과' 컬럼 값이 비어있습니다."
       }
     ],
     "completed_at": "2025-11-02T14:35:22Z"
   }
   ```

3. 프런트엔드 상태 처리:
   - **processing:** 폴링 계속, 프로그레스 바 업데이트, "데이터 처리 중... (약 XX초 소요)"
   - **completed:** 폴링 중단, 성공 UI 표시
   - **failed:** 폴링 중단, 에러 UI 표시

4. **완료 시 UI:**
   - 녹색 체크 아이콘 + "업로드가 완료되었습니다!"
   - 세부 통계: "총 X개 파일 중 Y개 성공", "총 XXX건의 데이터가 등록되었습니다", "처리 시간: X분 Y초"
   - 액션 버튼: "대시보드 보기" (메인 대시보드 이동), "추가 업로드" (페이지 초기화)

5. **실패 시 UI:**
   - 빨간색 경고 아이콘 + "업로드 중 오류가 발생했습니다"
   - 파일별 상세 에러: "student_roster.csv 처리 실패 - 원인: 3번째 행에서 '학과' 컬럼이 비어있습니다"
   - 권장 조치: "Excel에서 해당 행을 수정한 후 다시 업로드하세요"
   - 액션 버튼: "다시 시도" (파일 재선택)

#### Edge Cases
- **폴링 중 네트워크 단절:** 3회 연속 실패 시 "네트워크 연결을 확인하세요" 경고, 재연결 시 폴링 재개
- **장시간 처리 (3분 이상):** "처리 시간이 예상보다 길어지고 있습니다. 파일 크기가 크거나 복잡한 데이터일 수 있습니다" 경고 + 추정 완료 시간
- **작업 ID 만료/없음:** "작업 정보를 찾을 수 없습니다" 메시지 + "새로 업로드하기" 버튼

#### Business Rules
- BR-019: 작업 상태 폴링 간격: 3초
- BR-020: 완료/실패 시 폴링 즉시 중단
- BR-021: 사용자는 폴링 중 다른 페이지 이동 가능 (백그라운드 처리 계속)
- BR-022: **부분 성공 허용** (파일별 독립 트랜잭션으로 3개 성공, 1개 실패 가능)

---

## 4. API 명세

### 4.1 POST /api/upload/

**목적:** CSV/Excel 파일 업로드 및 백그라운드 처리 시작

**인증:** Header `X-Admin-Key: <하드코딩된_키_값>`

**요청:**
```http
POST /api/upload/ HTTP/1.1
Host: example.com
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary
X-Admin-Key: secret_admin_key_12345

------WebKitFormBoundary
Content-Disposition: form-data; name="research_funding"; filename="research_project_data.csv"
Content-Type: text/csv

[파일 바이너리 데이터]
------WebKitFormBoundary
Content-Disposition: form-data; name="students"; filename="student_roster.csv"
Content-Type: text/csv

[파일 바이너리 데이터]
------WebKitFormBoundary--
```

**성공 응답 (HTTP 202 Accepted):**
```json
{
  "status": "processing",
  "job_id": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
  "message": "파일 업로드가 시작되었습니다. 처리가 완료되면 알려드리겠습니다.",
  "estimated_time": "약 30초 소요 예상"
}
```

**에러 응답:**
- **403 Forbidden (API Key 불일치):**
  ```json
  {
    "error": "forbidden",
    "message": "관리자 권한이 없습니다. 접근이 거부되었습니다."
  }
  ```

- **400 Bad Request (파일 검증 실패):**
  ```json
  {
    "error": "validation_error",
    "details": {
      "file": "publication_list.csv",
      "issue": "필수 컬럼 'Impact Factor'가 누락되었습니다.",
      "required_columns": ["논문ID", "학과", "저널등급", "Impact Factor"]
    }
  }
  ```

- **500 Internal Server Error:**
  ```json
  {
    "error": "server_error",
    "message": "서버 오류가 발생했습니다. 잠시 후 다시 시도하세요."
  }
  ```

---

### 4.2 GET /api/upload/status/{job_id}/

**목적:** 업로드 작업 진행 상태 조회

**인증:** 없음 (job_id로 접근 제어)

**요청:**
```http
GET /api/upload/status/a1b2c3d4-e5f6-7890-abcd-ef1234567890/ HTTP/1.1
Host: example.com
```

**성공 응답 (HTTP 200 OK):**
```json
{
  "job_id": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
  "status": "completed",
  "progress": 100,
  "files": [
    {
      "file_type": "research_funding",
      "status": "completed",
      "rows_processed": 1523,
      "rows_inserted": 1498,
      "rows_skipped": 25,
      "errors": []
    },
    {
      "file_type": "students",
      "status": "completed",
      "rows_processed": 856,
      "rows_inserted": 850,
      "rows_skipped": 6,
      "errors": []
    }
  ],
  "completed_at": "2025-11-02T14:35:22Z"
}
```

**처리 중 응답:**
```json
{
  "job_id": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
  "status": "processing",
  "progress": 45,
  "files": [
    {
      "file_type": "research_funding",
      "status": "completed",
      "rows_processed": 1523,
      "rows_inserted": 1498
    },
    {
      "file_type": "students",
      "status": "processing",
      "progress": 60
    }
  ]
}
```

**실패 응답:**
```json
{
  "job_id": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
  "status": "failed",
  "progress": 30,
  "files": [
    {
      "file_type": "research_funding",
      "status": "completed"
    },
    {
      "file_type": "students",
      "status": "failed",
      "error_message": "필수 컬럼 '학과'가 누락되었습니다.",
      "error_details": "3번째 행부터 '학과' 컬럼 값이 비어있습니다."
    }
  ],
  "failed_at": "2025-11-02T14:32:10Z"
}
```

**404 Not Found (job_id 없음):**
```json
{
  "error": "not_found",
  "message": "작업 정보를 찾을 수 없습니다."
}
```

---

## 5. 데이터 검증 규칙

### 5.1 파일 레벨 검증

| 검증 항목 | 규칙 | 처리 시점 | 에러 메시지 |
|----------|------|----------|------------|
| 파일 형식 | `.csv`, `.xlsx`, `.xls`만 허용 | 클라이언트 + 서버 | "지원되지 않는 파일 형식입니다. CSV 또는 Excel 파일을 선택하세요." |
| 파일 크기 | 최대 10MB | 클라이언트 + 서버 | "파일 크기가 10MB를 초과합니다. (현재: XX.X MB)" |
| 파일 인코딩 | UTF-8, EUC-KR, CP949 자동 감지 | 서버 (Pandas) | "파일 인코딩을 감지할 수 없습니다." |
| 빈 파일 | 0 byte 불허 | 클라이언트 | "빈 파일입니다. 데이터가 포함된 파일을 선택하세요." |

### 5.2 스키마 검증 (필수 컬럼)

### 5.2.1 CSV 컬럼 → Django Model 필드 매핑

**research_project_data.csv:**
| CSV 컬럼명 | Django Model 필드명 | 데이터 타입 | 제약 조건 |
|-----------|-------------------|-----------|----------|
| 집행ID | execution_id | CharField(max_length=100) | primary_key=True |
| 소속학과 | department | CharField(max_length=100) | null=False |
| 총연구비 | total_budget | BigIntegerField | null=False, validators=[MinValueValidator(0)] |
| 집행일자 | execution_date | DateField | null=False |
| 집행금액 | execution_amount | BigIntegerField | null=False, validators=[MinValueValidator(0)] |

**research_project_data.csv 검증 규칙:**
| 필수 컬럼 | 데이터 타입 | 검증 규칙 |
|----------|-----------|----------|
| 집행ID | String | NOT NULL, 중복 시 최신 유지 |
| 소속학과 | String | NOT NULL, 공백 제거 |
| 총연구비 | Integer/Float | NOT NULL, >= 0 |
| 집행일자 | Date | NOT NULL, <= 현재 날짜 |
| 집행금액 | Integer/Float | NOT NULL, >= 0, <= 총연구비 |

**student_roster.csv:**
| CSV 컬럼명 | Django Model 필드명 | 데이터 타입 | 제약 조건 |
|-----------|-------------------|-----------|----------|
| 학번 | student_id | CharField(max_length=20) | primary_key=True |
| 학과 | department | CharField(max_length=100) | null=False |
| 학년 | grade | IntegerField | null=False, validators=[MinValueValidator(1), MaxValueValidator(4)] |
| 과정구분 | program_type | CharField(max_length=20) | null=False, choices=['학사', '석사', '박사'] |
| 학적상태 | enrollment_status | CharField(max_length=20) | null=False, choices=['재학', '휴학', '졸업'] |

**student_roster.csv 검증 규칙:**
| 필수 컬럼 | 데이터 타입 | 검증 규칙 |
|----------|-----------|----------|
| 학번 | String | NOT NULL, 중복 시 최신 유지 |
| 학과 | String | NOT NULL, 공백 제거 |
| 학년 | Integer | NOT NULL, 1~4 |
| 과정구분 | String | NOT NULL, IN ('학사', '석사', '박사') |
| 학적상태 | String | NOT NULL, IN ('재학', '휴학', '졸업') |

**publication_list.csv:**
| CSV 컬럼명 | Django Model 필드명 | 데이터 타입 | 제약 조건 |
|-----------|-------------------|-----------|----------|
| 논문ID | publication_id | CharField(max_length=100) | primary_key=True |
| 학과 | department | CharField(max_length=100) | null=False |
| 저널등급 | journal_tier | CharField(max_length=20) | null=False, choices=['SCIE', 'KCI', '기타'] |
| Impact Factor | impact_factor | FloatField | null=True, validators=[MinValueValidator(0)] |

**publication_list.csv 검증 규칙:**
| 필수 컬럼 | 데이터 타입 | 검증 규칙 |
|----------|-----------|----------|
| 논문ID | String | NOT NULL, 중복 시 최신 유지 |
| 학과 | String | NOT NULL, 공백 제거 |
| 저널등급 | String | NOT NULL, IN ('SCIE', 'KCI', ...) |
| Impact Factor | Float | NULL 허용, >= 0 |

**department_kpi.csv:**
| CSV 컬럼명 | Django Model 필드명 | 데이터 타입 | 제약 조건 |
|-----------|-------------------|-----------|----------|
| 평가년도 | evaluation_year | IntegerField | null=False, validators=[MinValueValidator(2000)], **복합 PK 구성요소** |
| 학과 | department | CharField(max_length=100) | null=False, **복합 PK 구성요소** |
| 졸업생 취업률(%) | employment_rate | FloatField | null=False, validators=[MinValueValidator(0), MaxValueValidator(100)] |
| 연간 기술이전 수입액(억원) | tech_transfer_revenue | FloatField | null=False, validators=[MinValueValidator(0)] |

**복합 PK 정의:**
```python
class DepartmentKPI(models.Model):
    evaluation_year = models.IntegerField(validators=[MinValueValidator(2000)])
    department = models.CharField(max_length=100)
    employment_rate = models.FloatField(validators=[MinValueValidator(0), MaxValueValidator(100)])
    tech_transfer_revenue = models.FloatField(validators=[MinValueValidator(0)])

    class Meta:
        constraints = [
            models.UniqueConstraint(
                fields=['evaluation_year', 'department'],
                name='unique_year_department_kpi'
            )
        ]
        verbose_name = 'Department KPI'
        verbose_name_plural = 'Department KPIs'
```

**이유:** 동일 학과의 여러 년도 데이터가 존재하므로 (평가년도 + 학과) 조합을 복합 PK로 사용

### 5.2.2 인덱스 전략

**MVP 필수 인덱스:**
1. **자동 생성 인덱스:**
   - 각 테이블의 PK (Django 자동 생성)
   - DepartmentKPI의 복합 UNIQUE 제약 조건 (인덱스 자동 생성)

2. **명시적 추가 인덱스 (필터링/정렬 성능 최적화):**
   - `department` (모든 테이블) - 학과별 필터링 쿼리 최적화
   - `execution_date` (ResearchProject) - 기간별 필터링/정렬 최적화
   - `evaluation_year` (DepartmentKPI) - 연도별 필터링 최적화

**Django Model 구현 예시:**
```python
class ResearchProject(models.Model):
    execution_id = models.CharField(max_length=100, primary_key=True)
    department = models.CharField(max_length=100)
    total_budget = models.BigIntegerField(validators=[MinValueValidator(0)])
    execution_date = models.DateField()
    execution_amount = models.BigIntegerField(validators=[MinValueValidator(0)])

    class Meta:
        indexes = [
            models.Index(fields=['department'], name='idx_rp_dept'),
            models.Index(fields=['execution_date'], name='idx_rp_date'),
        ]

class StudentRoster(models.Model):
    student_id = models.CharField(max_length=20, primary_key=True)
    department = models.CharField(max_length=100)
    grade = models.IntegerField(validators=[MinValueValidator(1), MaxValueValidator(4)])
    program_type = models.CharField(max_length=20, choices=[('학사', '학사'), ('석사', '석사'), ('박사', '박사')])
    enrollment_status = models.CharField(max_length=20, choices=[('재학', '재학'), ('휴학', '휴학'), ('졸업', '졸업')])

    class Meta:
        indexes = [
            models.Index(fields=['department'], name='idx_sr_dept'),
        ]
```

**성능 고려사항:**
- MVP 단계: 데이터 양이 적으므로 (수천~수만 건) 인덱스 효과 미미
- 인덱스 추가는 INSERT 성능 저하 (전체 교체 모드에서 중요)
- **권장:** 초기 MVP는 PK 인덱스만 사용, 성능 이슈 발생 시 추가

**department_kpi.csv 검증 규칙:**
| 필수 컬럼 | 데이터 타입 | 검증 규칙 |
|----------|-----------|----------|
| 평가년도 | Integer | NOT NULL, 2000~현재년도 |
| 학과 | String | NOT NULL, 공백 제거 |
| 졸업생 취업률(%) | Float | NOT NULL, 0~100 |
| 연간 기술이전 수입액(억원) | Float | NOT NULL, >= 0 |

### 5.3 데이터 품질 검증

| 검증 항목 | 규칙 | 처리 방식 |
|----------|------|----------|
| 결측값 (NaN) | 필수 컬럼: 불허 / 선택적 컬럼: 허용 | 필수 컬럼 NaN 시 해당 행 제외 + 경고 로그 |
| 중복 PK | 동일 PK 중복 발견 시 | 최신 행 유지 (Last-Write-Wins) |
| 데이터 타입 변환 실패 | 날짜/숫자 변환 실패 시 | 해당 행 제외 + 상세 에러 로그 (행 번호, 컬럼, 값) |
| 범위 위반 | 학년, 취업률, 금액 등 | 해당 행 제외 + 상세 에러 로그 |

---

## 6. 보안 요구사항

### 6.1 인증 및 권한

| 요구사항 | 구현 방식 | 우선순위 |
|----------|----------|----------|
| 관리자 접근 제어 | 하드코딩된 API Key (환경 변수) | P0-MVP |
| API Key 검증 | DRF 미들웨어 또는 View 레벨 검증 | P0-MVP |
| DB 기반 인증 | 미구현 (MVP 제외) | POST-MVP |

**API Key 관리:**
- 백엔드: `settings.py`에서 환경 변수 `ADMIN_API_KEY` 로드
- 프런트엔드: `.env.local`에서 `VITE_ADMIN_API_KEY` 로드
- 프로덕션: Railway 환경 변수로 관리

### 6.2 입력 검증

| 위협 | 완화 방법 | 우선순위 |
|------|----------|----------|
| 파일 업로드 공격 (malicious file) | 파일 형식 화이트리스트 (.csv, .xlsx, .xls) + MIME 타입 검증 | P0-MVP |
| 대용량 파일 DoS | 최대 크기 10MB 제한 | P0-MVP |
| SQL Injection | Django ORM 사용 (Parameterized Query 자동) | P0-MVP |
| XSS | React 기본 이스케이핑 + DOMPurify (필요 시) | P1-MVP |
| CSRF | API Key 인증 사용으로 CSRF 불필요 | P0-MVP |

#### 6.2.1 파일 MIME 타입 검증
악성 파일이 확장자를 위장하는 것을 방지하기 위해 실제 파일 MIME 타입을 검증합니다.

```python
import magic

def validate_file_type(file):
    """파일의 실제 MIME 타입을 검증"""
    # 파일의 처음 2048 바이트로 MIME 타입 판별
    mime = magic.from_buffer(file.read(2048), mime=True)
    file.seek(0)  # 파일 포인터 초기화

    allowed_mimes = [
        'text/csv',
        'text/plain',  # CSV 파일이 이렇게 인식될 수도 있음
        'application/vnd.ms-excel',  # .xls
        'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'  # .xlsx
    ]

    if mime not in allowed_mimes:
        raise ValidationError(f"허용되지 않은 파일 형식입니다: {mime}")
```

**라이브러리**: `python-magic` (requirements.txt에 추가)

#### 6.2.2 CSRF 보호 전략
- **적용 범위**: API Key 기반 인증을 사용하므로 CSRF 체크 불필요
- **이유**: CSRF는 세션 쿠키 기반 인증에서만 필요. API Key는 HTTP 헤더로 전송되므로 브라우저의 자동 쿠키 전송 메커니즘과 무관
- **DRF 설정**: `permission_classes = [AdminAPIKeyPermission]` 사용 시 자동으로 CSRF exempt

### 6.3 데이터 보호

| 요구사항 | 구현 방식 | 우선순위 |
|----------|----------|----------|
| 전송 중 암호화 | HTTPS 필수 (Railway 자동 제공) | P0-MVP |
| 임시 파일 보안 | 처리 완료 후 `/tmp/upload_{job_id}/` 자동 삭제 | P1-MVP |
| DB 접근 제어 | Supabase Row Level Security (POST-MVP) | POST-MVP |

---

## 7. 테스트 요구사항

### 7.1 Unit Tests (70%)

**테스트 대상:** `excel_parser.py` (Pandas 로직)

| 테스트 케이스 | 입력 | 기대 출력 | 우선순위 |
|-------------|------|----------|----------|
| 정상 CSV 파싱 | 유효한 research_project_data.csv | DataFrame 반환, 모든 행 유효 | P0 |
| 필수 컬럼 누락 | '집행ID' 컬럼 없는 CSV | ValidationError 예외 발생 | P0 |
| 데이터 타입 변환 | 날짜 컬럼에 "abc" 값 | 해당 행 제외 + 에러 로그 | P0 |
| 중복 PK | 동일 집행ID 2건 | 마지막 행만 유지 | P0 |
| 결측값 처리 | 필수 컬럼에 NaN | 해당 행 제외 + 경고 로그 | P0 |
| 범위 검증 | 학년 = 10 | 해당 행 제외 + 에러 로그 | P1 |
| 비표준 인코딩 | EUC-KR 파일 | 자동 감지 후 파싱 성공 | P1 |
| 빈 DataFrame | 헤더만 있는 CSV | "데이터 행이 없습니다" 에러 | P1 |

**테스트 예시 (pytest):**
```python
def test_parse_research_project_data_success():
    # GIVEN: 유효한 CSV 파일
    file_path = "tests/fixtures/research_project_data_valid.csv"

    # WHEN: 파싱 함수 호출
    df, stats = parse_research_project_data(file_path)

    # THEN: DataFrame 반환 및 통계 확인
    assert len(df) > 0
    assert stats['rows_processed'] == stats['rows_inserted']
    assert '집행ID' in df.columns
    assert df['집행금액'].dtype in [np.int64, np.float64]
```

### 7.1.1 Unit Test Mock 전략

**원칙:**
- `excel_parser.py` Unit Test는 **DB 접근 금지**
- 파일 I/O만 허용 (테스트 fixture CSV/Excel 파일 사용)
- 외부 의존성 없는 순수 Pandas 로직 테스트

**Integration Test Mock 전략:**
- Django TestCase 사용 (자동 DB 트랜잭션 롤백)
- 외부 API 호출 Mock (Supabase는 테스트 DB 사용)
- 백그라운드 작업 동기 실행 (ThreadPoolExecutor Mock)

**Mock 예시:**
```python
from unittest.mock import patch, MagicMock

def test_upload_with_db_error():
    # GIVEN: DB 저장 실패 상황 Mock
    with patch('data_ingestion.repositories.save_research_funding_data') as mock_save:
        mock_save.side_effect = DatabaseError("Connection refused")

        # WHEN: 업로드 처리 실행
        result = process_upload_job(job_id, files)

        # THEN: 에러 처리 확인
        assert result['status'] == 'failed'
        assert 'ERR_DB_001' in result['error_code']
        assert "데이터베이스 저장 중 오류" in result['error_message']

def test_upload_with_background_task_mock():
    # GIVEN: ThreadPoolExecutor를 동기 실행으로 Mock
    with patch('concurrent.futures.ThreadPoolExecutor') as mock_executor:
        # submit()을 즉시 실행하도록 설정
        mock_executor.return_value.submit.side_effect = lambda fn, *args: fn(*args)

        # WHEN: 업로드 API 호출
        response = client.post('/api/upload/', files, **headers)

        # THEN: 동기 실행으로 즉시 완료 확인
        job_id = response.json()['job_id']
        status = get_job_status(job_id)
        assert status['status'] == 'completed'
```

**Fixture 관리:**
- `tests/fixtures/` 폴더에 샘플 CSV/Excel 파일 저장
- 정상 케이스, 에러 케이스 (컬럼 누락, 타입 오류 등) 각각 준비
- 파일명 컨벤션: `{file_type}_{scenario}.csv` (예: `research_valid.csv`, `students_missing_column.csv`)

### 7.2 Integration Tests (20%)

**테스트 대상:** DRF API Endpoints

| 테스트 케이스 | API | 입력 | 기대 출력 | 우선순위 |
|-------------|-----|------|----------|----------|
| 업로드 성공 | POST /api/upload/ | 유효한 4개 파일 + API Key | HTTP 202 + job_id | P0 |
| API Key 불일치 | POST /api/upload/ | 잘못된 API Key | HTTP 403 | P0 |
| 파일 크기 초과 | POST /api/upload/ | 12MB 파일 | HTTP 400 | P0 |
| 상태 조회 성공 | GET /api/upload/status/{job_id}/ | 유효한 job_id | HTTP 200 + 상태 정보 | P0 |
| 상태 조회 실패 | GET /api/upload/status/{invalid_id}/ | 잘못된 job_id | HTTP 404 | P1 |

**테스트 예시 (DRF TestCase):**
```python
def test_upload_api_success(self):
    # GIVEN: 유효한 파일 및 API Key
    files = {
        'research_funding': open('tests/fixtures/research_valid.csv', 'rb'),
        'students': open('tests/fixtures/students_valid.csv', 'rb'),
    }
    headers = {'HTTP_X_ADMIN_KEY': settings.ADMIN_API_KEY}

    # WHEN: POST /api/upload/ 호출
    response = self.client.post('/api/upload/', files, **headers)

    # THEN: HTTP 202 및 job_id 반환
    self.assertEqual(response.status_code, 202)
    self.assertIn('job_id', response.json())
```

### 7.3 Acceptance Tests (10%)

**테스트 대상:** E2E 유저플로우

| 시나리오 | 단계 | 기대 결과 | 우선순위 |
|---------|------|----------|----------|
| 전체 업로드 플로우 (Happy Path) | 1. 관리자 페이지 접근<br>2. 파일 선택<br>3. 업로드 시작<br>4. 폴링 완료 대기<br>5. 대시보드 확인 | 모든 단계 성공, 대시보드에 최신 데이터 표시 | P0 (MVP 필수) |
| 파일 검증 실패 처리 | 1. 잘못된 파일 선택<br>2. 에러 메시지 확인<br>3. 파일 수정<br>4. 재업로드 | 구체적인 에러 메시지 표시 후 재시도 성공 | P2 (Integration Test로 대체) |
| 네트워크 오류 복구 | 1. 업로드 중 네트워크 단절<br>2. 수동 재시도<br>3. 연결 복구 후 폴링 재개 | 수동 재시도 후 정상 완료 | P2 (Integration Test로 대체) |

**테스트 도구:** Playwright (프런트엔드 E2E)

**우선순위 조정 이유:**
- **E2E 테스트는 느리고 불안정함 (flaky tests)**
- MVP에서는 Happy Path만 P0로 보장
- 에러 처리 시나리오는 Integration Test로 충분히 검증 가능
- POST-MVP에서 CI/CD 안정화 후 E2E 범위 확대

**MVP E2E 테스트 범위:**
- 1개 시나리오만 구현: 전체 업로드 플로우 Happy Path
- 실행 빈도: 수동 (배포 전 체크리스트)
- 자동화: POST-MVP (CI/CD 파이프라인 통합)

---

## 8. 에러 처리

### 8.1 에러 코드 정의

| 에러 코드 | HTTP Status | 에러 메시지 | 사용자 액션 |
|----------|------------|------------|------------|
| ERR_AUTH_001 | 403 | "관리자 권한이 없습니다. 접근이 거부되었습니다." | 메인 대시보드 이동 |
| ERR_FILE_001 | 400 | "지원되지 않는 파일 형식입니다. CSV 또는 Excel 파일을 선택하세요." | 파일 재선택 |
| ERR_FILE_002 | 400 | "파일 크기가 10MB를 초과합니다. (현재: XX.X MB)" | 파일 분할 또는 축소 |
| ERR_FILE_003 | 400 | "빈 파일입니다. 데이터가 포함된 파일을 선택하세요." | 파일 재선택 |
| ERR_SCHEMA_001 | 400 | "필수 컬럼 '{컬럼명}'가 누락되었습니다." | Ecount 추출 설정 확인 후 재업로드 |
| ERR_DATA_001 | 400 | "'{파일명}' {행번호}번째 행의 '{컬럼명}' 컬럼에 유효하지 않은 값이 있습니다." | Excel에서 해당 행 수정 후 재업로드 |
| ERR_PARSE_001 | 500 | "파일 인코딩을 감지할 수 없습니다." | UTF-8 인코딩으로 저장 후 재업로드 |
| ERR_DB_001 | 500 | "데이터베이스 저장 중 오류가 발생했습니다." | 잠시 후 재시도 |
| ERR_NETWORK_001 | 0 | "네트워크 연결을 확인하세요." | 연결 확인 후 재시도 |

### 8.2 에러 로깅

**로깅 레벨:**
- ERROR: 사용자 액션 필요 (파일 검증 실패, DB 에러 등)
- WARNING: 자동 복구 가능 (중복 데이터, 일부 행 제외 등)
- INFO: 정상 작업 진행 (파싱 시작, 완료 등)

**로그 포맷:**
```
[2025-11-02 14:32:10] ERROR [job_id=a1b2c3d4] ERR_SCHEMA_001: 필수 컬럼 '학과'가 누락되었습니다. (파일: student_roster.csv)
```

---

## 9. 성능 요구사항

### 9.1 MVP 성능 목표 (내부 베타 테스트 기준)

| 지표 | 목표 | 측정 방법 | 비고 |
|------|------|----------|------|
| 파일 업로드 응답 시간 | < 5초 (HTTP 202 반환) | API 응답 시간 측정 | 파일 임시 저장 + 작업 등록 시간 |
| 10MB 파일 파싱 시간 | < 2분 | 백그라운드 작업 소요 시간 | 전체 DataFrame 로드 방식 |
| 상태 폴링 응답 시간 | < 2초 | API 응답 시간 측정 | 메모리 기반 상태 조회 |
| 동시 업로드 처리 | 단일 작업 순차 처리 | 부하 테스트 | 큐 대기, POST-MVP에서 병렬화 |

**MVP 목표 설정 이유:**
- **사용자 규모:** 내부 관리자 소수(< 10명)만 접근
- **사용 빈도:** 주 1~2회 데이터 업로드
- **우선순위:** 성능보다 안정성 및 기능 완성도 우선
- **최적화 시점:** 성능 이슈 보고 시 ThreadPool worker 증가 등으로 대응

### 9.2 성능 최적화 전략

**MVP 구현:**
- Pandas 전체 DataFrame 로드 (청크 처리 제외)
- Django ORM Bulk Insert: 배치 크기 1000건
- 백그라운드 Thread Pool: 최대 1개 worker (순차 처리)

**POST-MVP 고려사항:**
- ThreadPoolExecutor worker 증가 (3~5개)
- Pandas 청크 처리 (대용량 파일 지원 시)
- Redis 기반 작업 큐 (Celery)
- APM 도구 도입 (New Relic, DataDog)

### 9.3 성능 측정 방법

**MVP:**
- 수동 측정: 브라우저 Network 탭, Django Debug Toolbar
- 로그 기반 측정: 각 단계별 타임스탬프 로깅

**POST-MVP:**
- APM 도구 연동 (자동 성능 모니터링)
- 커스텀 메트릭 수집 (Supabase Analytics)

---

## 10. 의존성

### 10.1 외부 시스템 의존성

| 시스템 | 용도 | 가용성 요구사항 |
|--------|------|----------------|
| Supabase (PostgreSQL) | 데이터 저장 | 99.9% 가용성 |
| Railway | 백엔드 호스팅 | 99.9% 가용성 |

### 10.2 라이브러리 의존성

**백엔드 (Python):**
- Django 4.x
- Django Rest Framework 3.x
- Pandas 2.x
- openpyxl (Excel 파싱)

**프런트엔드 (JavaScript):**
- React 18.x
- Axios (HTTP 클라이언트)
- React Query (상태 관리, 선택적)

---

## 11. Out of Scope (MVP 제외)

### 11.1 POST-MVP 기능
- DB 기반 사용자 인증 시스템
- 증분 업데이트 (UPSERT)
- 파일 프리뷰 기능
- 에러 로그 다운로드
- 자동 백업/롤백
- 데이터 변경 이력 추적 (Audit Log)
- 대용량 파일 청크 업로드
- 업로드 취소 기능
- Redis 기반 작업 상태 저장 (서버 재시작 시 상태 보존)

### 11.2 확장 고려 사항
- 다른 데이터 소스 지원 (API, DB 직접 연동 등)
- 스케줄링 자동 업로드
- 데이터 품질 대시보드
- 알림 시스템 (업로드 완료 이메일 등)

---

## 12. Sequence Diagram (PlantUML)

```plantuml
@startuml
actor User as "관리자"
participant FE as "Frontend\n(React)"
participant BE as "Backend\n(DRF)"
participant Pandas as "excel_parser.py\n(Pandas)"
database DB as "Database\n(Supabase)"

== 1. 관리자 페이지 접근 ==
User -> FE: /admin/upload 접근
FE -> FE: 환경 변수 검증\n(ADMIN_MODE)
FE --> User: 파일 업로드 UI 표시

== 2. 파일 선택 및 검증 ==
User -> FE: CSV/Excel 파일 선택
FE -> FE: 클라이언트 검증\n(크기, 형식)
alt 검증 실패
    FE --> User: 에러 메시지 표시
else 검증 성공
    FE --> User: "업로드 시작" 버튼 활성화
end

== 3. 파일 업로드 요청 ==
User -> FE: "업로드 시작" 클릭
FE -> BE: POST /api/upload/\n(FormData + API Key)
BE -> BE: API Key 검증
alt API Key 불일치
    BE --> FE: HTTP 403 Forbidden
    FE --> User: "권한 없음" 에러
else API Key 유효
    BE -> BE: 파일 임시 저장\n(/tmp/upload_{job_id}/)
    BE -> BE: 백그라운드 작업 등록\n(threading.Thread)
    BE --> FE: HTTP 202 Accepted\n{"job_id": "...", "status": "processing"}
    FE --> User: "처리 중..." 메시지\n+ 프로그레스 바
end

== 4. 백그라운드 파싱 (비동기) ==
FE -> BE: GET /api/upload/status/{job_id}/\n(3초 간격 폴링)
activate BE
BE -> Pandas: parse_research_project_data(file_path)
activate Pandas
Pandas -> Pandas: DataFrame 로드\n(인코딩 자동 감지)
Pandas -> Pandas: 필수 컬럼 검증
alt 컬럼 누락
    Pandas --> BE: ValidationError 예외
    BE -> BE: 작업 상태 = "failed"
    BE --> FE: {"status": "failed", "error": "..."}
    deactivate Pandas
    FE --> User: 에러 메시지 표시
else 검증 성공
    Pandas -> Pandas: 데이터 타입 변환
    Pandas -> Pandas: 정제 (NaN 제거, 중복 제거)
    Pandas -> Pandas: 비즈니스 로직 검증
    Pandas --> BE: 정제된 DataFrame + 통계
    deactivate Pandas
end

== 5. 데이터베이스 저장 ==
BE -> DB: BEGIN TRANSACTION
BE -> DB: DELETE FROM research_projects
BE -> DB: BULK INSERT (정제된 데이터)
alt DB 에러
    DB --> BE: 에러 발생
    BE -> DB: ROLLBACK
    BE -> BE: 작업 상태 = "failed"
    BE --> FE: {"status": "failed", "error": "DB 저장 실패"}
    FE --> User: 에러 메시지 표시
else 저장 성공
    BE -> DB: COMMIT
    BE -> BE: 작업 상태 = "completed"
    BE --> FE: {"status": "completed", "rows_inserted": 1498}
    deactivate BE
end

== 6. 완료 피드백 ==
FE -> FE: 폴링 중단
FE --> User: "업로드 완료!" 성공 메시지\n+ 처리 결과 통계
User -> FE: "대시보드 보기" 클릭
FE -> User: 메인 대시보드로 이동

@enduml
```

---

## 문서 변경 이력

| 버전 | 날짜 | 변경 사항 | 작성자 |
|------|------|-----------|--------|
| 1.0 | 2025-11-02 | 초기 유스케이스 명세 작성 | Spec Writer Agent |
| 1.1 | 2025-11-02 | Critical Issues 반영: CSV-Django 매핑 테이블 추가, 백그라운드 작업 상태 저장소 명시(메모리), 트랜잭션 전략 명확화(파일별 독립), API Key 검증 위치 명시(View 레벨), ThreadPoolExecutor 사용 명시, 임시 파일 정리 로직 추가, MIME 타입 검증 추가, CSRF 전략 명확화 | Claude Code |
| 1.2 | 2025-11-02 | **CTO 검증 피드백 반영 (speccheck.md 기반):**<br>- **P0 수정:** 복합 PK 정의 추가 (department_kpi), 메모리 저장소 동시성 제어 (threading.Lock), 성능 요구사항 완화 (MVP 적정 수준), Ecount CSV 샘플 검증 섹션 추가<br>- **P1 개선:** 부분 성공 UX 플로우 추가 (3.5.1), 인덱스 전략 명시 (5.2.2), Mock 테스트 전략 추가 (7.1.1), E2E 테스트 우선순위 조정<br>- **MVP 간소화:** 청크 처리 제거, UTF-8만 지원, 자동 재시도 제거<br>- **상세:** 권장-001~014 반영 완료 | Claude Code |

---

## 승인 및 검토

**작성자:** Spec Writer Agent
**검토자:** CTO
**승인일:** 2025-11-02

본 유스케이스 명세는 MVP 범위에 맞춘 실행 가능한 수준으로 작성되었으며, TDD 원칙에 따라 테스트 요구사항이 포함되었습니다.

---

**문서 끝**
</file>

<file path="002-research-funding-dashboard/plan.md">
# Research Funding Dashboard Implementation Plan

**Feature ID:** 002
**Feature Name:** 연구비 집행 추이 시각화
**Priority:** P0-MVP
**Date:** 2025-11-02
**Author:** Plan Writer Agent

---

## 1. 개요

### 1.1 모듈 구성 요약

본 구현 계획은 **연구비 집행 추이 대시보드** 기능을 TDD 원칙에 따라 개발하기 위한 설계입니다.

### 1.2 비동기 처리 전략 (CTO 간소화 원칙)

**MVP 접근 방식: Python Threading**

Excel 업로드 시 비동기 파일 처리는 **Python 표준 라이브러리의 threading 모듈**을 사용하여 구현합니다. 별도의 Task Queue (Celery, RQ 등)는 MVP 범위에서 제외됩니다.

**이유:**
- CTO 핵심 원칙: "Simplest infrastructure approach" 준수
- 외부 의존성 없음 (Redis, RabbitMQ 불필요)
- 인프라 설정 시간 최소화 (1일 이내)
- 대용량 트래픽이 아닌 내부 관리자 도구 특성 고려

**구현 예시 (POST-MVP 기능, 참고용):**

```python
# backend/data_ingestion/services/async_processor.py
import threading
from typing import Callable

def process_upload_async(job_id: str, file_path: str, callback: Callable):
    """
    백그라운드 스레드에서 파일 처리 실행

    Args:
        job_id: 작업 고유 식별자
        file_path: 업로드된 파일 경로
        callback: 처리 완료 후 실행할 함수
    """
    thread = threading.Thread(
        target=_process_file_task,
        args=(job_id, file_path, callback),
        daemon=True  # 메인 프로세스 종료 시 자동 정리
    )
    thread.start()

def _process_file_task(job_id: str, file_path: str, callback: Callable):
    try:
        # 1. Excel 파싱
        parser = ExcelParser()
        data = parser.parse(file_path)

        # 2. DB 저장
        repository = ResearchFundingRepository()
        repository.bulk_insert(data)

        # 3. 완료 콜백
        callback(job_id, status='success')
    except Exception as e:
        callback(job_id, status='error', error=str(e))
```

**제약 사항:**
- 단일 서버 환경 전용 (Railway 스케일링 시 Task Queue로 전환 필요)
- 작업 상태 추적은 DB 테이블 사용 (UploadJob 모델)

**POST-MVP 마이그레이션 경로:**
- 트래픽 증가 시 → Celery + Redis 전환
- 현재 threading 코드는 Celery task로 쉽게 변환 가능

**핵심 원칙:**
- Red → Green → Refactor 사이클 철저히 준수
- Test First: 코드보다 테스트를 먼저 작성
- Small Steps: 한 번에 하나의 시나리오만 구현
- FIRST Principles: Fast, Independent, Repeatable, Self-validating, Timely
- Test Pyramid: Unit 70% > Integration 20% > Acceptance 10%

**TDD 적용 범위:**
- Backend: 모든 비즈니스 로직 (Services, Repositories)
- Frontend: 핵심 데이터 처리 로직 (Hooks, Utils)
- API Integration: 엔드포인트 통합 테스트
- E2E: 핵심 사용자 시나리오

**모듈 목록:**

| 모듈명 | 레이어 | 위치 | 핵심 책임 |
|--------|--------|------|-----------|
| ResearchProject Model | Domain | `backend/data_ingestion/infrastructure/models.py` | 연구비 데이터 엔티티 정의 |
| ResearchFundingRepository | Infrastructure | `backend/data_ingestion/infrastructure/repositories.py` | 데이터베이스 접근 (ORM) |
| ResearchFundingService | Service | `backend/data_ingestion/services/research_funding_service.py` | 비즈니스 로직 및 집계 |
| ResearchFundingView | Presentation | `backend/data_ingestion/api/views.py` | API 엔드포인트 처리 |
| ResearchFundingSerializer | Presentation | `backend/data_ingestion/api/serializers.py` | 요청/응답 직렬화 |
| ErrorCodeRegistry | Constants | `backend/data_ingestion/constants/error_codes.py` | 중앙화된 에러 코드 관리 |
| useDashboardData Hook | Frontend Logic | `frontend/src/hooks/useDashboardData.ts` | API 호출 및 데이터 변환 (TypeScript) |
| ResearchFundingChart | Frontend UI | `frontend/src/components/dashboard/ResearchFundingChart.tsx` | Line Chart 렌더링 (TypeScript) |
| ResearchFundingMetricCard | Frontend UI | `frontend/src/components/dashboard/ResearchFundingMetricCard.tsx` | Metric Card 렌더링 (TypeScript) |

---

## 2. Architecture Diagram

### 2.1 시스템 아키텍처 (Layered Architecture)

```mermaid
graph TB
    subgraph "Presentation Layer"
        A[ResearchFundingChart.jsx]
        B[ResearchFundingMetricCard.jsx]
        C[DepartmentFilter.jsx]
    end

    subgraph "Frontend Logic Layer"
        D[useDashboardData Hook]
        E[dataApiClient.js]
    end

    subgraph "API Layer (DRF)"
        F[ResearchFundingView]
        G[ResearchFundingSerializer]
    end

    subgraph "Service Layer"
        H[ResearchFundingService]
    end

    subgraph "Infrastructure Layer"
        I[ResearchFundingRepository]
        J[ResearchProject Model]
    end

    subgraph "Database"
        K[(Supabase PostgreSQL)]
    end

    A --> D
    B --> D
    C --> D
    D --> E
    E -->|HTTP GET| F
    F --> G
    F --> H
    H --> I
    I --> J
    J --> K

    style A fill:#e1f5ff
    style B fill:#e1f5ff
    style C fill:#e1f5ff
    style D fill:#fff4e1
    style H fill:#ffe1e1
    style I fill:#e1ffe1
```

### 2.2 데이터 흐름

```mermaid
sequenceDiagram
    participant User
    participant Chart as ResearchFundingChart
    participant Hook as useDashboardData
    participant API as ResearchFundingView
    participant Service as ResearchFundingService
    participant Repo as Repository
    participant DB as Supabase

    User->>Chart: 대시보드 접속
    Chart->>Hook: useEffect() 실행
    Hook->>API: GET /api/dashboard/research-funding/
    API->>Service: get_dashboard_data(dept, period)
    Service->>Repo: get_current_balance(dept)
    Repo->>DB: SELECT SUM(total_budget) - SUM(execution_amount)
    DB-->>Repo: current_balance
    Repo-->>Service: 1530000000
    Service->>Repo: get_monthly_trend(dept, period)
    Repo->>DB: SELECT month, SUM(execution_amount) GROUP BY month
    DB-->>Repo: trend_data
    Repo-->>Service: [{month, balance, execution}]
    Service->>Service: format_currency(amount)
    Service-->>API: {current_balance, trend, formatted}
    API->>API: serialize response
    API-->>Hook: JSON Response
    Hook->>Hook: transformData()
    Hook-->>Chart: {metricData, chartData}
    Chart->>Chart: render Recharts
    Chart-->>User: 시각화 표시
```

---

## 3. Implementation Plan

### 3.1 Django Model (ResearchProject)

#### Location
`backend/data_ingestion/infrastructure/models.py`

#### Responsibility
- 연구비 집행 데이터의 Domain Entity 정의
- DB 스키마와 Python 객체 매핑
- 필드 제약 조건 및 유효성 검증

#### Test Strategy
- **Unit Tests**: Django Model 필드 제약 조건 검증

#### Test Scenarios (Red Phase)

**Test Case 1: 모델 생성 성공**
```python
def test_create_research_project_with_valid_data():
    # Arrange
    data = {
        'execution_id': 'EX001',
        'department': '컴퓨터공학과',
        'total_budget': 1000000000,
        'execution_date': '2024-01-15',
        'execution_amount': 200000000
    }

    # Act
    project = ResearchProject.objects.create(**data)

    # Assert
    assert project.execution_id == 'EX001'
    assert project.total_budget == 1000000000
```

**Test Case 2: execution_id UNIQUE 제약**
```python
def test_execution_id_must_be_unique():
    # Arrange
    ResearchProject.objects.create(execution_id='EX001', ...)

    # Act & Assert
    with pytest.raises(IntegrityError):
        ResearchProject.objects.create(execution_id='EX001', ...)
```

**Test Case 3: 음수 금액 불허**
```python
def test_negative_budget_rejected():
    # Arrange & Act & Assert
    with pytest.raises(ValidationError):
        project = ResearchProject(total_budget=-1000)
        project.full_clean()
```

**Test Case 4: 필수 필드 누락 검증**
```python
def test_required_fields_cannot_be_null():
    # Act & Assert
    with pytest.raises(ValidationError):
        project = ResearchProject(execution_id='EX001')
        project.full_clean()
```

#### Implementation Order (TDD Cycle)
1. **Red**: test_create_research_project_with_valid_data 작성 → 실행 (실패)
2. **Green**: ResearchProject Model 기본 필드 정의 → 테스트 통과
3. **Refactor**: 필드명 명확화, docstring 추가
4. **Red**: test_execution_id_must_be_unique 작성 → 실행 (실패)
5. **Green**: execution_id에 unique=True 추가 → 테스트 통과
6. **Red**: test_negative_budget_rejected 작성 → 실행 (실패)
7. **Green**: MinValueValidator(0) 추가 → 테스트 통과
8. **Commit**: "feat: Add ResearchProject model with basic validations"

#### Dependencies
- Django ORM
- PostgreSQL (Supabase)

---

### 3.2 ResearchFundingRepository

#### Location
`backend/data_ingestion/infrastructure/repositories.py`

#### Responsibility
- 데이터베이스 CRUD 연산 전담
- ORM 쿼리 최적화 (인덱스 활용)
- 집계 쿼리 실행 (SUM, GROUP BY)

#### Test Strategy
- **Unit Tests**: 격리된 환경에서 Repository 메서드 검증
- **Database**: In-memory SQLite 또는 Test DB 사용

#### Test Scenarios (Red Phase)

**Test Case 1: 전체 학과 현재 잔액 계산**
```python
def test_get_current_balance_all_departments():
    # Arrange
    ResearchProject.objects.create(
        execution_id='EX001',
        total_budget=1000000000,
        execution_amount=200000000,
        ...
    )
    ResearchProject.objects.create(
        execution_id='EX002',
        total_budget=500000000,
        execution_amount=100000000,
        ...
    )
    repo = ResearchFundingRepository()

    # Act
    balance = repo.get_current_balance(department=None)

    # Assert
    expected = (1000000000 + 500000000) - (200000000 + 100000000)
    assert balance == expected  # 1200000000
```

**Test Case 2: 특정 학과 잔액 계산**
```python
def test_get_current_balance_specific_department():
    # Arrange
    ResearchProject.objects.create(
        execution_id='EX001',
        department='컴퓨터공학과',
        total_budget=1000000000,
        execution_amount=200000000,
        ...
    )
    ResearchProject.objects.create(
        execution_id='EX002',
        department='전자공학과',
        total_budget=500000000,
        execution_amount=100000000,
        ...
    )
    repo = ResearchFundingRepository()

    # Act
    balance = repo.get_current_balance(department='컴퓨터공학과')

    # Assert
    assert balance == 800000000
```

**Test Case 3: 데이터 없을 때 0 반환**
```python
def test_get_current_balance_no_data_returns_zero():
    # Arrange
    repo = ResearchFundingRepository()

    # Act
    balance = repo.get_current_balance()

    # Assert
    assert balance == 0
```

**Test Case 4: 월별 집행 추이 집계**
```python
def test_get_monthly_trend():
    # Arrange
    ResearchProject.objects.bulk_create([
        ResearchProject(
            execution_id='EX001',
            execution_date='2024-01-15',
            execution_amount=100000000,
            total_budget=1000000000,
            ...
        ),
        ResearchProject(
            execution_id='EX002',
            execution_date='2024-01-25',
            execution_amount=50000000,
            total_budget=1000000000,
            ...
        ),
        ResearchProject(
            execution_id='EX003',
            execution_date='2024-02-10',
            execution_amount=80000000,
            total_budget=1000000000,
            ...
        ),
    ])
    repo = ResearchFundingRepository()

    # Act
    trend = repo.get_monthly_trend(department=None, period='latest')

    # Assert
    assert len(trend) == 2  # 2024-01, 2024-02
    assert trend[0]['month'] == '2024-01'
    assert trend[0]['execution'] == 150000000
    assert trend[1]['month'] == '2024-02'
    assert trend[1]['execution'] == 80000000
```

**Test Case 5: 기간 필터 적용 (1년)**
```python
def test_get_monthly_trend_with_1year_period():
    # Arrange
    from django.utils import timezone
    from datetime import timedelta

    two_years_ago = timezone.now() - timedelta(days=730)
    six_months_ago = timezone.now() - timedelta(days=180)

    ResearchProject.objects.bulk_create([
        ResearchProject(
            execution_id='EX001',
            execution_date=two_years_ago.date(),
            execution_amount=100000000,
            ...
        ),
        ResearchProject(
            execution_id='EX002',
            execution_date=six_months_ago.date(),
            execution_amount=80000000,
            ...
        ),
    ])
    repo = ResearchFundingRepository()

    # Act
    trend = repo.get_monthly_trend(period='1year')

    # Assert
    assert len(trend) == 1  # 최근 1년 데이터만
    assert trend[0]['execution'] == 80000000
```

#### Implementation Order (TDD Cycle)
1. **Red**: test_get_current_balance_all_departments 작성 → 실행 (실패)
2. **Green**: Repository 클래스 및 get_current_balance() 메서드 구현 → 테스트 통과
3. **Refactor**: 쿼리 최적화, 변수명 개선
4. **Red**: test_get_current_balance_specific_department 작성 → 실행 (실패)
5. **Green**: department 필터링 로직 추가 → 테스트 통과
6. **Red**: test_get_current_balance_no_data_returns_zero 작성 → 실행 (실패)
7. **Green**: NULL 처리 로직 추가 (or 0) → 테스트 통과
8. **Red**: test_get_monthly_trend 작성 → 실행 (실패)
9. **Green**: get_monthly_trend() 메서드 구현 (TruncMonth, GROUP BY) → 테스트 통과
10. **Red**: test_get_monthly_trend_with_1year_period 작성 → 실행 (실패)
11. **Green**: 기간 필터링 로직 추가 → 테스트 통과
12. **Refactor**: 중복 코드 제거, 헬퍼 함수 분리
13. **Commit**: "feat: Add ResearchFundingRepository with balance and trend queries"

#### Dependencies
- ResearchProject Model
- Django ORM (QuerySet API)
- Django Timezone Utils

---

### 3.3 ResearchFundingService

#### Location
`backend/data_ingestion/services/research_funding_service.py`

#### Responsibility
- 비즈니스 로직 조정 (Repository 호출)
- 데이터 포맷팅 (억원 변환, 날짜 포맷)
- YoY 변화율 계산

#### Test Strategy
- **Unit Tests**: Service 메서드 독립 검증
- **Mocking**: Repository를 Mock하여 Service 로직만 테스트

#### Test Scenarios (Red Phase)

**Test Case 1: 대시보드 데이터 조회 성공**
```python
def test_get_dashboard_data_success():
    # Arrange
    mock_repo = Mock(spec=ResearchFundingRepository)
    mock_repo.get_current_balance.return_value = 1530000000
    mock_repo.get_monthly_trend.return_value = [
        {'month': '2024-01', 'balance': 1200000000, 'execution': 150000000},
        {'month': '2024-02', 'balance': 1400000000, 'execution': 120000000},
    ]

    service = ResearchFundingService(repository=mock_repo)

    # Act
    data = service.get_dashboard_data(department='all', period='latest')

    # Assert
    assert data['current_balance'] == 1530000000
    assert data['current_balance_formatted'] == '15.3억원'
    assert len(data['trend']) == 2
    assert data['trend'][0]['month_formatted'] == '2024년 1월'
```

**Test Case 2: 억원 변환 정확성**
```python
def test_format_currency_to_billion_won():
    # Arrange
    service = ResearchFundingService()

    # Act
    result = service._format_currency(1530000000)

    # Assert
    assert result == '15.3억원'
```

**Test Case 3: 월 포맷팅 (YYYY-MM → YYYY년 M월)**
```python
def test_format_month():
    # Arrange
    service = ResearchFundingService()

    # Act
    result = service._format_month('2024-01')

    # Assert
    assert result == '2024년 1월'
```

**Test Case 4: YoY 변화율 계산 (POST-MVP)**
```python
def test_calculate_year_over_year_change():
    # Arrange
    service = ResearchFundingService()
    current_balance = 1530000000
    last_year_balance = 1320000000

    # Act
    change, percentage = service._calculate_yoy_change(
        current_balance,
        last_year_balance
    )

    # Assert
    assert change == 210000000
    assert percentage == pytest.approx(15.9, rel=0.1)
```

**Test Case 5: 데이터 없을 때 기본값 반환**
```python
def test_get_dashboard_data_no_data():
    # Arrange
    mock_repo = Mock(spec=ResearchFundingRepository)
    mock_repo.get_current_balance.return_value = 0
    mock_repo.get_monthly_trend.return_value = []

    service = ResearchFundingService(repository=mock_repo)

    # Act
    data = service.get_dashboard_data(department='all', period='latest')

    # Assert
    assert data['current_balance'] == 0
    assert data['current_balance_formatted'] == '0억원'
    assert data['trend'] == []
```

#### Implementation Order (TDD Cycle)
1. **Red**: test_format_currency_to_billion_won 작성 → 실행 (실패)
2. **Green**: _format_currency() 메서드 구현 → 테스트 통과
3. **Red**: test_format_month 작성 → 실행 (실패)
4. **Green**: _format_month() 메서드 구현 → 테스트 통과
5. **Red**: test_get_dashboard_data_success 작성 → 실행 (실패)
6. **Green**: get_dashboard_data() 메서드 구현 (Repository 호출 + 포맷팅) → 테스트 통과
7. **Refactor**: 포맷팅 로직을 별도 유틸리티로 분리 (재사용성)
8. **Red**: test_get_dashboard_data_no_data 작성 → 실행 (실패)
9. **Green**: 빈 데이터 처리 로직 추가 → 테스트 통과
10. **Commit**: "feat: Add ResearchFundingService with data formatting"

#### Dependencies
- ResearchFundingRepository (주입)
- Python datetime (날짜 포맷팅)

---

### 3.4 ResearchFundingView (DRF API)

#### Location
`backend/data_ingestion/api/views.py`

#### Responsibility
- HTTP 요청 처리 (GET)
- 쿼리 파라미터 검증 (department, period)
- Service 레이어 호출 및 응답 직렬화

#### Test Strategy
- **Integration Tests**: DRF APIClient로 엔드포인트 통합 테스트
- **Database**: 실제 Test DB 사용

#### Test Scenarios (Red Phase)

**Test Case 1: 정상 요청 - 전체 학과**
```python
def test_get_research_funding_all_departments():
    # Arrange
    ResearchProject.objects.create(
        execution_id='EX001',
        department='컴퓨터공학과',
        total_budget=1000000000,
        execution_date='2024-01-15',
        execution_amount=200000000
    )
    client = APIClient()

    # Act
    response = client.get('/api/dashboard/research-funding/')

    # Assert
    assert response.status_code == 200
    assert response.data['status'] == 'success'
    assert 'data' in response.data
    assert 'current_balance' in response.data['data']
    assert 'trend' in response.data['data']
```

**Test Case 2: 학과 필터링**
```python
def test_get_research_funding_with_department_filter():
    # Arrange
    ResearchProject.objects.bulk_create([
        ResearchProject(
            execution_id='EX001',
            department='컴퓨터공학과',
            total_budget=1000000000,
            execution_amount=200000000,
            ...
        ),
        ResearchProject(
            execution_id='EX002',
            department='전자공학과',
            total_budget=500000000,
            execution_amount=100000000,
            ...
        ),
    ])
    client = APIClient()

    # Act
    response = client.get(
        '/api/dashboard/research-funding/',
        {'department': '컴퓨터공학과'}
    )

    # Assert
    assert response.status_code == 200
    assert response.data['data']['current_balance'] == 800000000
```

**Test Case 3: 잘못된 학과명 - 400 에러**
```python
def test_get_research_funding_invalid_department():
    # Arrange
    from backend.data_ingestion.constants.error_codes import ErrorCode
    client = APIClient()

    # Act
    response = client.get(
        '/api/dashboard/research-funding/',
        {'department': '존재하지않는학과'}
    )

    # Assert
    assert response.status_code == 400
    assert response.data['error_code'] == ErrorCode.INVALID_DEPARTMENT
```

**Test Case 4: 데이터 없을 때 200 OK with 빈 데이터**
```python
def test_get_research_funding_no_data():
    # Arrange
    client = APIClient()

    # Act
    response = client.get('/api/dashboard/research-funding/')

    # Assert
    assert response.status_code == 200
    assert response.data['data']['current_balance'] == 0
    assert response.data['data']['trend'] == []
    assert 'message' in response.data
```

**Test Case 5: 기간 필터링 (1year)**
```python
def test_get_research_funding_with_period_filter():
    # Arrange
    from django.utils import timezone
    from datetime import timedelta

    two_years_ago = timezone.now() - timedelta(days=730)
    six_months_ago = timezone.now() - timedelta(days=180)

    ResearchProject.objects.bulk_create([
        ResearchProject(
            execution_id='EX001',
            execution_date=two_years_ago.date(),
            ...
        ),
        ResearchProject(
            execution_id='EX002',
            execution_date=six_months_ago.date(),
            ...
        ),
    ])
    client = APIClient()

    # Act
    response = client.get(
        '/api/dashboard/research-funding/',
        {'period': '1year'}
    )

    # Assert
    assert response.status_code == 200
    trend_data = response.data['data']['trend']
    assert len(trend_data) == 1  # 최근 1년 데이터만
```

#### Implementation Order (TDD Cycle)
1. **Red**: test_get_research_funding_all_departments 작성 → 실행 (실패)
2. **Green**: ResearchFundingView 기본 GET 메서드 구현 → 테스트 통과
3. **Red**: test_get_research_funding_with_department_filter 작성 → 실행 (실패)
4. **Green**: 쿼리 파라미터 파싱 및 Service 전달 → 테스트 통과
5. **Red**: test_get_research_funding_invalid_department 작성 → 실행 (실패)
6. **Green**: 입력 검증 로직 추가 (허용된 학과 목록 체크) → 테스트 통과
7. **Refactor**: Serializer로 검증 로직 분리
8. **Red**: test_get_research_funding_no_data 작성 → 실행 (실패)
9. **Green**: 빈 데이터 응답 처리 → 테스트 통과
10. **Commit**: "feat: Add ResearchFundingView API endpoint"

#### Dependencies
- DRF (APIView, Response)
- ResearchFundingService
- ResearchFundingSerializer
- ErrorCodeRegistry (backend/data_ingestion/constants/error_codes.py)

#### Error Code Registry

**새 모듈 추가: backend/data_ingestion/constants/error_codes.py**

```python
class ErrorCode:
    """중앙화된 에러 코드 레지스트리"""

    # 입력 검증 에러
    INVALID_DEPARTMENT = 'INVALID_DEPARTMENT'
    INVALID_PERIOD = 'INVALID_PERIOD'

    # 데이터 에러
    NO_DATA_AVAILABLE = 'NO_DATA_AVAILABLE'

    # 서버 에러
    INTERNAL_SERVER_ERROR = 'INTERNAL_SERVER_ERROR'
```

**사용 예시:**
```python
from backend.data_ingestion.constants.error_codes import ErrorCode

if department not in valid_departments:
    return Response({
        'error_code': ErrorCode.INVALID_DEPARTMENT,
        'message': '유효하지 않은 학과명입니다.'
    }, status=400)
```

---

### 3.5 ResearchFundingSerializer

#### Location
`backend/data_ingestion/api/serializers.py`

#### Responsibility
- 요청 파라미터 검증 (department, period)
- 응답 데이터 직렬화
- 에러 메시지 구조화

#### Test Strategy
- **Unit Tests**: Serializer 검증 로직 테스트

#### Test Scenarios (Red Phase)

**Test Case 1: 유효한 파라미터 검증**
```python
def test_validate_valid_parameters():
    # Arrange
    serializer = ResearchFundingQuerySerializer(data={
        'department': '컴퓨터공학과',
        'period': '1year'
    })

    # Act
    is_valid = serializer.is_valid()

    # Assert
    assert is_valid
    assert serializer.validated_data['department'] == '컴퓨터공학과'
```

**Test Case 2: 기본값 설정**
```python
def test_default_values():
    # Arrange
    serializer = ResearchFundingQuerySerializer(data={})

    # Act
    is_valid = serializer.is_valid()

    # Assert
    assert is_valid
    assert serializer.validated_data['department'] == 'all'
    assert serializer.validated_data['period'] == 'latest'
```

**Test Case 3: 잘못된 period 값 검증**
```python
def test_invalid_period():
    # Arrange
    serializer = ResearchFundingQuerySerializer(data={
        'period': 'invalid_period'
    })

    # Act
    is_valid = serializer.is_valid()

    # Assert
    assert not is_valid
    assert 'period' in serializer.errors
```

#### Implementation Order (TDD Cycle)
1. **Red**: test_default_values 작성 → 실행 (실패)
2. **Green**: Serializer 클래스 정의 (기본값 설정) → 테스트 통과
3. **Red**: test_validate_valid_parameters 작성 → 실행 (실패)
4. **Green**: 필드 검증 로직 추가 → 테스트 통과
5. **Red**: test_invalid_period 작성 → 실행 (실패)
6. **Green**: ChoiceField로 허용 값 제한 → 테스트 통과
7. **Commit**: "feat: Add ResearchFundingSerializer with validation"

#### Dependencies
- DRF Serializers

---

### 3.6 useDashboardData Hook (Frontend)

#### Location
`frontend/src/hooks/useDashboardData.ts`

#### Responsibility
- API 호출 및 상태 관리 (LoadingStatus, error, data)
- 응답 데이터 변환 (Recharts 형식)
- 필터 변경 시 재요청
- TypeScript 타입 안정성 제공 (state-management.md 준수)

#### Test Strategy
- **Unit Tests**: React Testing Library로 Hook 동작 테스트
- **Mocking**: API 호출 Mock
- **Type Safety**: TypeScript 컴파일 타임 검증

#### TypeScript Type Definitions

**state-management.md에서 정의된 타입 사용:**

```typescript
// frontend/src/types/domain.ts (state-management.md에서 정의)
export type LoadingStatus = 'idle' | 'loading' | 'success' | 'error';

export interface ResearchFundingData {
  current_balance: number;
  current_balance_formatted: string;
  trend: Array<{
    month: string;
    month_formatted: string;
    balance: number;
    execution: number;
  }>;
}

export interface DashboardState {
  loadingStatus: LoadingStatus;
  data: ResearchFundingData | null;
  error: Error | null;
}
```

**Hook 구현 시그니처:**

```typescript
import { LoadingStatus, ResearchFundingData } from '@/types/domain';

interface UseDashboardDataOptions {
  department?: string;
  period?: string;
}

interface UseDashboardDataResult {
  loadingStatus: LoadingStatus;
  data: ResearchFundingData | null;
  error: Error | null;
  chartData: ChartDataPoint[];
  refetch: () => void;
}

export function useDashboardData(
  options?: UseDashboardDataOptions
): UseDashboardDataResult;
```

#### Test Scenarios (Red Phase)

**Test Case 1: 초기 로딩 상태**
```typescript
test('초기 로딩 상태 확인', () => {
  // Arrange
  const { result } = renderHook(() => useDashboardData());

  // Assert
  expect(result.current.loadingStatus).toBe('loading');
  expect(result.current.data).toBeNull();
  expect(result.current.error).toBeNull();
});
```

**Test Case 2: 데이터 로드 성공**
```typescript
test('API 호출 성공 시 데이터 반환', async () => {
  // Arrange
  const mockData: ResearchFundingData = {
    current_balance: 1530000000,
    current_balance_formatted: '15.3억원',
    trend: [
      {
        month: '2024-01',
        month_formatted: '2024년 1월',
        balance: 1200000000,
        execution: 150000000
      }
    ]
  };

  jest.spyOn(global, 'fetch').mockResolvedValue({
    ok: true,
    json: async () => ({ status: 'success', data: mockData })
  } as Response);

  // Act
  const { result, waitForNextUpdate } = renderHook(() => useDashboardData());
  await waitForNextUpdate();

  // Assert
  expect(result.current.loadingStatus).toBe('success');
  expect(result.current.data).toEqual(mockData);
  expect(result.current.error).toBeNull();
});
```

**Test Case 3: 데이터 변환 정확성**
```typescript
test('Recharts 형식으로 데이터 변환', async () => {
  // Arrange
  const mockApiResponse = {
    data: {
      current_balance: 1200000000,
      current_balance_formatted: '12.0억원',
      trend: [
        {
          month: '2024-01',
          month_formatted: '2024년 1월',
          balance: 1200000000,
          execution: 150000000
        }
      ]
    }
  };

  jest.spyOn(global, 'fetch').mockResolvedValue({
    ok: true,
    json: async () => mockApiResponse
  } as Response);

  // Act
  const { result, waitForNextUpdate } = renderHook(() => useDashboardData());
  await waitForNextUpdate();

  // Assert
  const chartData = result.current.chartData;
  expect(chartData[0].month).toBe('2024년 1월');
  expect(chartData[0].balance).toBe(12.0);  // 억원 단위
  expect(chartData[0].execution).toBe(1.5);
});
```

**Test Case 4: 에러 처리**
```typescript
test('API 호출 실패 시 에러 상태', async () => {
  // Arrange
  jest.spyOn(global, 'fetch').mockRejectedValue(
    new Error('Network error')
  );

  // Act
  const { result, waitForNextUpdate } = renderHook(() => useDashboardData());
  await waitForNextUpdate();

  // Assert
  expect(result.current.loadingStatus).toBe('error');
  expect(result.current.error).toBeTruthy();
  expect(result.current.data).toBeNull();
});
```

**Test Case 5: 필터 변경 시 재요청**
```typescript
test('필터 변경 시 API 재호출', async () => {
  // Arrange
  const fetchSpy = jest.spyOn(global, 'fetch').mockResolvedValue({
    ok: true,
    json: async () => ({
      status: 'success',
      data: { current_balance: 0, current_balance_formatted: '0억원', trend: [] }
    })
  } as Response);

  // Act
  const { result, rerender, waitForNextUpdate } = renderHook(
    ({department}: {department: string}) => useDashboardData({department}),
    {initialProps: {department: 'all'}}
  );
  await waitForNextUpdate();

  rerender({department: '컴퓨터공학과'});
  await waitForNextUpdate();

  // Assert
  expect(fetchSpy).toHaveBeenCalledTimes(2);
  expect(fetchSpy).toHaveBeenLastCalledWith(
    expect.stringContaining('department=컴퓨터공학과')
  );
});
```

#### Implementation Order (TDD Cycle)
1. **Red**: test_초기_로딩_상태 작성 → 실행 (실패)
2. **Green**: useDashboardData Hook 기본 구조 (useState<LoadingStatus>) → 테스트 통과
3. **Red**: test_API_호출_성공 작성 → 실행 (실패)
4. **Green**: useEffect로 fetch 구현 (TypeScript 타입 적용) → 테스트 통과
5. **Refactor**: 중복 코드 제거, 상수 분리, 타입 정의 추출
6. **Red**: test_데이터_변환_정확성 작성 → 실행 (실패)
7. **Green**: transformData() 함수 구현 (타입 가드 추가) → 테스트 통과
8. **Red**: test_에러_처리 작성 → 실행 (실패)
9. **Green**: try-catch로 에러 처리 (LoadingStatus 'error' 설정) → 테스트 통과
10. **Red**: test_필터_변경시_재요청 작성 → 실행 (실패)
11. **Green**: useEffect 의존성 배열에 필터 추가 → 테스트 통과
12. **Commit**: "feat: Add useDashboardData hook with TypeScript type safety"

#### Dependencies
- React (useState, useEffect)
- fetch API (또는 axios)
- TypeScript types from state-management.md (LoadingStatus, ResearchFundingData)

---

### 3.7 ResearchFundingChart Component

#### Location
`frontend/src/components/dashboard/ResearchFundingChart.tsx`

#### Responsibility
- Line Chart 렌더링 (Recharts)
- Tooltip 표시
- 로딩/에러/빈 상태 UI 처리
- XSS 방지 (React의 기본 escaping 활용)

#### Test Strategy
- **Integration Tests**: React Testing Library로 렌더링 검증
- **Snapshot Tests**: UI 변경 감지
- **Type Safety**: TypeScript Props 검증

#### TypeScript Props Interface

```typescript
import { LoadingStatus } from '@/types/domain';

interface ChartDataPoint {
  month: string;
  balance: number;
  execution: number;
}

interface ResearchFundingChartProps {
  data: ChartDataPoint[];
  loadingStatus: LoadingStatus;
  error: Error | null;
  onRetry?: () => void;
}
```

#### Security Note (XSS Prevention)

React는 기본적으로 JSX에 렌더링되는 모든 값을 자동으로 escape하여 XSS 공격을 방지합니다. `dangerouslySetInnerHTML`을 사용하지 않는 한 안전합니다.

```typescript
// 안전: React가 자동으로 escape
<span>{monthFormatted}</span>

// 위험: 사용 금지 (이 컴포넌트에서는 사용하지 않음)
// <div dangerouslySetInnerHTML={{__html: userInput}} />
```

#### Test Scenarios (Red Phase)

**Test Case 1: 차트 정상 렌더링**
```typescript
test('데이터와 함께 차트가 렌더링됨', () => {
  // Arrange
  const mockData: ChartDataPoint[] = [
    {month: '2024년 1월', balance: 12.0, execution: 1.5},
    {month: '2024년 2월', balance: 14.0, execution: 1.2}
  ];

  // Act
  render(
    <ResearchFundingChart
      data={mockData}
      loadingStatus="success"
      error={null}
    />
  );

  // Assert
  expect(screen.getByText('연구비 집행 추이')).toBeInTheDocument();
  expect(screen.getByText('2024년 1월')).toBeInTheDocument();
});
```

**Test Case 2: 로딩 상태**
```typescript
test('로딩 중일 때 스켈레톤 표시', () => {
  // Act
  render(
    <ResearchFundingChart
      data={[]}
      loadingStatus="loading"
      error={null}
    />
  );

  // Assert
  expect(screen.getByTestId('chart-skeleton')).toBeInTheDocument();
});
```

**Test Case 3: 빈 데이터 상태**
```typescript
test('데이터 없을 때 빈 상태 메시지', () => {
  // Act
  render(
    <ResearchFundingChart
      data={[]}
      loadingStatus="success"
      error={null}
    />
  );

  // Assert
  expect(screen.getByText('아직 등록된 데이터가 없습니다')).toBeInTheDocument();
});
```

**Test Case 4: 에러 상태**
```typescript
test('에러 발생 시 에러 메시지 표시', () => {
  // Arrange
  const mockError = new Error('데이터 로드 실패');
  const mockRetry = jest.fn();

  // Act
  render(
    <ResearchFundingChart
      data={[]}
      loadingStatus="error"
      error={mockError}
      onRetry={mockRetry}
    />
  );

  // Assert
  expect(screen.getByText('데이터 로드 실패')).toBeInTheDocument();
  expect(screen.getByText('재시도')).toBeInTheDocument();

  // Act: 재시도 버튼 클릭
  fireEvent.click(screen.getByText('재시도'));

  // Assert: onRetry 콜백 호출됨
  expect(mockRetry).toHaveBeenCalledTimes(1);
});
```

#### Implementation Order (TDD Cycle)
1. **Red**: test_로딩_상태 작성 → 실행 (실패)
2. **Green**: 로딩 조건부 렌더링 (LoadingStatus 타입 사용) → 테스트 통과
3. **Red**: test_빈_데이터_상태 작성 → 실행 (실패)
4. **Green**: 빈 상태 UI 추가 → 테스트 통과
5. **Red**: test_에러_상태 작성 → 실행 (실패)
6. **Green**: 에러 UI 및 재시도 버튼 추가 (onRetry 콜백) → 테스트 통과
7. **Red**: test_차트_정상_렌더링 작성 → 실행 (실패)
8. **Green**: Recharts LineChart 구현 (TypeScript Props 적용) → 테스트 통과
9. **Refactor**: 상태별 컴포넌트 분리 (ChartSkeleton, EmptyState, ErrorState), 타입 정의 추출
10. **Commit**: "feat: Add ResearchFundingChart with TypeScript and XSS prevention"

#### Dependencies
- React
- Recharts (LineChart, XAxis, YAxis, Tooltip)
- TypeScript types (LoadingStatus, ChartDataPoint)

---

### 3.8 ResearchFundingMetricCard Component

#### Location
`frontend/src/components/dashboard/ResearchFundingMetricCard.tsx`

#### Responsibility
- 현재 잔액 Metric Card 렌더링
- YoY 변화 아이콘 및 백분율 표시
- 로딩 상태 처리 (LoadingStatus 기반)

#### Test Strategy
- **Unit Tests**: 컴포넌트 렌더링 검증
- **Type Safety**: TypeScript Props 검증

#### TypeScript Props Interface

```typescript
import { LoadingStatus } from '@/types/domain';

interface ResearchFundingMetricCardProps {
  currentBalance?: number;
  currentBalanceFormatted: string;
  yearOverYearChange?: number;
  yearOverYearPercentage?: number;
  loadingStatus: LoadingStatus;
}
```

#### Test Scenarios (Red Phase)

**Test Case 1: Metric Card 정상 렌더링**
```typescript
test('Metric Card가 잔액과 변화율 표시', () => {
  // Arrange
  const props: ResearchFundingMetricCardProps = {
    currentBalance: 1530000000,
    currentBalanceFormatted: '15.3억원',
    yearOverYearChange: 210000000,
    yearOverYearPercentage: 15.8,
    loadingStatus: 'success'
  };

  // Act
  render(<ResearchFundingMetricCard {...props} />);

  // Assert
  expect(screen.getByText('현재 연구비 잔액')).toBeInTheDocument();
  expect(screen.getByText('15.3억원')).toBeInTheDocument();
  expect(screen.getByText(/15.8%/)).toBeInTheDocument();
  expect(screen.getByText('↑')).toBeInTheDocument();  // 증가 아이콘
});
```

**Test Case 2: 감소 시 아이콘 변경**
```typescript
test('YoY 감소 시 하향 아이콘 표시', () => {
  // Arrange
  const props: ResearchFundingMetricCardProps = {
    currentBalanceFormatted: '15.3억원',
    yearOverYearChange: -100000000,
    yearOverYearPercentage: -6.5,
    loadingStatus: 'success'
  };

  // Act
  render(<ResearchFundingMetricCard {...props} />);

  // Assert
  expect(screen.getByText('↓')).toBeInTheDocument();
  expect(screen.getByText(/-6.5%/)).toHaveClass('text-red-600');
});
```

**Test Case 3: 로딩 스켈레톤**
```typescript
test('로딩 중 스켈레톤 표시', () => {
  // Act
  render(
    <ResearchFundingMetricCard
      currentBalanceFormatted=""
      loadingStatus="loading"
    />
  );

  // Assert
  expect(screen.getByTestId('metric-skeleton')).toBeInTheDocument();
});
```

#### Implementation Order (TDD Cycle)
1. **Red**: test_Metric_Card_정상_렌더링 작성 → 실행 (실패)
2. **Green**: 기본 Metric Card 구조 구현 (TypeScript Props) → 테스트 통과
3. **Red**: test_감소시_아이콘_변경 작성 → 실행 (실패)
4. **Green**: YoY 조건부 렌더링 로직 추가 (타입 가드) → 테스트 통과
5. **Red**: test_로딩_스켈레톤 작성 → 실행 (실패)
6. **Green**: 로딩 상태 처리 (LoadingStatus 기반) → 테스트 통과
7. **Commit**: "feat: Add ResearchFundingMetricCard with TypeScript"

#### Dependencies
- React
- Tailwind CSS (또는 스타일링 라이브러리)
- TypeScript types (LoadingStatus)

---

### 3.9 QA Sheet (Presentation Layer 수동 테스트)

**목적:** E2E 테스트로 자동화하기 어려운 UI/UX 검증 항목

| 항목 | 검증 내용 | 예상 결과 | 상태 |
|------|-----------|-----------|------|
| 1. 초기 로드 | 브라우저에서 `/dashboard` 접속 | Line Chart와 Metric Card 표시됨 | [ ] |
| 2. 데이터 정확성 | 현재 잔액이 DB 값과 일치하는지 확인 | 정확한 금액 표시 | [ ] |
| 3. 차트 애니메이션 | 페이지 로드 시 차트 애니메이션 동작 | 부드러운 Line 드로잉 | [ ] |
| 4. Tooltip 표시 | 데이터 포인트에 마우스 호버 | 월별 집행액/잔액 Tooltip 표시 | [ ] |
| 5. 학과 필터 | "컴퓨터공학과" 선택 | 차트 데이터 필터링 및 리렌더링 | [ ] |
| 6. 필터 초기화 | "전체 보기" 버튼 클릭 | 전체 데이터로 복원 | [ ] |
| 7. 로딩 상태 | 네트워크 Throttling 설정 후 새로고침 | 스켈레톤 UI 표시 | [ ] |
| 8. 에러 처리 | 백엔드 서버 중지 후 접속 | 에러 메시지 및 "재시도" 버튼 표시 | [ ] |
| 9. 빈 데이터 | DB를 비운 후 접속 | "데이터가 없습니다" 메시지 표시 | [ ] |
| 10. 반응형 | 브라우저 창 크기 조절 (모바일 사이즈) | 차트가 반응형으로 조절됨 | [ ] |
| 11. 색상 대비 | 차트 색상이 배경과 명확히 구분되는지 | WCAG AA 기준 충족 | [ ] |
| 12. 키보드 접근성 | Tab 키로 필터 드롭다운 접근 | 필터가 포커스되고 Enter로 열림 | [ ] |

---

## 4. TDD Workflow

### 4.1 전체 구현 순서 (Outside-In 전략)

**이유:** 사용자 시나리오부터 시작하여 필요한 컴포넌트를 점진적으로 구현

1. **Phase 1: Domain & Infrastructure (Inside-Out)**
   - ResearchProject Model 구현
   - ResearchFundingRepository 구현
   - **Commit Point:** "feat: Add domain and data layer for research funding"

2. **Phase 2: Service Layer**
   - ResearchFundingService 구현
   - **Commit Point:** "feat: Add business logic for research funding dashboard"

3. **Phase 3: API Layer**
   - ResearchFundingSerializer 구현
   - ResearchFundingView 구현
   - **Commit Point:** "feat: Add REST API endpoint for research funding"

4. **Phase 4: Frontend Logic**
   - useDashboardData Hook 구현
   - **Commit Point:** "feat: Add frontend data fetching logic"

5. **Phase 5: Presentation Layer**
   - ResearchFundingChart 구현
   - ResearchFundingMetricCard 구현
   - **Commit Point:** "feat: Add UI components for research funding"

6. **Phase 6: Integration & E2E**
   - 전체 플로우 E2E 테스트 작성
   - **Commit Point:** "test: Add E2E tests for research funding dashboard"

7. **Phase 7: Refactoring & Optimization**
   - 코드 중복 제거
   - 쿼리 최적화
   - **Commit Point:** "refactor: Optimize research funding queries"

### 4.2 각 모듈별 TDD 사이클

**템플릿:**
```
1. Red: 실패하는 테스트 작성
   - 예상 동작 정의
   - 테스트 실행 → 실패 확인 (올바른 이유로 실패하는지 검증)

2. Green: 최소한의 코드로 테스트 통과
   - "Fake it till you make it" 접근
   - 테스트 실행 → 통과 확인

3. Refactor: 코드 개선 (테스트는 계속 통과)
   - 중복 제거
   - 네이밍 개선
   - 구조 단순화
   - 테스트 실행 → 여전히 통과 확인

4. Commit: 작은 단위로 커밋
   - 커밋 메시지: "feat/test/refactor: <변경 내용>"
```

### 4.3 테스트 실행 명령어

**Backend (Django):**
```bash
# 전체 테스트
python manage.py test

# 특정 앱
python manage.py test data_ingestion

# 특정 테스트 파일
python manage.py test data_ingestion.tests.test_research_funding_api

# Coverage 리포트
coverage run --source='.' manage.py test
coverage report
coverage html
```

**Frontend (React):**
```bash
# 전체 테스트
npm test

# Watch 모드
npm test -- --watch

# Coverage
npm test -- --coverage

# 특정 파일
npm test -- ResearchFundingChart.test.jsx
```

### 4.4 Commit Convention

```
feat: 새로운 기능 추가
test: 테스트 코드 추가/수정
refactor: 코드 리팩토링 (기능 변경 없음)
fix: 버그 수정
docs: 문서 수정
style: 코드 포맷팅 (세미콜론, 공백 등)
```

**예시:**
```
feat: Add ResearchProject model with validation
test: Add unit tests for ResearchFundingRepository
refactor: Extract currency formatting to utility function
fix: Handle null values in monthly trend calculation
```

### 4.5 정의 완료 (Definition of Done)

각 모듈 구현 완료 기준:

- [ ] 모든 테스트 케이스 작성 완료 (Red Phase)
- [ ] 모든 테스트 통과 (Green Phase)
- [ ] 코드 리팩토링 완료 (Refactor Phase)
- [ ] Test Coverage 80% 이상 (Unit Tests)
- [ ] Linter 경고 없음
- [ ] 타입 체크 통과 (TypeScript/PropTypes)
- [ ] 코드 리뷰 승인 (2명 이상)
- [ ] 문서화 완료 (Docstring/JSDoc)
- [ ] Commit 완료 및 Push

### 4.6 블로커 이슈 처리

**이슈 발견 시:**
1. 즉시 테스트 작성 (재현)
2. Red Phase 확인 (테스트 실패)
3. 근본 원인 분석
4. 최소한의 수정으로 Green Phase
5. Refactor 후 Commit
6. 이슈 트래커 업데이트

---

## 5. 위험 요소 및 완화 전략

### 5.1 기술적 위험

| 위험 요소 | 영향 | 완화 전략 |
|-----------|------|-----------|
| Django ORM 쿼리 성능 저하 | 대용량 데이터에서 차트 로딩 지연 | 1. 인덱스 추가 (department, execution_date) 2. 쿼리 최적화 (select_related) 3. 캐싱 전략 (POST-MVP) |
| Recharts 렌더링 성능 | 많은 데이터 포인트 시 애니메이션 끊김 | 1. 데이터 샘플링 (최대 100 포인트) 2. 애니메이션 비활성화 옵션 |
| 프런트엔드 에러 경계 | API 에러 시 전체 앱 크래시 | 1. React Error Boundary 구현 2. Fallback UI |
| 테스트 DB 격리 실패 | 테스트 간 데이터 오염 | 1. 각 테스트마다 setUp/tearDown 2. Django TransactionTestCase 사용 |

### 5.2 비즈니스 로직 위험

| 위험 요소 | 영향 | 완화 전략 |
|-----------|------|-----------|
| 잔액 계산 오류 (중복 total_budget) | 잘못된 데이터 표시 | 1. 명확한 비즈니스 룰 문서화 2. 다양한 엣지케이스 테스트 3. 실제 데이터로 검증 |
| 월별 집계 오류 (타임존 이슈) | 데이터 불일치 | 1. UTC 기준 통일 2. 타임존 변환 테스트 |
| 필터링 결과 없음 | 빈 화면 혼란 | 1. 명확한 빈 상태 메시지 2. 필터 초기화 버튼 |

---

## 6. MVP 범위 최종 확인

### 6.1 포함 기능 (P0-MVP)

- [x] ResearchProject Django Model
- [x] 현재 잔액 계산 API
- [x] 월별 집행 추이 API
- [x] 학과/기간 필터링
- [x] Line Chart 시각화
- [x] Metric Card (현재 잔액)
- [x] 기본 Tooltip
- [x] 로딩/에러/빈 상태 UI
- [x] 단위 테스트 (70%)
- [x] 통합 테스트 (20%)
- [x] E2E 테스트 (핵심 시나리오)

### 6.2 제외 기능 (POST-MVP)

- [ ] YoY 변화율 계산 (데이터 부족 시)
- [ ] 차트 확대/축소 (Zoom, Brush)
- [ ] 차트 클릭 드릴다운
- [ ] 데이터 내보내기 (CSV, PNG)
- [ ] 다중 학과 비교
- [ ] 커스텀 날짜 범위 선택
- [ ] 실시간 데이터 갱신 (폴링)
- [ ] 모바일 터치 최적화
- [ ] 고급 접근성 (스크린 리더 세부 지원)

---

## 7. 개발 일정 (예상)

| Phase | 작업 내용 | 예상 시간 | 담당 |
|-------|-----------|-----------|------|
| Phase 1 | Domain & Infrastructure (Model, Repository) | 4시간 | Backend Dev |
| Phase 2 | Service Layer | 3시간 | Backend Dev |
| Phase 3 | API Layer (View, Serializer) | 3시간 | Backend Dev |
| Phase 4 | Frontend Logic (Hook) | 4시간 | Frontend Dev |
| Phase 5 | Presentation (Chart, Metric Card) | 5시간 | Frontend Dev |
| Phase 6 | Integration & E2E Tests | 3시간 | QA + Dev |
| Phase 7 | Refactoring & Optimization | 2시간 | Dev Team |
| **총계** | | **24시간 (3일)** | |

**전제 조건:**
- 인프라 (Supabase, Railway) 이미 설정 완료
- 기본 프로젝트 구조 존재
- 테스트 환경 구성 완료

---

## 8. 체크리스트

### 8.1 구현 전 확인 사항

- [ ] spec.md 문서 정독 완료
- [ ] database.md에서 ResearchProject 스키마 확인
- [ ] userflow.md에서 사용자 시나리오 이해
- [ ] TDD 프로세스 숙지 (Red-Green-Refactor)
- [ ] 테스트 환경 설정 (Test DB, Mock 라이브러리)
- [ ] 개발 브랜치 생성 (`feat/002-research-funding-dashboard`)

### 8.2 구현 중 확인 사항

- [ ] 각 모듈마다 테스트 먼저 작성 (Test First)
- [ ] 테스트가 올바른 이유로 실패하는지 확인 (Red Phase)
- [ ] 최소한의 코드로 테스트 통과 (Green Phase)
- [ ] 리팩토링 후 테스트 여전히 통과 (Refactor Phase)
- [ ] 작은 단위로 자주 커밋
- [ ] Coverage 리포트 정기 확인 (목표: 80% 이상)

### 8.3 구현 완료 후 확인 사항

- [ ] 모든 Unit Tests 통과
- [ ] 모든 Integration Tests 통과
- [ ] E2E Tests 통과
- [ ] QA Sheet 수동 테스트 완료
- [ ] Linter 경고 없음
- [ ] 코드 리뷰 승인
- [ ] 문서 업데이트 (API 문서, README)
- [ ] PR 생성 및 Merge

---

## 9. 참고 자료

### 9.1 내부 문서
- [spec.md](./spec.md) - 기능 상세 유스케이스
- [/docs/database.md](../database.md) - DB 스키마
- [/docs/userflow.md](../userflow.md) - 유저플로우
- [/prompt/tdd.md](../../prompt/tdd.md) - TDD 프로세스 가이드라인

### 9.2 외부 자료
- [Django Testing Documentation](https://docs.djangoproject.com/en/stable/topics/testing/)
- [DRF Testing](https://www.django-rest-framework.org/api-guide/testing/)
- [React Testing Library](https://testing-library.com/docs/react-testing-library/intro/)
- [Recharts Documentation](https://recharts.org/en-US/)
- [Kent C. Dodds - Test Pyramid](https://kentcdodds.com/blog/the-testing-trophy-and-testing-classifications)

---

## 10. 문서 변경 이력

| 버전 | 날짜 | 변경 사항 | 작성자 |
|------|------|-----------|--------|
| 1.0 | 2025-11-02 | 초기 TDD 기반 Implementation Plan 작성 | Plan Writer Agent |
| 1.1 | 2025-11-02 | plancheck.md 권장사항 반영: (1) TypeScript 타입 안정성 추가 (state-management.md 준수), (2) Python threading 비동기 처리 명시, (3) ErrorCodeRegistry 중앙화, (4) XSS 방지 보안 노트 추가 | Claude Code |

---

## 11. 승인 및 검토

**작성자:** Plan Writer Agent
**검토자:** CTO
**승인일:** 2025-11-02

본 문서는 **TDD 원칙**을 준수하며, **MVP 범위**에 맞춘 구현 계획입니다. 각 모듈은 Red-Green-Refactor 사이클을 엄격히 따르며, Test First 접근 방식으로 개발됩니다.

**핵심 원칙 재확인:**
- ✅ Test First: 코드보다 테스트를 먼저 작성
- ✅ Small Steps: 한 번에 하나의 시나리오만 구현
- ✅ FIRST Principles: Fast, Independent, Repeatable, Self-validating, Timely
- ✅ Test Pyramid: Unit 70% > Integration 20% > Acceptance 10%
- ✅ Frequent Commits: 작은 단위로 자주 커밋

---

---

## 12. v1.1 업데이트 요약

### 12.1 주요 개선 사항 (plancheck.md 반영)

#### 1. TypeScript 타입 안정성 강화 (P1 Priority)

**문제점:**
- 기존: JavaScript (.js/.jsx) 기반, PropTypes 검증만 수행
- state-management.md의 타입 정의와 불일치

**해결책:**
- 모든 프론트엔드 모듈을 TypeScript (.ts/.tsx)로 전환
- state-management.md에서 정의한 `LoadingStatus`, `ResearchFundingData` 타입 사용
- useDashboardData Hook: `LoadingStatus` enum 기반 상태 관리 (`'idle' | 'loading' | 'success' | 'error'`)
- 컴포넌트 Props 인터페이스 명시적 정의

**영향받은 모듈:**
- `useDashboardData.ts` (Line 790)
- `ResearchFundingChart.tsx` (Line 1009)
- `ResearchFundingMetricCard.tsx` (Line 1164)

**테스트 코드 업데이트:**
- Mock 데이터에 타입 어노테이션 추가
- `loading: boolean` → `loadingStatus: LoadingStatus` 변경

#### 2. 비동기 처리 전략 명시 (P2 Priority)

**문제점:**
- 기존: "Python threading or simple task queue" 모호한 표현
- 구체적 구현 방법 없음

**해결책:**
- **Python threading 모듈 선택** (CTO 간소화 원칙)
- 구현 예시 코드 제공 (Line 32-66)
- 제약 사항 및 POST-MVP 마이그레이션 경로 문서화
- Celery/RQ 등 외부 Task Queue는 MVP 범위 제외

**이유:**
- 외부 의존성 없음 (Redis, RabbitMQ 불필요)
- 인프라 설정 시간 최소화
- 내부 관리자 도구 특성 (대용량 트래픽 미발생)

#### 3. 에러 코드 중앙화 (P2 Priority)

**문제점:**
- 에러 코드가 하드코딩됨 (`'INVALID_DEPARTMENT'`)
- 유지보수 어려움, 중복 가능성

**해결책:**
- 중앙화된 ErrorCodeRegistry 클래스 추가 (Line 680-706)
- `backend/data_ingestion/constants/error_codes.py` 모듈 생성
- 모든 에러 코드를 상수로 정의

**사용 예시:**
```python
from backend.data_ingestion.constants.error_codes import ErrorCode

if department not in valid_departments:
    return Response({
        'error_code': ErrorCode.INVALID_DEPARTMENT,
        'message': '유효하지 않은 학과명입니다.'
    }, status=400)
```

#### 4. XSS 방지 보안 노트 추가 (Security Enhancement)

**추가 내용:**
- ResearchFundingChart 컴포넌트에 XSS 방지 가이드라인 추가 (Line 1041-1051)
- React의 기본 escaping 메커니즘 설명
- `dangerouslySetInnerHTML` 사용 금지 명시

**보안 원칙:**
```typescript
// 안전: React가 자동으로 escape
<span>{monthFormatted}</span>

// 위험: 사용 금지
// <div dangerouslySetInnerHTML={{__html: userInput}} />
```

### 12.2 변경 사항 통계

| 카테고리 | 변경 내용 | 영향 범위 |
|----------|-----------|-----------|
| 파일 확장자 | `.js` → `.ts`, `.jsx` → `.tsx` | 프론트엔드 3개 모듈 |
| 타입 정의 | TypeScript 인터페이스 추가 | Hook 1개, 컴포넌트 2개 |
| 테스트 코드 | 타입 어노테이션 추가 | 15개 테스트 케이스 |
| 새 모듈 | ErrorCodeRegistry 클래스 | Backend 1개 모듈 |
| 문서 추가 | 비동기 처리 전략 섹션 | 35줄 코드 예시 포함 |
| 보안 강화 | XSS 방지 가이드라인 | 컴포넌트 1개 |

### 12.3 구현 시 주의사항

**Phase 4 (Frontend Logic) 구현 시:**
1. `frontend/src/types/domain.ts` 파일 먼저 생성 (state-management.md 타입 정의)
2. TypeScript 컴파일러 설정 확인 (`tsconfig.json`)
3. Jest 설정에 TypeScript 지원 추가 (`ts-jest`)

**Phase 3 (API Layer) 구현 시:**
1. `backend/data_ingestion/constants/error_codes.py` 먼저 생성
2. 모든 View에서 ErrorCode 클래스 import
3. 새 에러 발생 시 ErrorCode 클래스에 먼저 추가

**보안 검토 체크리스트:**
- [ ] React 컴포넌트에서 `dangerouslySetInnerHTML` 사용 여부 확인
- [ ] 사용자 입력값이 직접 렌더링되는 경우 escape 확인
- [ ] DRF CSRF middleware 활성화 상태 확인 (settings.py)

### 12.4 Definition of Done 업데이트

기존 DoD에 다음 항목 추가:

- [ ] TypeScript 컴파일 에러 없음 (`tsc --noEmit`)
- [ ] 모든 Props에 타입 정의 존재
- [ ] ErrorCode 상수 사용 (하드코딩 금지)
- [ ] XSS 방지 가이드라인 준수

---

**문서 끝**
</file>

<file path="002-research-funding-dashboard/spec.md">
# 연구비 집행 추이 대시보드 기능 상세 유스케이스

**기능 ID:** 002
**기능명:** 연구비 집행 추이 시각화 (P0-MVP)
**작성일:** 2025년 11월 2일
**작성자:** Spec Writer Agent
**수정자:** Claude Code
**버전:** 1.2 (speccheck.md P0 이슈 반영)

---

## 1. 기능 개요

본 기능은 대학교 연구비 집행 데이터를 시간에 따른 추이로 시각화하여, 연구비 잔액과 집행 패턴을 직관적으로 파악할 수 있도록 지원합니다. Line Chart를 통해 월별 집행 추이를 보여주고, Metric Card로 현재 총 연구비 잔액을 강조하여 표시합니다.

**핵심 가치:**
- 연구비 집행 추이를 한눈에 파악하여 예산 관리 의사결정 지원
- 학과별/기간별 필터링을 통한 세밀한 데이터 분석
- 인터랙티브한 차트로 상세 정보 확인

**데이터 소스:** `research_project_data.csv`
- 집행ID (String, PK)
- 소속학과 (String)
- 총연구비 (Int/Float)
- 집행일자 (Date)
- 집행금액 (Int/Float)

**기술 스택:**
- Backend: Django Rest Framework, Pandas
- Frontend: React, Recharts
- Data Fetching: useDashboardData Hook
- API: RESTful JSON API

---

## 2. 사용자 스토리

### 2.1 주요 사용자 스토리 (GIVEN-WHEN-THEN)

**스토리 1: 연구비 추이 조회**
```
GIVEN 내부 직원이 메인 대시보드에 접속했을 때
WHEN 연구비 집행 추이 차트가 로드되면
THEN 월별 연구비 잔액 추이가 Line Chart로 표시되고
AND 현재 총 연구비 잔액이 Metric Card에 표시된다
```

**스토리 2: 학과별 필터링**
```
GIVEN 사용자가 연구비 추이를 확인하고 있을 때
WHEN 학과 필터 드롭다운에서 "컴퓨터공학과"를 선택하면
THEN 해당 학과의 연구비 집행 추이만 차트에 표시되고
AND Metric Card도 해당 학과의 잔액으로 업데이트된다
```

**스토리 3: 상세 정보 확인**
```
GIVEN 사용자가 차트를 보고 있을 때
WHEN 특정 데이터 포인트에 마우스를 올리면
THEN Tooltip이 표시되어 해당 월의 집행금액과 잔액을 보여준다
```

**스토리 4: 데이터 없음 처리**
```
GIVEN 관리자가 아직 연구비 데이터를 업로드하지 않았을 때
WHEN 사용자가 대시보드에 접속하면
THEN 빈 상태 메시지와 함께 "데이터를 업로드하세요" 안내가 표시된다
```

---

## 3. 상세 유스케이스

### 3.1 Use Case: 연구비 추이 데이터 로드

**Primary Actor:** 내부 직원 (Viewer)

**Precondition:**
- 사용자가 메인 대시보드 URL에 접속
- 관리자가 `research_project_data.csv` 파일을 업로드 완료

**Trigger:** 메인 대시보드 페이지 로드

**Main Scenario:**
1. React 앱이 초기화되고 메인 대시보드 컴포넌트가 렌더링됨
2. `useDashboardData` Hook이 실행되어 API 요청 전송
   - `GET /api/dashboard/research-funding/?department=all&period=latest`
3. 백엔드 DRF View가 요청을 수신하고 쿼리 파라미터 파싱
4. Django ORM을 통해 Supabase에서 연구비 데이터 조회
5. 월별 집계 쿼리 실행:
   ```sql
   SELECT
       DATE_TRUNC('month', execution_date) AS month,
       SUM(total_budget) - SUM(execution_amount) AS balance,
       SUM(execution_amount) AS monthly_execution
   FROM research_projects
   GROUP BY month
   ORDER BY month ASC
   ```
6. 현재 총 잔액 계산:
   ```sql
   SELECT SUM(total_budget) - SUM(execution_amount) AS current_balance
   FROM research_projects
   ```
7. JSON 응답 생성 및 반환:
   ```json
   {
     "current_balance": 1530000000,
     "trend": [
       {"month": "2024-01", "balance": 1200000000, "execution": 150000000},
       {"month": "2024-02", "balance": 1400000000, "execution": 120000000},
       {"month": "2024-03", "balance": 1530000000, "execution": 100000000}
     ],
     "last_updated": "2025-11-02T14:35:22Z"
   }
   ```
8. 프런트엔드가 응답 데이터를 수신하고 Recharts 형식으로 변환
9. Line Chart 렌더링 (X축: 월, Y축: 잔액)
10. Metric Card 렌더링 (현재 잔액: 15.3억원)

**Edge Cases:**
- 데이터 없음: 빈 상태 UI 표시 ("아직 등록된 데이터가 없습니다")
- API 타임아웃: 에러 메시지 표시 및 재시도 버튼 제공
- 부분 데이터 로드 실패: 성공한 데이터는 표시, 실패 영역은 에러 카드
- 네트워크 단절: "네트워크 연결을 확인하세요" 경고 표시

**Business Rules:**
- **잔액 계산: `연구과제별 고유 total_budget 합계 - 모든 execution_amount 합계`**
  - 동일 연구과제에서 여러 번 집행 시 total_budget 중복 제거 필요
  - MVP에서는 execution_id별로 DISTINCT 처리하여 간소화
  - 예: 연구과제 A(100억)에서 2회 집행(10억, 20억) → 잔액 = 100억 - 30억 = 70억
- 월별 추이: 매월 말 시점의 누적 잔액 = `연구과제별 고유 총연구비 합계 - 해당 월까지의 누적 집행액`
- 월별 집계: 집행일자를 기준으로 월 단위 GROUP BY
- 금액 단위: 억원 (소수점 1자리까지 표시)
- 기본 필터: 전체 학과, 최근 1년

---

### 3.2 Use Case: 학과별 필터링

**Primary Actor:** 내부 직원 (Viewer)

**Precondition:**
- 연구비 추이 차트가 이미 로드된 상태
- 여러 학과의 데이터가 존재

**Trigger:** 학과 필터 드롭다운에서 특정 학과 선택

**Main Scenario:**
1. 사용자가 학과 필터 드롭다운 클릭
2. 학과 목록 표시 ("전체 학과", "컴퓨터공학과", "전자공학과", ...)
3. 사용자가 "컴퓨터공학과" 선택
4. React State 업데이트 (selectedDepartment: "컴퓨터공학과")
5. 300ms 디바운싱 후 API 재호출
   - `GET /api/dashboard/research-funding/?department=컴퓨터공학과&period=latest`
6. 백엔드에서 필터링된 쿼리 실행:
   ```sql
   SELECT
       DATE_TRUNC('month', execution_date) AS month,
       SUM(total_budget) - SUM(execution_amount) AS balance,
       SUM(execution_amount) AS monthly_execution
   FROM research_projects
   WHERE department = '컴퓨터공학과'
   GROUP BY month
   ORDER BY month ASC
   ```
7. 필터링된 데이터로 JSON 응답 반환
8. 차트 리렌더링 (애니메이션 효과)
9. Metric Card 업데이트 (해당 학과 잔액)
10. 필터 드롭다운에 선택된 값 표시
11. "전체 보기" 버튼 활성화

**Edge Cases:**
- 필터 결과 없음: "선택한 학과의 데이터가 없습니다" 메시지 표시
- 빠른 연속 선택: 디바운싱으로 마지막 선택만 적용
- API 에러: 기존 차트 유지, 에러 토스트 표시
- 잘못된 학과명: 400 Bad Request, 필터 초기화

**Business Rules:**
- 학과 필터는 단일 선택만 가능 (복수 선택 불가)
- 필터 적용 시 URL 쿼리 파라미터 업데이트 (POST-MVP)
- 필터 조합: department + period는 AND 조건
- 전체 학과 선택 시 WHERE 절 제거

---

### 3.3 Use Case: 차트 인터랙션 (Tooltip)

**Primary Actor:** 내부 직원 (Viewer)

**Precondition:**
- 연구비 추이 차트가 렌더링된 상태
- 차트에 최소 1개 이상의 데이터 포인트 존재

**Trigger:** 사용자가 Line Chart의 데이터 포인트에 마우스 호버

**Main Scenario:**
1. 사용자가 차트의 특정 데이터 포인트에 마우스 커서 이동
2. Recharts의 Tooltip 컴포넌트가 활성화됨
3. 해당 데이터 포인트의 정보 추출:
   - 월 (month): "2024년 3월"
   - 집행금액 (execution): 1.2억원
   - 잔액 (balance): 15.3억원
4. 커스텀 Tooltip 템플릿에 데이터 바인딩
5. 커서 근처에 Tooltip 팝업 표시:
   ```
   ┌─────────────────────────┐
   │ 2024년 3월              │
   │ 집행: 1.2억원           │
   │ 잔액: 15.3억원          │
   └─────────────────────────┘
   ```
6. 커서 이동 시 Tooltip 내용 자동 업데이트
7. 커서가 차트 영역을 벗어나면 Tooltip 사라짐

**Edge Cases:**
- 모바일 터치: 데이터 포인트 탭하여 Tooltip 고정 표시
- 여러 포인트 근접: 가장 가까운 포인트의 Tooltip만 표시
- 긴 텍스트: 최대 너비 설정, 줄바꿈 처리
- 데이터 포인트 1개: Tooltip 정상 작동

**Business Rules:**
- Tooltip 표시 위치: 커서 상단 우측 (차트 밖으로 나가지 않도록)
- 금액 포맷: 억원 단위, 쉼표 구분, 소수점 1자리
- 날짜 포맷: "YYYY년 M월" (예: "2024년 3월")
- 애니메이션: 페이드 인/아웃 (200ms)

---

## 4. API 명세

### 4.1 GET /api/dashboard/research-funding/

**용도:** 연구비 집행 추이 데이터 조회

**Method:** GET

**Request Headers:**
```
Content-Type: application/json
```

**Query Parameters:**

| 파라미터 | 타입 | 필수 | 기본값 | 설명 |
|---------|------|------|--------|------|
| department | String | No | "all" | 학과 필터 ("all" 또는 학과명) |
| period | String | No | "latest" | 기간 필터 ("latest", "1year", "3years", "2024") |
| start_date | Date | No | - | 시작 날짜 (YYYY-MM-DD) - POST-MVP |
| end_date | Date | No | - | 종료 날짜 (YYYY-MM-DD) - POST-MVP |

**Request Example:**
```
GET /api/dashboard/research-funding/?department=컴퓨터공학과&period=1year
```

**Response (Success - 200 OK):**
```json
{
  "status": "success",
  "data": {
    "current_balance": 1530000000,
    "current_balance_formatted": "15.3억원",
    "year_over_year_change": 210000000,
    "year_over_year_percentage": 15.8,
    "trend": [
      {
        "month": "2024-01",
        "month_formatted": "2024년 1월",
        "balance": 1200000000,
        "balance_formatted": "12.0억원",
        "execution": 150000000,
        "execution_formatted": "1.5억원"
      },
      {
        "month": "2024-02",
        "month_formatted": "2024년 2월",
        "balance": 1400000000,
        "balance_formatted": "14.0억원",
        "execution": 120000000,
        "execution_formatted": "1.2억원"
      },
      {
        "month": "2024-03",
        "month_formatted": "2024년 3월",
        "balance": 1530000000,
        "balance_formatted": "15.3억원",
        "execution": 100000000,
        "execution_formatted": "1.0억원"
      }
    ],
    "last_updated": "2025-11-02T14:35:22Z"
  }
}
```

**Response (No Data - 200 OK):**
```json
{
  "status": "success",
  "data": {
    "current_balance": 0,
    "current_balance_formatted": "0억원",
    "year_over_year_change": 0,
    "year_over_year_percentage": 0,
    "trend": [],
    "last_updated": null
  },
  "message": "데이터가 없습니다."
}
```

**Response (Error - 400 Bad Request):**
```json
{
  "status": "error",
  "error_code": "INVALID_DEPARTMENT",
  "message": "유효하지 않은 학과명입니다.",
  "details": {
    "field": "department",
    "value": "잘못된학과",
    "allowed_values": ["all", "컴퓨터공학과", "전자공학과", "..."]
  }
}
```

**Response (Error - 500 Internal Server Error):**
```json
{
  "status": "error",
  "error_code": "DATABASE_ERROR",
  "message": "데이터 조회 중 오류가 발생했습니다.",
  "details": null
}
```

---

## 5. 데이터 집계 로직

### 5.0 데이터베이스 스키마 (Django Model)

#### ResearchProject Model

**파일:** `backend/data_ingestion/infrastructure/models.py`

```python
from django.db import models
from django.core.validators import MinValueValidator

class ResearchProject(models.Model):
    """연구비 집행 데이터 모델"""

    # 비즈니스 PK (집행ID)
    execution_id = models.CharField(
        max_length=100,
        unique=True,  # 중복 방지
        verbose_name="집행ID"
    )

    # 연구과제 식별자 (중복 제거용) - POST-MVP 고려
    project_number = models.CharField(
        max_length=100,
        null=True,
        blank=True,
        verbose_name="과제번호",
        help_text="동일 연구과제 그룹핑을 위한 식별자 (예: NRF-2023-015)"
    )

    department = models.CharField(
        max_length=100,
        verbose_name="소속학과"
    )

    total_budget = models.BigIntegerField(
        validators=[MinValueValidator(0)],
        verbose_name="총연구비"
    )

    execution_date = models.DateField(
        verbose_name="집행일자"
    )

    execution_amount = models.BigIntegerField(
        validators=[MinValueValidator(0)],
        verbose_name="집행금액"
    )

    # 메타데이터
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        db_table = 'research_projects'
        indexes = [
            models.Index(fields=['department']),
            models.Index(fields=['execution_date']),
        ]
        verbose_name = "연구비 집행 데이터"
        verbose_name_plural = "연구비 집행 데이터 목록"

    def __str__(self):
        return f"{self.execution_id} - {self.department}"
```

**필드 명세:**

| 필드명 | 타입 | 제약 조건 | 설명 |
|--------|------|----------|------|
| execution_id | CharField(100) | unique=True | 집행ID (비즈니스 PK) |
| project_number | CharField(100) | null=True, blank=True | 과제번호 (동일 연구과제 그룹핑용, POST-MVP) |
| department | CharField(100) | null=False | 소속학과 |
| total_budget | BigIntegerField | validators=[MinValueValidator(0)] | 총연구비 (단위: 원) |
| execution_date | DateField | null=False | 집행일자 |
| execution_amount | BigIntegerField | validators=[MinValueValidator(0)] | 집행금액 (단위: 원) |
| created_at | DateTimeField | auto_now_add=True | 생성일시 |
| updated_at | DateTimeField | auto_now=True | 수정일시 |

**인덱스:**
- `department` (필터링 쿼리 최적화)
- `execution_date` (월별 집계 쿼리 최적화)
- `project_number` (POST-MVP: 연구과제별 그룹핑 최적화)

**CSV 컬럼 매핑:**

| CSV 컬럼명 | Model 필드명 | 변환 로직 | MVP 포함 여부 |
|-----------|------------|----------|-------------|
| 집행ID | execution_id | 문자열 그대로 | ✅ 필수 |
| 과제번호 | project_number | 문자열 그대로 | 🔵 선택 (POST-MVP) |
| 소속학과 | department | 문자열 그대로 | ✅ 필수 |
| 총연구비 | total_budget | int(value) | ✅ 필수 |
| 집행일자 | execution_date | pd.to_datetime(value) | ✅ 필수 |
| 집행금액 | execution_amount | int(value) | ✅ 필수 |

**참고:** CSV 파일에는 추가 컬럼(과제명, 연구책임자, 지원기관, 집행항목, 상태, 비고)이 있으나, MVP 대시보드에서는 미사용

#### 데이터 구조 가정 (Business Rules 명확화)

**연구비 데이터 구조:**
- 각 `execution_id`는 특정 연구과제의 1회 집행 건을 의미
- `total_budget`은 해당 연구과제의 전체 예산으로, 여러 execution_id에서 중복될 수 있음
- 동일 연구과제에서 여러 번 집행하는 경우, 각 집행 건마다 별도의 execution_id가 부여됨

**예시 데이터:**
```
연구과제 A (예산 100억원):
  - EX001: execution_id=EX001, total_budget=100억, execution_amount=10억 (1차 집행)
  - EX002: execution_id=EX002, total_budget=100억, execution_amount=20억 (2차 집행)

연구과제 B (예산 50억원):
  - EX003: execution_id=EX003, total_budget=50억, execution_amount=15억 (1차 집행)
```

**잔액 계산 로직:**
```
전체 잔액 = (연구과제별 고유 total_budget 합계) - (모든 execution_amount 합계)
         = (100억 + 50억) - (10억 + 20억 + 15억)
         = 150억 - 45억
         = 105억
```

**중요:**
- `total_budget` 합산 시 연구과제 중복 제거가 필요
- MVP에서는 `execution_id` 기준으로 DISTINCT 처리 (간소화)
- POST-MVP에서는 `project_id` 같은 별도 컬럼으로 연구과제 그룹핑 고려

**실제 CSV 데이터 구조 확인 (docs/db/research_project_data.csv):**
- CSV에는 `과제번호` 컬럼이 존재하여 동일 연구과제 식별 가능
- 예시: "NRF-2023-015" 과제는 T2301001, T2301003 두 개의 집행ID를 가짐
- 두 집행 건 모두 총연구비 500,000,000원을 공유
- **MVP 구현 시:** `과제번호` 컬럼을 Django Model에 추가하여 정확한 잔액 계산 가능
- **또는 간소화:** execution_id 기준 DISTINCT 유지 (샘플 데이터 확인 후 결정)

### 5.1 레이어 아키텍처 (CLAUDE.md 원칙 준수)

이 기능은 다음과 같은 레이어 분리를 따릅니다:

```
api/views.py (Presentation Layer)
  → services/research_funding_service.py (Business Logic Layer)
    → infrastructure/repositories.py (Data Access Layer)
      → models.py (Domain Layer)
```

**Presentation Layer (API View):**
```python
# api/views.py
from rest_framework.views import APIView
from rest_framework.response import Response
from services.research_funding_service import ResearchFundingService

class ResearchFundingView(APIView):
    def get(self, request):
        department = request.query_params.get('department', 'all')
        period = request.query_params.get('period', 'latest')

        service = ResearchFundingService()
        data = service.get_dashboard_data(department, period)

        return Response({"status": "success", "data": data})
```

**Service Layer (Business Logic):**
```python
# services/research_funding_service.py
from infrastructure.repositories import ResearchFundingRepository

class ResearchFundingService:
    def __init__(self):
        self.repository = ResearchFundingRepository()

    def get_dashboard_data(self, department, period):
        current_balance = self.repository.get_current_balance(department)
        monthly_trend = self.repository.get_monthly_trend(department, period)

        return {
            'current_balance': current_balance,
            'current_balance_formatted': self._format_currency(current_balance),
            'trend': [
                {
                    'month': item['month'],
                    'balance': item['balance'],
                    'execution': item['execution']
                }
                for item in monthly_trend
            ]
        }

    def _format_currency(self, amount):
        return f"{amount / 100000000:.1f}억원"
```

**Repository Layer (Data Access):**
```python
# infrastructure/repositories.py
from django.db.models import Sum
from django.db.models.functions import TruncMonth
from infrastructure.models import ResearchProject

class ResearchFundingRepository:
    def get_current_balance(self, department=None):
        queryset = ResearchProject.objects.all()

        if department and department != "all":
            queryset = queryset.filter(department=department)

        result = queryset.aggregate(
            total_budget=Sum('total_budget'),
            total_execution=Sum('execution_amount')
        )

        total_budget = result['total_budget'] or 0
        total_execution = result['total_execution'] or 0
        current_balance = total_budget - total_execution

        return current_balance
```

**월별 추이 데이터 집계:**
```python
from django.db.models import Sum, Q
from django.db.models.functions import TruncMonth
from django.utils import timezone
from datetime import timedelta

def get_monthly_trend(department=None, period='latest'):
    queryset = ResearchProject.objects.all()

    if department and department != "all":
        queryset = queryset.filter(department=department)

    # 기간 필터 적용
    if period == "1year":
        one_year_ago = timezone.now() - timedelta(days=365)
        queryset = queryset.filter(execution_date__gte=one_year_ago)
    elif period == "3years":
        three_years_ago = timezone.now() - timedelta(days=1095)
        queryset = queryset.filter(execution_date__gte=three_years_ago)

    # 전체 총연구비 (중복 제거: execution_id 기준 DISTINCT)
    # MVP 간소화: 동일 total_budget을 가진 execution_id들이 같은 연구과제로 간주
    # 실제로는 각 execution_id가 고유하므로 distinct() 사용
    unique_budgets = queryset.values('execution_id', 'total_budget').distinct()
    total_budget = sum([item['total_budget'] for item in unique_budgets])

    # 또는 Django ORM으로 구현:
    # total_budget = queryset.values('execution_id').annotate(
    #     budget=Sum('total_budget')
    # ).aggregate(
    #     total=Sum('budget')
    # )['total'] or 0

    # 월별 집행액 집계
    trend_data = queryset.annotate(
        month=TruncMonth('execution_date')
    ).values('month').annotate(
        monthly_execution=Sum('execution_amount')
    ).order_by('month')

    # 월별 누적 잔액 계산
    cumulative_execution = 0
    result = []

    for item in trend_data:
        monthly_execution = item['monthly_execution']
        cumulative_execution += monthly_execution

        # 잔액 = 연구과제별 고유 총연구비 - 누적 집행액
        balance = total_budget - cumulative_execution

        result.append({
            'month': item['month'].strftime('%Y-%m'),
            'balance': balance,
            'execution': monthly_execution
        })

    return result
```

**로직 설명:**
1. **전체 총연구비 계산:** execution_id별로 DISTINCT하여 중복 제거
   - 예: EX001(100억), EX002(100억) → 실제로는 각각 고유하므로 200억 (MVP 간소화)
   - POST-MVP: project_id 컬럼 추가하여 동일 연구과제 그룹핑
2. **월별 집행액 집계:** 집행일자 기준 월별 GROUP BY
3. **누적 잔액 계산:** 전체 총연구비 - 누적 집행액 (매월 업데이트)

**중요 가정 (MVP):**
- 현재 CSV 데이터에서 각 execution_id는 고유한 집행 건
- 동일 연구과제 구분을 위한 project_id 컬럼 없음
- 따라서 각 execution_id의 total_budget을 합산
- **실제 데이터 구조에 따라 로직 조정 필요** (샘플 CSV 확인 후)

### 5.2 데이터 변환 로직 (Frontend)

**Recharts 형식으로 변환:**
```javascript
// hooks/useDashboardData.js
function transformResearchFundingData(apiResponse) {
  const { data } = apiResponse;

  // Metric Card 데이터
  const metricData = {
    currentBalance: data.current_balance,
    currentBalanceFormatted: data.current_balance_formatted,
    yearOverYearChange: data.year_over_year_change,
    yearOverYearPercentage: data.year_over_year_percentage,
    lastUpdated: data.last_updated
  };

  // Chart 데이터
  const chartData = data.trend.map(item => ({
    month: item.month_formatted,
    balance: item.balance / 100000000, // 억원 단위
    execution: item.execution / 100000000,
    balanceFormatted: item.balance_formatted,
    executionFormatted: item.execution_formatted
  }));

  return { metricData, chartData };
}
```

---

## 6. UI 컴포넌트 구조

### 6.1 React 컴포넌트 트리

```
DashboardPage
├── DashboardHeader
│   ├── PageTitle
│   ├── FilterDropdowns
│   │   ├── DepartmentFilter
│   │   └── PeriodFilter
│   └── LastUpdatedInfo
├── MetricsRow
│   ├── ResearchFundingMetricCard
│   ├── StudentCountMetricCard
│   ├── PublicationMetricCard
│   └── KPIMetricCard
└── ChartsGrid
    ├── ResearchFundingChart (Line Chart)
    ├── StudentDistributionChart (Stacked Bar)
    ├── PublicationChart (Doughnut)
    └── KPITrendChart (Dual Line)
```

### 6.2 ResearchFundingChart 컴포넌트

**파일:** `frontend/src/components/dashboard/ResearchFundingChart.jsx`

**Props:**
```typescript
interface ResearchFundingChartProps {
  data: ChartDataPoint[];
  loading: boolean;
  error: Error | null;
  onRetry?: () => void;
}

interface ChartDataPoint {
  month: string;
  balance: number;
  execution: number;
  balanceFormatted: string;
  executionFormatted: string;
}
```

**Recharts 구조:**
```jsx
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer } from 'recharts';

function ResearchFundingChart({ data, loading, error, onRetry }) {
  if (loading) return <ChartSkeleton />;
  if (error) return <ChartError message={error.message} onRetry={onRetry} />;
  if (data.length === 0) return <EmptyChartState />;

  return (
    <div className="chart-container">
      <h3 className="chart-title">연구비 집행 추이</h3>
      <ResponsiveContainer width="100%" height={400}>
        <LineChart data={data} margin={{ top: 5, right: 30, left: 20, bottom: 5 }}>
          <CartesianGrid strokeDasharray="3 3" stroke="#e0e0e0" />
          <XAxis
            dataKey="month"
            stroke="#666"
            style={{ fontSize: '12px' }}
          />
          <YAxis
            stroke="#666"
            style={{ fontSize: '12px' }}
            label={{ value: '억원', angle: -90, position: 'insideLeft' }}
          />
          <Tooltip content={<CustomTooltip />} />
          <Line
            type="monotone"
            dataKey="balance"
            stroke="#2563eb"
            strokeWidth={2}
            dot={{ r: 4 }}
            activeDot={{ r: 6 }}
          />
        </LineChart>
      </ResponsiveContainer>
    </div>
  );
}
```

**CustomTooltip 컴포넌트:**
```jsx
function CustomTooltip({ active, payload, label }) {
  if (!active || !payload || !payload.length) return null;

  const data = payload[0].payload;

  return (
    <div className="custom-tooltip">
      <p className="tooltip-label">{label}</p>
      <p className="tooltip-execution">
        집행: <span className="value">{data.executionFormatted}</span>
      </p>
      <p className="tooltip-balance">
        잔액: <span className="value">{data.balanceFormatted}</span>
      </p>
    </div>
  );
}
```

### 6.3 ResearchFundingMetricCard 컴포넌트

**파일:** `frontend/src/components/dashboard/ResearchFundingMetricCard.jsx`

**Props:**
```typescript
interface MetricCardProps {
  currentBalance: number;
  currentBalanceFormatted: string;
  yearOverYearChange: number;
  yearOverYearPercentage: number;
  loading: boolean;
}
```

**렌더링 구조:**
```jsx
function ResearchFundingMetricCard({
  currentBalance,
  currentBalanceFormatted,
  yearOverYearChange,
  yearOverYearPercentage,
  loading
}) {
  if (loading) return <MetricCardSkeleton />;

  const isIncrease = yearOverYearChange > 0;
  const changeIcon = isIncrease ? '↑' : '↓';
  const changeColor = isIncrease ? 'text-green-600' : 'text-red-600';

  return (
    <div className="metric-card">
      <h4 className="metric-title">현재 연구비 잔액</h4>
      <p className="metric-value">{currentBalanceFormatted}</p>
      <div className={`metric-change ${changeColor}`}>
        <span className="change-icon">{changeIcon}</span>
        <span className="change-text">
          {Math.abs(yearOverYearChange / 100000000).toFixed(1)}억원
          ({yearOverYearPercentage.toFixed(1)}%)
        </span>
      </div>
      <p className="metric-description">전년 대비</p>
    </div>
  );
}
```

---

## 7. 테스트 요구사항 (TDD)

### 7.1 Unit Tests (백엔드)

**파일:** `backend/data_ingestion/tests/test_research_funding_api.py`

**테스트 케이스:**

```python
import pytest
from django.urls import reverse
from rest_framework.test import APIClient
from data_ingestion.infrastructure.models import ResearchProject

@pytest.mark.django_db
class TestResearchFundingAPI:

    def test_get_current_balance_all_departments(self):
        """전체 학과 잔액 조회 성공"""
        # Given: 연구비 데이터가 DB에 존재
        ResearchProject.objects.create(
            execution_id="EX001",
            department="컴퓨터공학과",
            total_budget=1000000000,
            execution_date="2024-01-15",
            execution_amount=200000000
        )

        # When: API 호출
        client = APIClient()
        response = client.get(reverse('research-funding-list'))

        # Then: 잔액 계산 정확성 검증
        assert response.status_code == 200
        assert response.data['data']['current_balance'] == 800000000

    def test_get_trend_with_department_filter(self):
        """학과 필터 적용 시 추이 데이터 조회"""
        # Given: 여러 학과 데이터
        ResearchProject.objects.bulk_create([
            ResearchProject(execution_id="EX001", department="컴퓨터공학과", ...),
            ResearchProject(execution_id="EX002", department="전자공학과", ...)
        ])

        # When: 특정 학과 필터 적용
        response = client.get(
            reverse('research-funding-list'),
            {'department': '컴퓨터공학과'}
        )

        # Then: 해당 학과 데이터만 반환
        assert len(response.data['data']['trend']) > 0
        for item in response.data['data']['trend']:
            assert "컴퓨터공학과" in str(item)

    def test_get_empty_data(self):
        """데이터 없을 때 빈 응답 반환"""
        # Given: 빈 DB

        # When: API 호출
        response = client.get(reverse('research-funding-list'))

        # Then: 빈 데이터 구조 반환
        assert response.status_code == 200
        assert response.data['data']['current_balance'] == 0
        assert response.data['data']['trend'] == []

    def test_invalid_department_parameter(self):
        """잘못된 학과명 파라미터 에러 처리"""
        # When: 존재하지 않는 학과명
        response = client.get(
            reverse('research-funding-list'),
            {'department': '존재하지않는학과'}
        )

        # Then: 400 에러
        assert response.status_code == 400
        assert response.data['error_code'] == 'INVALID_DEPARTMENT'
```

### 7.2 Integration Tests (프런트엔드)

**파일:** `frontend/src/components/dashboard/ResearchFundingChart.test.jsx`

**테스트 케이스:**

```javascript
import { render, screen, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import ResearchFundingChart from './ResearchFundingChart';

describe('ResearchFundingChart', () => {

  test('차트가 데이터와 함께 렌더링됨', async () => {
    // Given: 정상 데이터
    const mockData = [
      { month: '2024년 1월', balance: 12.0, execution: 1.5, ... },
      { month: '2024년 2월', balance: 14.0, execution: 1.2, ... }
    ];

    // When: 컴포넌트 렌더링
    render(<ResearchFundingChart data={mockData} loading={false} error={null} />);

    // Then: 차트 제목과 데이터 포인트 표시
    expect(screen.getByText('연구비 집행 추이')).toBeInTheDocument();
    await waitFor(() => {
      expect(screen.getByText('2024년 1월')).toBeInTheDocument();
    });
  });

  test('로딩 중일 때 스켈레톤 표시', () => {
    // When: 로딩 상태
    render(<ResearchFundingChart data={[]} loading={true} error={null} />);

    // Then: 스켈레톤 UI
    expect(screen.getByTestId('chart-skeleton')).toBeInTheDocument();
  });

  test('데이터 없을 때 빈 상태 메시지 표시', () => {
    // When: 빈 데이터
    render(<ResearchFundingChart data={[]} loading={false} error={null} />);

    // Then: 빈 상태 메시지
    expect(screen.getByText('아직 등록된 데이터가 없습니다')).toBeInTheDocument();
  });

  test('에러 발생 시 에러 메시지와 재시도 버튼 표시', () => {
    // Given: 에러 상태
    const mockError = new Error('데이터 로드 실패');
    const mockRetry = jest.fn();

    // When: 에러와 함께 렌더링
    render(<ResearchFundingChart data={[]} loading={false} error={mockError} onRetry={mockRetry} />);

    // Then: 에러 메시지와 재시도 버튼
    expect(screen.getByText('데이터 로드 실패')).toBeInTheDocument();
    const retryButton = screen.getByText('재시도');
    userEvent.click(retryButton);
    expect(mockRetry).toHaveBeenCalled();
  });
});
```

### 7.3 E2E Tests

**파일:** `frontend/cypress/e2e/research-funding-dashboard.cy.js`

**테스트 시나리오:**

```javascript
describe('연구비 집행 추이 대시보드 E2E', () => {

  beforeEach(() => {
    // Given: 테스트 데이터 시드
    cy.seedDatabase('research_funding');
    cy.visit('/dashboard');
  });

  it('사용자가 연구비 추이를 조회할 수 있다', () => {
    // When: 대시보드 로드

    // Then: Metric Card와 차트 표시
    cy.contains('현재 연구비 잔액').should('be.visible');
    cy.contains('15.3억원').should('be.visible');
    cy.get('[data-testid="research-funding-chart"]').should('be.visible');
  });

  it('학과 필터를 적용하여 특정 학과 데이터를 조회할 수 있다', () => {
    // When: 학과 필터 드롭다운 클릭
    cy.get('[data-testid="department-filter"]').click();
    cy.contains('컴퓨터공학과').click();

    // Then: 차트가 필터링된 데이터로 업데이트됨
    cy.wait('@getFilteredData');
    cy.get('[data-testid="metric-card"]').should('contain', '컴퓨터공학과');
  });

  it('차트 데이터 포인트 호버 시 Tooltip이 표시된다', () => {
    // When: 데이터 포인트에 마우스 호버
    cy.get('[data-testid="research-funding-chart"]')
      .find('.recharts-line-dot')
      .first()
      .trigger('mouseover');

    // Then: Tooltip 표시
    cy.get('.custom-tooltip').should('be.visible');
    cy.contains('2024년 1월').should('be.visible');
    cy.contains('집행:').should('be.visible');
    cy.contains('잔액:').should('be.visible');
  });

  it('데이터가 없을 때 빈 상태 메시지가 표시된다', () => {
    // Given: 빈 DB
    cy.clearDatabase('research_projects');

    // When: 대시보드 로드
    cy.visit('/dashboard');

    // Then: 빈 상태 UI
    cy.contains('아직 등록된 데이터가 없습니다').should('be.visible');
  });
});
```

---

## 8. 에러 처리

### 8.1 백엔드 에러 코드

| 에러 코드 | HTTP Status | 설명 | 사용자 메시지 |
|----------|-------------|------|--------------|
| `INVALID_DEPARTMENT` | 400 | 유효하지 않은 학과명 | "유효하지 않은 학과명입니다." |
| `INVALID_PERIOD` | 400 | 유효하지 않은 기간 파라미터 | "유효하지 않은 기간 설정입니다." |
| `INVALID_DATE_RANGE` | 400 | 시작일이 종료일보다 늦음 | "날짜 범위가 올바르지 않습니다." |
| `DATABASE_ERROR` | 500 | DB 조회 실패 | "데이터 조회 중 오류가 발생했습니다." |
| `NO_DATA` | 200 | 데이터 없음 (에러 아님) | "데이터가 없습니다." |

### 8.2 프런트엔드 에러 처리

**API 연결 에러:**
```javascript
try {
  const response = await fetchResearchFundingData(filters);
  setChartData(response.data);
} catch (error) {
  if (error.response?.status === 400) {
    showToast('error', error.response.data.message);
  } else if (error.response?.status === 500) {
    showToast('error', '서버 오류가 발생했습니다. 잠시 후 다시 시도하세요.');
  } else if (error.code === 'ECONNABORTED') {
    showToast('error', '요청 시간이 초과되었습니다.');
  } else {
    showToast('error', '네트워크 연결을 확인하세요.');
  }
  setError(error);
}
```

**차트 렌더링 에러:**
```javascript
// Error Boundary로 Recharts 렌더링 에러 캐치
class ChartErrorBoundary extends React.Component {
  state = { hasError: false };

  static getDerivedStateFromError(error) {
    return { hasError: true };
  }

  render() {
    if (this.state.hasError) {
      return (
        <div className="chart-error">
          <p>차트를 표시할 수 없습니다.</p>
          <button onClick={() => window.location.reload()}>새로고침</button>
        </div>
      );
    }
    return this.props.children;
  }
}
```

### 8.3 데이터 없음 처리

**빈 상태 UI:**
```jsx
function EmptyChartState() {
  return (
    <div className="empty-state">
      <svg className="empty-icon" width="120" height="120">
        {/* 빈 상태 일러스트레이션 */}
      </svg>
      <h3>아직 등록된 데이터가 없습니다</h3>
      <p>관리자가 데이터를 업로드하면 여기에 시각화가 표시됩니다.</p>
    </div>
  );
}
```

---

## 9. 성능 요구사항

### 9.1 로딩 시간 목표

| 메트릭 | 목표 | 측정 방법 |
|-------|------|----------|
| 초기 차트 로드 | < 2초 | Time to Interactive (TTI) |
| 필터 적용 후 리렌더링 | < 500ms | React DevTools Profiler |
| API 응답 시간 | < 1초 | Django Debug Toolbar |
| 차트 애니메이션 | 60fps | Chrome DevTools Performance |

### 9.2 최적화 전략

**백엔드:**
- DB 인덱스: `department`, `execution_date` 컬럼
- 쿼리 최적화: `select_related`, `prefetch_related` 사용 (필요시)
- 응답 데이터 최소화: 필요한 필드만 선택

**프런트엔드:**
- React.memo로 불필요한 리렌더링 방지
- useMemo로 데이터 변환 로직 캐싱
- 디바운싱으로 API 호출 최소화
- Lazy Loading으로 초기 번들 크기 감소

**캐싱 (POST-MVP):**
- React Query로 API 응답 캐싱 (5분)
- SWR (Stale-While-Revalidate) 전략

---

## 10. 접근성 (Accessibility)

### 10.1 ARIA 라벨

**차트 컨테이너:**
```jsx
<div
  role="img"
  aria-label="연구비 집행 추이 Line Chart. 월별 연구비 잔액 변화를 보여줍니다."
>
  <LineChart ... />
</div>
```

**Metric Card:**
```jsx
<div role="region" aria-labelledby="metric-title">
  <h4 id="metric-title">현재 연구비 잔액</h4>
  <p aria-label="잔액 15.3억원">15.3억원</p>
</div>
```

**필터 드롭다운:**
```jsx
<label htmlFor="department-filter">학과 선택</label>
<select
  id="department-filter"
  aria-label="학과 필터 선택"
  aria-describedby="filter-help"
>
  <option value="all">전체 학과</option>
  ...
</select>
<span id="filter-help" className="sr-only">
  학과를 선택하면 해당 학과의 연구비 데이터만 표시됩니다.
</span>
```

### 10.2 키보드 네비게이션

- Tab: 필터 드롭다운, 버튼 간 이동
- Enter/Space: 드롭다운 열기, 버튼 클릭
- Arrow Keys: 드롭다운 옵션 선택
- Esc: 드롭다운 닫기

### 10.3 색상 대비

- WCAG 2.1 Level AA 준수 (대비율 4.5:1 이상)
- 차트 라인: 파란색 (#2563eb) - 배경 대비 충분
- 텍스트: 진한 회색 (#333) - 흰 배경 대비 충분

---

## 11. 보안 요구사항

### 11.1 API 보안

**입력 검증 (Input Validation):**
| 파라미터 | 검증 규칙 | 에러 코드 |
|---------|----------|----------|
| department | 화이트리스트 기반 (DB에서 허용된 학과명 조회 후 검증) | INVALID_DEPARTMENT |
| period | IN ('latest', '1year', '3years', '2024') | INVALID_PERIOD |
| start_date | YYYY-MM-DD 형식, 미래 날짜 불허 | INVALID_DATE |
| end_date | start_date 이후 날짜 | INVALID_DATE_RANGE |

**SQL Injection 방어:**
- Django ORM의 Parameterized Query 자동 사용
- Raw SQL 사용 금지

**XSS 방어:**
- React 기본 이스케이핑 적용
- 사용자 입력 데이터는 서버에서도 sanitize

**Rate Limiting (POST-MVP):**
- 동일 IP에서 초당 10회 요청 제한

### 11.2 인증 및 권한 (MVP 간소화)

**MVP에서:**
- 모든 사용자가 조회 가능 (내부 직원 대상 가정)
- API Key 불필요

**POST-MVP:**
- JWT 기반 인증
- Role-based Access Control (관리자, 직원, 게스트)

---

## 12. Out of Scope (MVP 제외 기능)

다음 기능은 MVP에서 제외되며, 베타 피드백 후 우선순위 재평가:

1. **차트 확대/축소 (Zoom, Brush)**
   - 사용자가 특정 기간 구간을 확대하여 상세 조회
   - Recharts Brush 컴포넌트 사용

2. **차트 클릭 드릴다운**
   - 데이터 포인트 클릭 시 해당 학과/기간으로 자동 필터 적용
   - 상세 데이터 모달 표시

3. **데이터 내보내기**
   - CSV, PNG, PDF 형식으로 차트 다운로드
   - Excel 리포트 생성

4. **다중 학과 선택**
   - 여러 학과를 동시에 선택하여 비교
   - 각 학과별 라인을 다른 색상으로 표시

5. **커스텀 날짜 범위 선택**
   - 캘린더 UI로 시작일-종료일 직접 선택
   - 프리셋 (최근 1년, 3년) 외 자유 설정

6. **실시간 데이터 갱신**
   - 30초 간격 자동 폴링
   - 데이터 변경 시 알림

7. **모바일 최적화**
   - 터치 제스처 (스와이프, 핀치 줌)
   - 반응형 차트 크기 조정

8. **데이터 비교 모드**
   - 작년 동기 대비 비교 라인 표시
   - 예산 목표 대비 진행률

---

## 12. Sequence Diagram (PlantUML)

```plantuml
@startuml
actor User
participant FE as "Frontend\n(React)"
participant BE as "Backend\n(Django)"
participant DB as "Database\n(Supabase)"

== 초기 데이터 로드 ==
User -> FE: 대시보드 접속
activate FE
FE -> FE: 컴포넌트 초기화
FE -> FE: 스켈레톤 UI 렌더링
FE -> BE: GET /api/dashboard/research-funding/\n?department=all&period=latest
activate BE
BE -> BE: 요청 파라미터 파싱
BE -> BE: 필터 조건 검증
BE -> DB: SELECT 월별 집계 쿼리\nGROUP BY month
activate DB
DB --> BE: 집계 결과 반환
deactivate DB
BE -> DB: SELECT 현재 총 잔액 쿼리\nSUM(total_budget) - SUM(execution_amount)
activate DB
DB --> BE: 잔액 계산 결과
deactivate DB
BE -> BE: JSON 응답 생성
BE --> FE: 200 OK\n{ current_balance, trend[] }
deactivate BE
FE -> FE: 데이터 변환\n(Recharts 형식)
FE -> FE: Line Chart 렌더링
FE -> FE: Metric Card 렌더링
FE --> User: 차트 및 지표 표시
deactivate FE

== 학과 필터 적용 ==
User -> FE: 학과 필터 드롭다운 클릭
activate FE
FE --> User: 학과 목록 표시
User -> FE: "컴퓨터공학과" 선택
FE -> FE: State 업데이트\nselectedDepartment = "컴퓨터공학과"
FE -> FE: 300ms 디바운싱 대기
FE -> BE: GET /api/dashboard/research-funding/\n?department=컴퓨터공학과&period=latest
activate BE
BE -> BE: 필터 조건 검증
BE -> DB: SELECT 월별 집계 쿼리\nWHERE department = '컴퓨터공학과'\nGROUP BY month
activate DB
DB --> BE: 필터링된 집계 결과
deactivate DB
BE -> DB: SELECT 학과 잔액 쿼리\nWHERE department = '컴퓨터공학과'
activate DB
DB --> BE: 학과 잔액 결과
deactivate DB
BE --> FE: 200 OK\n{ current_balance, trend[] }
deactivate BE
FE -> FE: 차트 리렌더링 (애니메이션)
FE -> FE: Metric Card 업데이트
FE -> FE: "전체 보기" 버튼 활성화
FE --> User: 필터링된 차트 표시
deactivate FE

== 차트 인터랙션 (Tooltip) ==
User -> FE: 데이터 포인트에 마우스 호버
activate FE
FE -> FE: Recharts Tooltip 활성화
FE -> FE: 데이터 포인트 정보 추출\n{ month, balance, execution }
FE -> FE: CustomTooltip 렌더링
FE --> User: Tooltip 팝업 표시\n"2024년 3월\n집행: 1.2억원\n잔액: 15.3억원"
User -> FE: 마우스 이동 (차트 밖)
FE -> FE: Tooltip 비활성화
FE --> User: Tooltip 사라짐
deactivate FE

== 에러 처리 ==
User -> FE: 필터 변경 (잘못된 학과명)
activate FE
FE -> BE: GET /api/dashboard/research-funding/\n?department=존재하지않는학과
activate BE
BE -> BE: 학과명 검증 실패
BE --> FE: 400 Bad Request\n{ error_code: "INVALID_DEPARTMENT" }
deactivate BE
FE -> FE: 에러 핸들러 실행
FE -> FE: 토스트 알림 표시
FE --> User: "유효하지 않은 학과명입니다"
FE -> FE: 필터 초기화
deactivate FE

== 데이터 없음 처리 ==
User -> FE: 빈 DB 상태에서 접속
activate FE
FE -> BE: GET /api/dashboard/research-funding/
activate BE
BE -> DB: SELECT 쿼리
activate DB
DB --> BE: 빈 결과셋
deactivate DB
BE --> FE: 200 OK\n{ current_balance: 0, trend: [] }
deactivate BE
FE -> FE: 빈 상태 감지
FE -> FE: EmptyChartState 렌더링
FE --> User: "아직 등록된 데이터가 없습니다"
deactivate FE

@enduml
```

---

## 문서 변경 이력

| 버전 | 날짜 | 변경 사항 | 작성자 |
|------|------|-----------|--------|
| 1.0 | 2025-11-02 | 초기 상세 유스케이스 문서 작성 | Spec Writer Agent |
| 1.1 | 2025-11-02 | Critical Issues 반영: 비즈니스 로직 오류 수정(잔액 계산식), Service 레이어 아키텍처 추가, 보안 요구사항 섹션 추가 | Claude Code |
| 1.2 | 2025-11-02 | speccheck.md P0 이슈 반영: Django Model 정의 추가 (5.0절), 데이터 구조 가정 및 중복 제거 로직 명확화, Business Rules 상세화 | Claude Code |

---

## 승인 및 검토

**작성자:** Spec Writer Agent
**검토자:** CTO
**승인일:** 2025-11-02

본 문서는 MVP 범위의 연구비 집행 추이 대시보드 기능에 대한 상세 유스케이스입니다. TDD 원칙(Red-Green-Refactor, FIRST, Test Pyramid)을 준수하며, 오버엔지니어링 없이 필수 기능만 포함합니다.

---

**문서 끝**
</file>

<file path="003-student-dashboard/plan.md">
# 학과별 학생 현황 대시보드 구현 계획 (TDD 기반)

**기능 ID:** UC-003
**기능명:** 학과별 학생 현황 시각화 (P0-MVP)
**작성일:** 2025-11-02
**버전:** 1.0

---

## 1. 개요

### 1.1 구현 모듈 요약

| 레이어 | 모듈 | 위치 | 책임 | TDD 적용 |
|--------|------|------|------|----------|
| Infrastructure | Student Model | `backend/data_ingestion/infrastructure/models.py` | DB 스키마 정의 (Django ORM) | Migration Test + Schema Validation |
| Infrastructure | StudentRepository | `backend/data_ingestion/infrastructure/repositories.py` | 데이터 접근 계층 (필터링 쿼리) | Unit Test + Performance Test |
| Util | validationUtils | `backend/data_ingestion/utils/validation_utils.py` | XSS/SQL Injection 방어, 입력 검증 | Unit Test |
| Service | StudentDashboardService | `backend/data_ingestion/services/student_dashboard_service.py` | 비즈니스 로직 (집계, 검증, 보안) | Unit Test |
| Presentation | StudentDashboardView | `backend/data_ingestion/api/views.py` | HTTP 요청 처리 (Thin Controller) | Integration Test + Performance Test |
| Presentation | StudentDashboardSerializer | `backend/data_ingestion/api/serializers.py` | API 응답 직렬화 | Unit Test |
| Util | formatUtils | `frontend/src/utils/formatUtils.js` | 숫자/날짜 포맷 헬퍼 | Unit Test |
| Frontend Hook | useStudentDashboardData | `frontend/src/hooks/useStudentDashboardData.js` | API 호출 및 상태 관리 | Unit Test |
| Frontend Component | StudentBarChart | `frontend/src/components/dashboard/StudentBarChart.jsx` | Recharts 차트 렌더링 | Unit Test |
| Frontend Component | StudentMetricCard | `frontend/src/components/dashboard/StudentMetricCard.jsx` | 총 학생 수 카드 | Unit Test |
| Frontend Component | StudentDashboardFilters | `frontend/src/components/dashboard/StudentDashboardFilters.jsx` | 필터 UI (학과, 학적상태) | Unit Test |
| Frontend Component | ErrorBoundary | `frontend/src/components/ui/ErrorBoundary.jsx` | React 에러 캐치 및 폴백 UI | Unit Test |
| Frontend Component | ErrorCard | `frontend/src/components/ui/ErrorCard.jsx` | 에러 메시지 카드 (재시도 버튼) | Unit Test |
| Frontend Component | ErrorToast | `frontend/src/components/ui/ErrorToast.jsx` | 일시적 에러 토스트 메시지 | Unit Test |
| Frontend Page | StudentDashboardPage | `frontend/src/pages/StudentDashboardPage.jsx` | 페이지 통합 + 에러 처리 | E2E Test |

### 1.2 TDD 적용 범위

- **Unit Tests (70%)**: 모든 Service, Repository, Hook, Component
- **Integration Tests (10%)**: API 엔드포인트 + DB 조회 플로우
- **E2E Tests (10%)**: 전체 사용자 시나리오 (필터링, 차트 인터랙션)
- **Manual QA (10%)**: Recharts 시각적 검증, 브라우저 호환성

---

## 2. Architecture Diagram

```mermaid
graph TB
    subgraph Frontend["Frontend (React)"]
        Page[StudentDashboardPage]
        Hook[useStudentDashboardData]
        Chart[StudentBarChart]
        Metric[StudentMetricCard]
        Filters[StudentDashboardFilters]

        Page --> Hook
        Page --> Chart
        Page --> Metric
        Page --> Filters
        Hook --> Chart
        Hook --> Metric
    end

    subgraph API["API Layer (DRF)"]
        View[StudentDashboardView]
        Serializer[StudentDashboardSerializer]

        View --> Serializer
    end

    subgraph Service["Service Layer"]
        Service[StudentDashboardService]

        Service --> View
    end

    subgraph Infrastructure["Infrastructure Layer"]
        Repo[StudentRepository]
        Model[Student Model]

        Repo --> Model
        Service --> Repo
    end

    subgraph Database["Database (Supabase)"]
        DB[(students 테이블)]

        Model --> DB
    end

    Hook -->|GET /api/dashboard/students/| View

    style Frontend fill:#e1f5ff
    style API fill:#fff4e1
    style Service fill:#ffe1f5
    style Infrastructure fill:#e1ffe1
    style Database fill:#f0f0f0
```

---

## 3. Implementation Plan

### 3.1 Phase 1: Infrastructure Layer (DB 스키마 및 Repository)

#### Module: Student Model

**Location**: `backend/data_ingestion/infrastructure/models.py`

**Responsibility**:
- students 테이블 Django ORM 모델 정의
- 필드: student_id (PK), department, grade, program_type, enrollment_status, created_at, updated_at
- 필수 컬럼 NOT NULL 제약

**Test Strategy**: Migration Test + Model Field Validation

**Test Scenarios (Red Phase)**:
```python
# tests/test_student_model.py

# AAA Pattern 예시
def test_student_model_has_required_fields():
    """Arrange: 필수 필드를 모두 채운 Student 인스턴스 생성
       Act: save() 메서드 호출
       Assert: DB에 저장 성공 및 필드 값 검증"""
    pass

def test_student_id_is_primary_key():
    """Assert: _meta.pk.name == 'student_id'"""
    pass

def test_created_at_auto_now_add():
    """Assert: created_at이 현재 시간으로 자동 설정"""
    pass

def test_updated_at_auto_now():
    """Assert: 레코드 수정 시 updated_at 자동 업데이트"""
    pass

# Edge Cases
def test_duplicate_student_id_raises_integrity_error():
    """Assert: 동일 학번 중복 시 IntegrityError 발생"""
    pass

def test_department_max_length_100():
    """Assert: 학과명 100자 초과 시 ValidationError"""
    pass
```

**Implementation Order (TDD Cycle)**:
1. **Red**: `test_student_model_has_required_fields` 작성 → 실패 확인
2. **Green**: `Student` 모델 기본 필드 정의 → 테스트 통과
3. **Refactor**: 필드 이름 명확화, verbose_name 추가
4. **Red**: `test_student_id_is_primary_key` 작성 → 실패
5. **Green**: `student_id` 필드를 PK로 설정 → 통과
6. **Refactor**: Meta 클래스 정리
7. **Commit**: "Add Student model with required fields"

**Dependencies**: None (순수 Django ORM)

---

#### Module: StudentRepository

**Location**: `backend/data_ingestion/infrastructure/repositories.py`

**Responsibility**:
- 학과/학적상태 필터링 쿼리 전담
- `get_students_by_filter(department, status)` 메서드
- `get_all_departments()` 메서드 (학과 목록 조회)

**Test Strategy**: Unit Test (DB 쿼리 결과 검증)

**Test Scenarios (Red Phase)**:
```python
# tests/test_student_repository.py

@pytest.fixture
def sample_students(db):
    """테스트 데이터 픽스처: 다양한 학과/과정/학적상태 학생 생성"""
    return Student.objects.bulk_create([
        Student(student_id='2024001', department='컴퓨터공학과', grade=1, program_type='학사', enrollment_status='재학'),
        Student(student_id='2024002', department='컴퓨터공학과', grade=1, program_type='석사', enrollment_status='재학'),
        Student(student_id='2024003', department='전자공학과', grade=2, program_type='학사', enrollment_status='휴학'),
        Student(student_id='2024004', department='전자공학과', grade=3, program_type='학사', enrollment_status='졸업'),
    ])

def test_get_students_by_filter_all_departments_all_status(sample_students):
    """Arrange: 4명의 학생 데이터
       Act: repo.get_students_by_filter('all', 'all')
       Assert: 4명 전부 반환"""
    pass

def test_get_students_by_filter_specific_department(sample_students):
    """Act: repo.get_students_by_filter('컴퓨터공학과', 'all')
       Assert: 컴퓨터공학과 학생 2명만 반환"""
    pass

def test_get_students_by_filter_enrollment_status_only(sample_students):
    """Act: repo.get_students_by_filter('all', '재학')
       Assert: 재학생 2명만 반환"""
    pass

def test_get_students_by_filter_combined_filters(sample_students):
    """Act: repo.get_students_by_filter('컴퓨터공학과', '재학')
       Assert: 컴퓨터공학과 재학생 2명만 반환"""
    pass

def test_get_all_departments_returns_distinct_list(sample_students):
    """Act: repo.get_all_departments()
       Assert: ['컴퓨터공학과', '전자공학과'] 반환 (중복 제거)"""
    pass

# Edge Cases
def test_filter_nonexistent_department_returns_empty_queryset(sample_students):
    """Act: repo.get_students_by_filter('존재하지않는학과', 'all')
       Assert: QuerySet.count() == 0"""
    pass

def test_get_all_departments_empty_db():
    """Arrange: 학생 데이터 없음
       Act: repo.get_all_departments()
       Assert: 빈 리스트 반환"""
    pass
```

**Performance & Schema Validation Tests:**

```python
# tests/test_student_model.py (데이터베이스 스키마 검증)

def test_student_model_matches_database_schema():
    """Assert: Student 모델이 database.md 명세와 완전히 일치"""
    from django.db import connection

    with connection.cursor() as cursor:
        cursor.execute("""
            SELECT column_name, data_type, is_nullable, column_default
            FROM information_schema.columns
            WHERE table_name = 'students'
            ORDER BY ordinal_position;
        """)
        columns = cursor.fetchall()

    # database.md에 정의된 필드 검증
    expected_columns = {
        'student_id': ('character varying', 'NO'),
        'department': ('character varying', 'NO'),
        'grade': ('integer', 'NO'),
        'program_type': ('character varying', 'NO'),
        'enrollment_status': ('character varying', 'NO'),
        'created_at': ('timestamp with time zone', 'NO'),
        'updated_at': ('timestamp with time zone', 'NO'),
    }

    for col_name, data_type, is_nullable, _ in columns:
        assert col_name in expected_columns, f"예상치 못한 컬럼: {col_name}"
        expected_type, expected_nullable = expected_columns[col_name]
        assert expected_type in data_type, f"{col_name} 타입 불일치"
        assert is_nullable == expected_nullable, f"{col_name} NULL 제약 불일치"
```

**Implementation Order (TDD Cycle)**:
1. **Red**: `test_get_students_by_filter_all_departments_all_status` 작성 → 실패
2. **Green**: `StudentRepository` 클래스 생성, 기본 쿼리 로직 작성 → 통과
3. **Refactor**: 코드 정리, 변수명 명확화
4. **Red**: `test_get_students_by_filter_specific_department` 작성 → 실패
5. **Green**: department 필터 로직 추가 → 통과
6. **Red**: `test_get_students_by_filter_enrollment_status_only` 작성 → 실패
7. **Green**: enrollment_status 필터 로직 추가 → 통과
8. **Refactor**: 필터 조건을 메서드로 분리
9. **Commit**: "Add StudentRepository with filtering logic"

**Dependencies**: Student Model

---

### 3.2 Phase 2: Service Layer (비즈니스 로직)

#### Module: StudentDashboardService

**Location**: `backend/data_ingestion/services/student_dashboard_service.py`

**Responsibility**:
- 입력 파라미터 검증 (학과 존재 여부, 학적상태 화이트리스트)
- Repository를 통한 데이터 조회
- 학과별/과정별 집계 로직 (`_aggregate_by_department`)
- 응답 데이터 구조화 (total_students, by_department, updated_at)
- XSS 방어 및 SQL Injection 방지

**Security Implementation**:
```python
import bleach

class StudentDashboardService:
    def _sanitize_input(self, value):
        """XSS 방어: HTML 태그 제거"""
        return bleach.clean(value, strip=True)

    def _validate_inputs(self, department, status):
        """입력 검증 (SQL Injection, XSS 방어)"""
        # 학적상태 화이트리스트 검증
        ALLOWED_STATUSES = ['all', '재학', '휴학', '졸업']
        if status not in ALLOWED_STATUSES:
            raise ValidationError(f"유효하지 않은 학적상태: {status}")

        # 학과명 SQL Injection 방어
        if department != 'all':
            department = self._sanitize_input(department)
            valid_departments = self.repository.get_all_departments()
            if department not in valid_departments:
                raise ValidationError(f"존재하지 않는 학과: {department}")
```

**Test Strategy**: Unit Test (Repository 의존성은 Mock 처리)

**Test Scenarios (Red Phase)**:
```python
# tests/test_student_dashboard_service.py

@pytest.fixture
def mock_repo(mocker):
    """StudentRepository Mock 생성"""
    return mocker.Mock(spec=StudentRepository)

def test_validate_inputs_valid_parameters(mock_repo):
    """Arrange: 유효한 department='컴퓨터공학과', status='재학'
       Act: service._validate_inputs(department, status)
       Assert: ValidationError 발생하지 않음"""
    pass

def test_validate_inputs_invalid_status_raises_error(mock_repo):
    """Arrange: status='invalid_status'
       Act: service._validate_inputs('all', status)
       Assert: ValidationError('유효하지 않은 학적상태') 발생"""
    pass

def test_validate_inputs_nonexistent_department_raises_error(mock_repo):
    """Arrange: department='존재하지않는학과', mock_repo.get_all_departments() 반환 ['컴퓨터공학과']
       Act: service._validate_inputs(department, '재학')
       Assert: ValidationError('존재하지 않는 학과') 발생"""
    pass

def test_get_student_dashboard_data_all_students(mock_repo):
    """Arrange: mock_repo.get_students_by_filter() 반환 값 설정 (QuerySet Mock)
       Act: service.get_student_dashboard_data('all', '재학')
       Assert:
         - total_students == 예상 값
         - by_department 리스트 구조 검증
         - updated_at 존재"""
    pass

def test_aggregate_by_department_groups_by_program_type(mock_repo):
    """Arrange: 컴퓨터공학과 학생 (학사 2명, 석사 1명) QuerySet Mock
       Act: service._aggregate_by_department(queryset)
       Assert: 반환 리스트에 {'department': '컴퓨터공학과', '학사': 2, '석사': 1, '박사': 0, 'total': 3} 포함"""
    pass

def test_aggregate_by_department_orders_by_total_desc(mock_repo):
    """Arrange: 전자공학과(10명), 컴퓨터공학과(20명) QuerySet Mock
       Act: service._aggregate_by_department(queryset)
       Assert: 반환 리스트 첫 번째 항목이 컴퓨터공학과 (학생 수 내림차순)"""
    pass

# Edge Cases
def test_get_student_dashboard_data_no_students(mock_repo):
    """Arrange: mock_repo.get_students_by_filter() 반환 빈 QuerySet
       Act: service.get_student_dashboard_data('all', '재학')
       Assert: total_students == 0, by_department == []"""
    pass

def test_aggregate_handles_missing_program_types(mock_repo):
    """Arrange: 학과에 학사만 있고 석사/박사 없음
       Act: service._aggregate_by_department(queryset)
       Assert: {'학사': N, '석사': 0, '박사': 0}"""
    pass
```

**Implementation Order (TDD Cycle)**:
1. **Red**: `test_validate_inputs_valid_parameters` 작성 → 실패
2. **Green**: `StudentDashboardService` 클래스 생성, `_validate_inputs` 메서드 구현 → 통과
3. **Red**: `test_validate_inputs_invalid_status_raises_error` 작성 → 실패
4. **Green**: 학적상태 화이트리스트 검증 로직 추가 → 통과
5. **Red**: `test_validate_inputs_nonexistent_department_raises_error` 작성 → 실패
6. **Green**: 학과 존재 여부 검증 로직 추가 → 통과
7. **Refactor**: 검증 로직 메서드 분리, 매직 넘버 상수화
8. **Red**: `test_get_student_dashboard_data_all_students` 작성 → 실패
9. **Green**: `get_student_dashboard_data` 메서드 구현 → 통과
10. **Red**: `test_aggregate_by_department_groups_by_program_type` 작성 → 실패
11. **Green**: `_aggregate_by_department` 메서드 구현 (Django ORM annotate 사용) → 통과
12. **Refactor**: 쿼리 최적화, 변수명 정리
13. **Commit**: "Add StudentDashboardService with validation and aggregation"

**Dependencies**: StudentRepository

---

### 3.2.5 Phase 2.5: Utility Functions

#### Module: formatUtils.js

**Location**: `frontend/src/utils/formatUtils.js`

**Functions:**
1. `formatNumber(value)`: 천 단위 쉼표 포맷 (1234 → "1,234")
2. `formatDate(isoString)`: ISO 8601 → "2025년 11월 2일"
3. `formatPercentage(value)`: 소수 → "78.5%"

**Test Scenarios:**
```javascript
describe('formatUtils', () => {
  it('formatNumber adds thousand separators', () => {
    expect(formatNumber(1234)).toBe('1,234');
    expect(formatNumber(1234567)).toBe('1,234,567');
    expect(formatNumber(0)).toBe('0');
  });

  it('formatDate converts ISO to Korean format', () => {
    expect(formatDate('2025-11-02T14:35:22Z')).toBe('2025년 11월 2일');
  });

  it('formatPercentage formats decimal to percentage', () => {
    expect(formatPercentage(0.785)).toBe('78.5%');
    expect(formatPercentage(1)).toBe('100.0%');
  });
});
```

---

#### Module: validationUtils.py

**Location**: `backend/data_ingestion/utils/validation_utils.py`

**Functions:**
1. `sanitize_string(value)`: XSS 방어용 HTML 태그 제거
2. `validate_department_name(name)`: 학과명 형식 검증
3. `validate_enum_value(value, allowed_values)`: Enum 검증

**Test Scenarios:**
```python
def test_sanitize_string_removes_html_tags():
    assert sanitize_string('<script>alert("XSS")</script>') == 'alert("XSS")'
    assert sanitize_string('컴퓨터공학과') == '컴퓨터공학과'

def test_validate_department_name():
    assert validate_department_name('컴퓨터공학과') is True
    assert validate_department_name('') is False
    assert validate_department_name('A' * 101) is False  # 100자 초과

def test_validate_enum_value():
    allowed = ['재학', '휴학', '졸업']
    assert validate_enum_value('재학', allowed) is True
    assert validate_enum_value('invalid', allowed) is False
```

---

### 3.3 Phase 3: Presentation Layer (API 엔드포인트)

#### Module: StudentDashboardSerializer

**Location**: `backend/data_ingestion/api/serializers.py`

**Responsibility**:
- API 응답 데이터 직렬화
- 필드: total_students, by_department, updated_at

**Test Strategy**: Unit Test

**Test Scenarios (Red Phase)**:
```python
# tests/test_student_dashboard_serializer.py

def test_serializer_with_valid_data():
    """Arrange: 유효한 딕셔너리 데이터 (total_students, by_department, updated_at)
       Act: serializer = StudentDashboardSerializer(data)
       Assert: serializer.data가 예상 JSON 구조와 일치"""
    pass

def test_serializer_datetime_format():
    """Arrange: updated_at이 datetime 객체인 데이터
       Act: serializer.data['updated_at']
       Assert: ISO 8601 포맷 문자열 (예: '2025-11-02T14:35:22Z')"""
    pass

# Edge Cases
def test_serializer_with_empty_by_department():
    """Arrange: by_department = []
       Act: serializer.data
       Assert: 정상 직렬화 (빈 리스트 허용)"""
    pass
```

**Implementation Order (TDD Cycle)**:
1. **Red**: `test_serializer_with_valid_data` 작성 → 실패
2. **Green**: `StudentDashboardSerializer` 클래스 생성, 필드 정의 → 통과
3. **Red**: `test_serializer_datetime_format` 작성 → 실패
4. **Green**: DateTimeField 설정 추가 → 통과
5. **Commit**: "Add StudentDashboardSerializer"

**Dependencies**: None (순수 DRF Serializer)

---

#### Module: StudentDashboardView

**Location**: `backend/data_ingestion/api/views.py`

**Responsibility**:
- GET /api/dashboard/students/ 엔드포인트 처리
- Query Parameter 파싱 (department, status)
- StudentDashboardService 호출
- HTTP 응답 반환 (200 OK, 400 Bad Request, 404 Not Found)

**Test Strategy**: Integration Test (DRF APIClient 사용)

**Test Scenarios (Red Phase)**:
```python
# tests/integration/test_student_dashboard_api.py

@pytest.fixture
def api_client():
    return APIClient()

@pytest.fixture
def sample_students(db):
    """통합 테스트용 실제 DB 데이터"""
    return Student.objects.bulk_create([
        Student(student_id='2024001', department='컴퓨터공학과', grade=1, program_type='학사', enrollment_status='재학'),
        Student(student_id='2024002', department='컴퓨터공학과', grade=2, program_type='석사', enrollment_status='재학'),
        Student(student_id='2024003', department='전자공학과', grade=1, program_type='학사', enrollment_status='휴학'),
    ])

def test_get_endpoint_returns_200_with_valid_params(api_client, sample_students):
    """Arrange: 샘플 학생 데이터 존재
       Act: GET /api/dashboard/students/?department=all&status=재학
       Assert:
         - status_code == 200
         - response.json()에 total_students, by_department, updated_at 포함"""
    pass

def test_get_endpoint_filters_by_department(api_client, sample_students):
    """Act: GET /api/dashboard/students/?department=컴퓨터공학과&status=all
       Assert:
         - total_students == 2
         - by_department 리스트 길이 1 (컴퓨터공학과만)"""
    pass

def test_get_endpoint_filters_by_enrollment_status(api_client, sample_students):
    """Act: GET /api/dashboard/students/?department=all&status=재학
       Assert:
         - total_students == 2 (재학생만)"""
    pass

def test_get_endpoint_invalid_status_returns_400(api_client):
    """Act: GET /api/dashboard/students/?status=invalid_status
       Assert:
         - status_code == 400
         - response.json()['error'] 존재"""
    pass

def test_get_endpoint_nonexistent_department_returns_400(api_client, sample_students):
    """Act: GET /api/dashboard/students/?department=존재하지않는학과
       Assert:
         - status_code == 400
         - error message 포함"""
    pass

def test_get_endpoint_no_data_returns_empty_list(api_client):
    """Arrange: 학생 데이터 없음
       Act: GET /api/dashboard/students/
       Assert:
         - status_code == 200
         - total_students == 0
         - by_department == []"""
    pass

# Edge Cases
def test_get_endpoint_missing_query_params_uses_defaults(api_client, sample_students):
    """Act: GET /api/dashboard/students/ (파라미터 없음)
       Assert:
         - department='all', status='재학' 기본값 적용
         - status_code == 200"""
    pass
```

**Implementation Order (TDD Cycle)**:
1. **Red**: `test_get_endpoint_returns_200_with_valid_params` 작성 → 실패
2. **Green**: `StudentDashboardView` 클래스 생성, GET 메서드 구현 → 통과
3. **Red**: `test_get_endpoint_filters_by_department` 작성 → 실패
4. **Green**: Query Parameter 파싱 로직 추가 → 통과
5. **Red**: `test_get_endpoint_invalid_status_returns_400` 작성 → 실패
6. **Green**: try-except로 ValidationError 처리, 400 응답 반환 → 통과
7. **Refactor**: 에러 응답 포맷 통일, 코드 정리
8. **Commit**: "Add StudentDashboardView API endpoint"

**Dependencies**: StudentDashboardService, StudentDashboardSerializer

---

### 3.3.1 에러 코드 및 응답 구조 명세

#### 표준 에러 응답 형식

모든 에러는 다음 JSON 구조로 반환:
```json
{
  "error": "error_code",
  "message": "User-friendly error message (Korean)",
  "details": "Optional detailed information",
  "timestamp": "2025-11-02T14:35:22Z"
}
```

#### 에러 코드 매핑 테이블

| HTTP Status | Error Code | 발생 시나리오 | 메시지 예시 | 권장 조치 |
|-------------|------------|-------------|-----------|---------|
| 400 | `validation_error` | 유효하지 않은 학적상태 입력 | "유효하지 않은 학적상태: 'invalid_status'" | 허용된 값: 재학, 휴학, 졸업, all |
| 400 | `validation_error` | 존재하지 않는 학과 | "존재하지 않는 학과: '존재하지않는학과'" | 학과 목록 조회 후 재시도 |
| 400 | `invalid_parameter` | 잘못된 쿼리 파라미터 형식 | "잘못된 파라미터 형식" | API 문서 참조 |
| 404 | `not_found` | 필터 조건에 해당하는 학생 없음 | "조건에 맞는 학생 데이터가 없습니다" | 필터 조건 변경 또는 '전체 보기' |
| 500 | `server_error` | 데이터베이스 연결 실패 | "서버 오류가 발생했습니다" | 잠시 후 재시도 |
| 500 | `server_error` | 예상치 못한 서버 에러 | "데이터 처리 중 문제가 발생했습니다" | 관리자 문의 |

#### 테스트 시나리오 추가

```python
# tests/integration/test_student_dashboard_api.py

def test_error_response_structure(api_client):
    """Act: 잘못된 요청 전송
       Assert: 에러 응답이 표준 구조를 따름 (error, message, details, timestamp)"""
    response = api_client.get('/api/dashboard/students/?status=invalid')
    assert response.status_code == 400
    data = response.json()
    assert 'error' in data
    assert 'message' in data
    assert 'timestamp' in data

def test_404_error_with_empty_result(api_client):
    """Arrange: DB에 데이터 없음
       Act: GET /api/dashboard/students/
       Assert: 200 OK with empty list (설계 결정: 빈 결과는 404가 아닌 200 반환)"""
    response = api_client.get('/api/dashboard/students/')
    assert response.status_code == 200
    data = response.json()
    assert data['total_students'] == 0
    assert data['by_department'] == []
```

#### Security Test Scenarios

```python
# tests/test_student_dashboard_service.py (보안 검증)

def test_xss_prevention_in_department_filter(mock_repo):
    """Act: department='<script>alert("XSS")</script>' 전송
       Assert: Sanitized된 값으로 처리 또는 ValidationError 발생"""
    service = StudentDashboardService(mock_repo)
    mock_repo.get_all_departments.return_value = ['컴퓨터공학과']

    with pytest.raises(ValidationError) as exc:
        service.get_student_dashboard_data('<script>alert("XSS")</script>', '재학')

    assert '존재하지 않는 학과' in str(exc.value)

def test_sql_injection_prevention(mock_repo):
    """Act: department="'; DROP TABLE students; --" 전송
       Assert: ValidationError 발생, DB 영향 없음"""
    service = StudentDashboardService(mock_repo)
    mock_repo.get_all_departments.return_value = ['컴퓨터공학과']

    with pytest.raises(ValidationError) as exc:
        service.get_student_dashboard_data("'; DROP TABLE students; --", '재학')

    assert '존재하지 않는 학과' in str(exc.value)
```

#### API Performance Requirements Test

```python
# tests/integration/test_student_dashboard_api.py (성능 검증)

import time

def test_api_response_time_meets_sla(api_client, sample_students):
    """Act: GET /api/dashboard/students/ 10회 호출
       Assert: 평균 응답 시간 < 500ms"""
    durations = []

    for _ in range(10):
        start = time.time()
        response = api_client.get('/api/dashboard/students/?department=all&status=재학')
        duration = (time.time() - start) * 1000  # ms
        durations.append(duration)
        assert response.status_code == 200

    avg_duration = sum(durations) / len(durations)
    assert avg_duration < 500, f"평균 응답 시간 {avg_duration:.2f}ms가 500ms를 초과합니다"

    # 최악의 경우도 1초 이내
    max_duration = max(durations)
    assert max_duration < 1000, f"최대 응답 시간 {max_duration:.2f}ms가 1000ms를 초과합니다"
```

---

### 3.4 Phase 4: Frontend Hook (API 통신 및 상태 관리)

#### Module: useStudentDashboardData

**Location**: `frontend/src/hooks/useStudentDashboardData.js`

**Responsibility**:
- API 호출 (GET /api/dashboard/students/)
- 로딩/에러 상태 관리
- 필터 상태 관리 (department, status)
- 300ms 디바운싱

**Test Strategy**: Unit Test (Jest + React Testing Library)

**Test Scenarios (Red Phase)**:
```javascript
// tests/useStudentDashboardData.test.js

import { renderHook, waitFor, act } from '@testing-library/react';
import { useStudentDashboardData } from './useStudentDashboardData';
import * as api from '../api/dataApiClient';

jest.mock('../api/dataApiClient');

describe('useStudentDashboardData', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  it('loads data on mount with default filters', async () => {
    // Arrange
    const mockData = { total_students: 100, by_department: [], updated_at: '2025-11-02T14:35:22Z' };
    api.fetchStudentData.mockResolvedValue(mockData);

    // Act
    const { result } = renderHook(() => useStudentDashboardData());

    // Assert (초기 로딩 상태)
    expect(result.current.loading).toBe(true);

    // Assert (데이터 로드 완료)
    await waitFor(() => expect(result.current.loading).toBe(false));
    expect(result.current.data).toEqual(mockData);
    expect(result.current.error).toBeNull();
    expect(api.fetchStudentData).toHaveBeenCalledWith({ department: 'all', status: '재학' });
  });

  it('updates data when filter changes', async () => {
    // Arrange
    api.fetchStudentData.mockResolvedValue({ total_students: 50, by_department: [] });
    const { result } = renderHook(() => useStudentDashboardData());
    await waitFor(() => expect(result.current.loading).toBe(false));

    // Act
    act(() => {
      result.current.updateFilter('department', '컴퓨터공학과');
    });

    // Assert (디바운싱 후 API 재호출)
    await waitFor(() =>
      expect(api.fetchStudentData).toHaveBeenCalledWith({ department: '컴퓨터공학과', status: '재학' })
    );
  });

  it('handles API error gracefully', async () => {
    // Arrange
    const errorMessage = 'Network error';
    api.fetchStudentData.mockRejectedValue(new Error(errorMessage));

    // Act
    const { result } = renderHook(() => useStudentDashboardData());

    // Assert
    await waitFor(() => expect(result.current.error).toBe(errorMessage));
    expect(result.current.data).toBeNull();
    expect(result.current.loading).toBe(false);
  });

  it('resets filters to default values', async () => {
    // Arrange
    api.fetchStudentData.mockResolvedValue({ total_students: 0, by_department: [] });
    const { result } = renderHook(() => useStudentDashboardData());
    await waitFor(() => expect(result.current.loading).toBe(false));

    act(() => {
      result.current.updateFilter('department', '전자공학과');
    });

    // Act
    act(() => {
      result.current.resetFilters();
    });

    // Assert
    await waitFor(() =>
      expect(api.fetchStudentData).toHaveBeenCalledWith({ department: 'all', status: '재학' })
    );
  });

  // Edge Cases
  it('debounces rapid filter changes (300ms)', async () => {
    // Arrange
    jest.useFakeTimers();
    api.fetchStudentData.mockResolvedValue({ total_students: 0, by_department: [] });
    const { result } = renderHook(() => useStudentDashboardData());

    // Act (연속 3번 필터 변경)
    act(() => {
      result.current.updateFilter('department', '컴퓨터공학과');
      result.current.updateFilter('department', '전자공학과');
      result.current.updateFilter('department', '기계공학과');
    });

    // Assert (300ms 내에는 API 호출 안 됨)
    expect(api.fetchStudentData).toHaveBeenCalledTimes(1); // mount 시 1번만

    // Act (300ms 경과)
    act(() => {
      jest.advanceTimersByTime(300);
    });

    // Assert (마지막 필터 값으로만 API 호출)
    await waitFor(() =>
      expect(api.fetchStudentData).toHaveBeenCalledWith({ department: '기계공학과', status: '재학' })
    );
    expect(api.fetchStudentData).toHaveBeenCalledTimes(2); // mount + debounced call

    jest.useRealTimers();
  });
});
```

**Implementation Order (TDD Cycle)**:
1. **Red**: `loads data on mount with default filters` 작성 → 실패
2. **Green**: useStudentDashboardData Hook 기본 구조 구현 (useState, useEffect) → 통과
3. **Red**: `updates data when filter changes` 작성 → 실패
4. **Green**: updateFilter 함수 구현 → 통과
5. **Red**: `handles API error gracefully` 작성 → 실패
6. **Green**: try-catch 에러 처리 추가 → 통과
7. **Red**: `debounces rapid filter changes` 작성 → 실패
8. **Green**: setTimeout 디바운싱 로직 추가 → 통과
9. **Refactor**: 상수 분리 (DEBOUNCE_DELAY), 코드 정리
10. **Commit**: "Add useStudentDashboardData hook with debouncing"

**Dependencies**: dataApiClient.js

---

### 3.5 Phase 5: Frontend Components (UI 렌더링)

#### Module: StudentBarChart

**Location**: `frontend/src/components/dashboard/StudentBarChart.jsx`

**Responsibility**:
- Recharts BarChart 렌더링
- 학사/석사/박사 스택 바 표시
- 커스텀 Tooltip 표시
- 로딩 상태 및 Empty State 처리

**Test Strategy**: Unit Test (React Testing Library)

**Test Scenarios (Red Phase)**:
```javascript
// tests/StudentBarChart.test.jsx

import { render, screen, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import StudentBarChart from './StudentBarChart';

describe('StudentBarChart', () => {
  const mockData = [
    { name: '컴퓨터공학과', 학사: 120, 석사: 35, 박사: 12 },
    { name: '전자공학과', 학사: 98, 석사: 28, 박사: 9 },
  ];

  it('renders chart with provided data', () => {
    // Act
    render(<StudentBarChart data={mockData} loading={false} />);

    // Assert
    expect(screen.getByText('컴퓨터공학과')).toBeInTheDocument();
    expect(screen.getByText('전자공학과')).toBeInTheDocument();
  });

  it('shows loading skeleton when loading prop is true', () => {
    // Act
    render(<StudentBarChart data={null} loading={true} />);

    // Assert
    expect(screen.getByTestId('skeleton-loader')).toBeInTheDocument();
    expect(screen.queryByText('컴퓨터공학과')).not.toBeInTheDocument();
  });

  it('shows empty state when data is empty array', () => {
    // Act
    render(<StudentBarChart data={[]} loading={false} />);

    // Assert
    expect(screen.getByText('학생 데이터가 없습니다.')).toBeInTheDocument();
  });

  it('renders stacked bars for each program type', () => {
    // Arrange
    const { container } = render(<StudentBarChart data={mockData} loading={false} />);

    // Assert (Recharts SVG 요소 확인)
    const bars = container.querySelectorAll('.recharts-bar');
    expect(bars.length).toBe(3); // 학사, 석사, 박사
  });

  // Edge Cases
  it('handles null data gracefully', () => {
    // Act
    render(<StudentBarChart data={null} loading={false} />);

    // Assert
    expect(screen.getByText('학생 데이터가 없습니다.')).toBeInTheDocument();
  });

  it('renders chart with single department', () => {
    // Arrange
    const singleDeptData = [{ name: '컴퓨터공학과', 학사: 50, 석사: 10, 박사: 5 }];

    // Act
    render(<StudentBarChart data={singleDeptData} loading={false} />);

    // Assert
    expect(screen.getByText('컴퓨터공학과')).toBeInTheDocument();
  });
});

describe('CustomTooltip', () => {
  it('displays tooltip with all program types and total', () => {
    // Arrange
    const mockPayload = [
      { name: '학사', value: 120, color: '#3B82F6' },
      { name: '석사', value: 35, color: '#10B981' },
      { name: '박사', value: 12, color: '#F59E0B' },
    ];
    const mockLabel = '컴퓨터공학과';

    // Act
    const { container } = render(
      <CustomTooltip active={true} payload={mockPayload} label={mockLabel} />
    );

    // Assert
    expect(screen.getByText('컴퓨터공학과')).toBeInTheDocument();
    expect(screen.getByText('학사: 120명')).toBeInTheDocument();
    expect(screen.getByText('석사: 35명')).toBeInTheDocument();
    expect(screen.getByText('박사: 12명')).toBeInTheDocument();
    expect(screen.getByText('총: 167명')).toBeInTheDocument();
  });

  it('does not render when active is false', () => {
    // Act
    const { container } = render(
      <CustomTooltip active={false} payload={[]} label="" />
    );

    // Assert
    expect(container).toBeEmptyDOMElement();
  });
});
```

**Implementation Order (TDD Cycle)**:
1. **Red**: `renders chart with provided data` 작성 → 실패
2. **Green**: StudentBarChart 컴포넌트 기본 구조 + Recharts BarChart 추가 → 통과
3. **Red**: `shows loading skeleton when loading prop is true` 작성 → 실패
4. **Green**: loading 조건부 렌더링 추가 → 통과
5. **Red**: `shows empty state when data is empty array` 작성 → 실패
6. **Green**: EmptyState 컴포넌트 추가 → 통과
7. **Red**: CustomTooltip 테스트 작성 → 실패
8. **Green**: CustomTooltip 컴포넌트 구현 → 통과
9. **Refactor**: 컴포넌트 분리, 스타일 정리
10. **Commit**: "Add StudentBarChart component with Recharts"

**Dependencies**: Recharts, EmptyState, SkeletonLoader (공통 UI 컴포넌트)

---

#### Module: StudentMetricCard

**Location**: `frontend/src/components/dashboard/StudentMetricCard.jsx`

**Responsibility**:
- 총 재학생 수 표시
- 천 단위 쉼표 포맷 (1,234명)
- 필터 적용 시 학과명 표시

**Test Strategy**: Unit Test

**Test Scenarios (Red Phase)**:
```javascript
// tests/StudentMetricCard.test.jsx

import { render, screen } from '@testing-library/react';
import StudentMetricCard from './StudentMetricCard';

describe('StudentMetricCard', () => {
  it('displays total student count with comma separator', () => {
    // Act
    render(<StudentMetricCard total={1234} department="all" />);

    // Assert
    expect(screen.getByText('총 재학생')).toBeInTheDocument();
    expect(screen.getByText('1,234명')).toBeInTheDocument();
  });

  it('displays department name when filtered', () => {
    // Act
    render(<StudentMetricCard total={167} department="컴퓨터공학과" />);

    // Assert
    expect(screen.getByText('총 재학생 (컴퓨터공학과)')).toBeInTheDocument();
    expect(screen.getByText('167명')).toBeInTheDocument();
  });

  it('handles zero students', () => {
    // Act
    render(<StudentMetricCard total={0} department="all" />);

    // Assert
    expect(screen.getByText('0명')).toBeInTheDocument();
  });

  // Edge Cases
  it('formats large numbers correctly (10,000+)', () => {
    // Act
    render(<StudentMetricCard total={12345} department="all" />);

    // Assert
    expect(screen.getByText('12,345명')).toBeInTheDocument();
  });
});
```

**Implementation Order (TDD Cycle)**:
1. **Red**: `displays total student count with comma separator` 작성 → 실패
2. **Green**: StudentMetricCard 컴포넌트 생성, toLocaleString() 사용 → 통과
3. **Red**: `displays department name when filtered` 작성 → 실패
4. **Green**: 조건부 텍스트 렌더링 추가 → 통과
5. **Refactor**: 포맷 함수 분리 (formatNumber 유틸리티)
6. **Commit**: "Add StudentMetricCard component"

**Dependencies**: None (순수 React 컴포넌트)

---

#### Module: StudentDashboardFilters

**Location**: `frontend/src/components/dashboard/StudentDashboardFilters.jsx`

**Responsibility**:
- 학과 필터 드롭다운
- 학적상태 필터 라디오 버튼
- 필터 초기화 버튼

**Test Strategy**: Unit Test

**Test Scenarios (Red Phase)**:
```javascript
// tests/StudentDashboardFilters.test.jsx

import { render, screen, fireEvent } from '@testing-library/react';
import StudentDashboardFilters from './StudentDashboardFilters';

describe('StudentDashboardFilters', () => {
  const mockOnFilterChange = jest.fn();
  const mockOnReset = jest.fn();

  beforeEach(() => {
    jest.clearAllMocks();
  });

  it('renders department dropdown and status radio buttons', () => {
    // Arrange
    const departments = ['컴퓨터공학과', '전자공학과'];

    // Act
    render(
      <StudentDashboardFilters
        departments={departments}
        selectedDepartment="all"
        selectedStatus="재학"
        onFilterChange={mockOnFilterChange}
        onReset={mockOnReset}
      />
    );

    // Assert
    expect(screen.getByLabelText('학과')).toBeInTheDocument();
    expect(screen.getByLabelText('재학')).toBeInTheDocument();
    expect(screen.getByLabelText('휴학')).toBeInTheDocument();
    expect(screen.getByLabelText('졸업')).toBeInTheDocument();
    expect(screen.getByText('전체 보기')).toBeInTheDocument();
  });

  it('calls onFilterChange when department is selected', () => {
    // Arrange
    const departments = ['컴퓨터공학과'];
    render(
      <StudentDashboardFilters
        departments={departments}
        selectedDepartment="all"
        selectedStatus="재학"
        onFilterChange={mockOnFilterChange}
        onReset={mockOnReset}
      />
    );

    // Act
    const dropdown = screen.getByLabelText('학과');
    fireEvent.change(dropdown, { target: { value: '컴퓨터공학과' } });

    // Assert
    expect(mockOnFilterChange).toHaveBeenCalledWith('department', '컴퓨터공학과');
  });

  it('calls onFilterChange when status is changed', () => {
    // Arrange
    render(
      <StudentDashboardFilters
        departments={[]}
        selectedDepartment="all"
        selectedStatus="재학"
        onFilterChange={mockOnFilterChange}
        onReset={mockOnReset}
      />
    );

    // Act
    const radioButton = screen.getByLabelText('휴학');
    fireEvent.click(radioButton);

    // Assert
    expect(mockOnFilterChange).toHaveBeenCalledWith('status', '휴학');
  });

  it('calls onReset when reset button is clicked', () => {
    // Arrange
    render(
      <StudentDashboardFilters
        departments={[]}
        selectedDepartment="컴퓨터공학과"
        selectedStatus="재학"
        onFilterChange={mockOnFilterChange}
        onReset={mockOnReset}
      />
    );

    // Act
    const resetButton = screen.getByText('전체 보기');
    fireEvent.click(resetButton);

    // Assert
    expect(mockOnReset).toHaveBeenCalled();
  });

  // Edge Cases
  it('renders empty dropdown when no departments provided', () => {
    // Act
    render(
      <StudentDashboardFilters
        departments={[]}
        selectedDepartment="all"
        selectedStatus="재학"
        onFilterChange={mockOnFilterChange}
        onReset={mockOnReset}
      />
    );

    // Assert
    const dropdown = screen.getByLabelText('학과');
    expect(dropdown.options.length).toBe(1); // "전체 학과" 옵션만
  });
});
```

**Implementation Order (TDD Cycle)**:
1. **Red**: `renders department dropdown and status radio buttons` 작성 → 실패
2. **Green**: 기본 필터 UI 구현 → 통과
3. **Red**: `calls onFilterChange when department is selected` 작성 → 실패
4. **Green**: onChange 핸들러 추가 → 통과
5. **Red**: 나머지 테스트 작성 → 실패
6. **Green**: 나머지 핸들러 구현 → 통과
7. **Refactor**: 컴포넌트 분리, 스타일 정리
8. **Commit**: "Add StudentDashboardFilters component"

**Dependencies**: None

---

### 3.5.4 Phase 5.4: 에러 처리 UI 컴포넌트

#### Module: ErrorBoundary

**Location**: `frontend/src/components/ui/ErrorBoundary.jsx`

**Responsibility:**
- React 렌더링 에러 캐치
- 사용자 친화적 폴백 UI 표시
- 에러 로그 전송 (POST-MVP: Sentry 연동)

**Test Scenarios:**
```javascript
describe('ErrorBoundary', () => {
  it('catches rendering errors and shows fallback UI', () => {
    const ThrowError = () => { throw new Error('Test error'); };

    render(
      <ErrorBoundary>
        <ThrowError />
      </ErrorBoundary>
    );

    expect(screen.getByText('문제가 발생했습니다')).toBeInTheDocument();
    expect(screen.getByText('새로고침')).toBeInTheDocument();
  });
});
```

---

#### Module: ErrorCard

**Location**: `frontend/src/components/ui/ErrorCard.jsx`

**Responsibility:**
- 차트 로딩 실패 시 에러 카드 표시
- 재시도 버튼 제공
- 에러 타입별 아이콘 및 메시지

**Props:**
- `errorType`: 'network' | 'validation' | 'server'
- `message`: 사용자에게 표시할 메시지
- `onRetry`: 재시도 콜백 함수

**Test Scenarios:**
```javascript
describe('ErrorCard', () => {
  it('displays error message with retry button', () => {
    const mockRetry = jest.fn();

    render(
      <ErrorCard
        errorType="network"
        message="데이터를 불러올 수 없습니다"
        onRetry={mockRetry}
      />
    );

    expect(screen.getByText('데이터를 불러올 수 없습니다')).toBeInTheDocument();

    const retryButton = screen.getByText('다시 시도');
    fireEvent.click(retryButton);

    expect(mockRetry).toHaveBeenCalled();
  });
});
```

---

#### Module: ErrorToast

**Location**: `frontend/src/components/ui/ErrorToast.jsx`

**Responsibility:**
- 일시적 에러 메시지 토스트 표시
- 3초 후 자동 사라짐
- 우측 상단에 슬라이드 인 애니메이션

**Usage Example:**
```javascript
// hooks/useStudentDashboardData.js
import { showErrorToast } from '../components/ui/ErrorToast';

const fetchData = async () => {
  try {
    // ...
  } catch (error) {
    showErrorToast('네트워크 오류가 발생했습니다');
  }
};
```

---

#### StudentDashboardPage 수정 (에러 처리 추가)

```jsx
// pages/StudentDashboardPage.jsx

import ErrorBoundary from '../components/ui/ErrorBoundary';
import ErrorCard from '../components/ui/ErrorCard';

export default function StudentDashboardPage() {
  const { data, loading, error, refetch } = useStudentDashboardData();

  return (
    <ErrorBoundary>
      <div className="dashboard-page">
        {error ? (
          <ErrorCard
            errorType="network"
            message="학생 데이터를 불러오는 중 오류가 발생했습니다"
            onRetry={refetch}
            data-testid="error-message"
          />
        ) : (
          // 차트 컴포넌트들...
        )}
      </div>
    </ErrorBoundary>
  );
}
```

---

#### Module: StudentDashboardPage

**Location**: `frontend/src/pages/StudentDashboardPage.jsx`

**Responsibility**:
- 모든 컴포넌트 통합
- useStudentDashboardData Hook 사용
- 레이아웃 구성

**Test Strategy**: E2E Test (Cypress)

**Test Scenarios (Red Phase)**:
```javascript
// cypress/e2e/student_dashboard.cy.js

describe('Student Dashboard E2E', () => {
  beforeEach(() => {
    cy.visit('/dashboard');
  });

  it('displays student chart and metric card on initial load', () => {
    // Assert
    cy.get('[data-testid="student-bar-chart"]').should('be.visible');
    cy.get('[data-testid="student-metric-card"]').should('contain', '명');
    cy.get('[data-testid="student-metric-card"]').should('contain', '총 재학생');
  });

  it('filters chart by department', () => {
    // Act
    cy.get('[data-testid="department-filter"]').select('컴퓨터공학과');
    cy.wait(500); // 디바운싱 대기

    // Assert
    cy.get('[data-testid="student-bar-chart"]').should('contain', '컴퓨터공학과');
    cy.get('[data-testid="student-metric-card"]').should('contain', '컴퓨터공학과');
  });

  it('filters chart by enrollment status', () => {
    // Act
    cy.get('[data-testid="status-filter-all"]').click();
    cy.wait(500);

    // Assert
    cy.get('[data-testid="student-metric-card"]').should('not.contain', '재학생');
    cy.get('[data-testid="student-metric-card"]').should('contain', '학생'); // 전체 학생
  });

  it('shows tooltip on chart hover', () => {
    // Act
    cy.get('[data-testid="student-bar-chart"] .recharts-bar-rectangle')
      .first()
      .trigger('mouseover');

    // Assert
    cy.get('.custom-tooltip').should('be.visible');
    cy.get('.custom-tooltip').should('contain', '총:');
  });

  it('resets filters to default', () => {
    // Arrange (필터 변경)
    cy.get('[data-testid="department-filter"]').select('전자공학과');
    cy.wait(500);

    // Act
    cy.get('[data-testid="reset-filters-btn"]').click();
    cy.wait(500);

    // Assert
    cy.get('[data-testid="department-filter"]').should('have.value', 'all');
    cy.get('[data-testid="status-filter-재학"]').should('be.checked');
  });

  // Edge Cases
  it('displays empty state when no students exist', () => {
    // Arrange (DB 비우기 - API Mock 필요)
    cy.intercept('GET', '/api/dashboard/students/*', {
      statusCode: 200,
      body: { total_students: 0, by_department: [], updated_at: '2025-11-02T14:35:22Z' }
    });

    // Act
    cy.reload();

    // Assert
    cy.get('[data-testid="student-bar-chart"]').should('contain', '학생 데이터가 없습니다');
  });

  it('displays error message on API failure', () => {
    // Arrange
    cy.intercept('GET', '/api/dashboard/students/*', { statusCode: 500 });

    // Act
    cy.reload();

    // Assert
    cy.get('[data-testid="error-message"]').should('be.visible');
    cy.get('[data-testid="error-message"]').should('contain', '데이터를 불러오는 중 오류가 발생했습니다');
  });
});
```

**Implementation Order (TDD Cycle)**:
1. **Red**: E2E 테스트 작성 → 실패
2. **Green**: StudentDashboardPage 컴포넌트 생성, 모든 하위 컴포넌트 통합 → 통과
3. **Refactor**: 레이아웃 CSS 정리, 반응형 디자인 추가
4. **Commit**: "Add StudentDashboardPage with full integration"

**Dependencies**: 모든 하위 컴포넌트, useStudentDashboardData Hook

---

### 3.6 Phase 6: QA Sheet (Presentation Layer 수동 테스트)

#### Manual Testing Checklist

**테스트 환경**: Chrome 최신 버전, Firefox 최신 버전, Edge 최신 버전

**시각적 검증 항목**:

| 항목 | 검증 내용 | 통과 기준 | 담당자 | 상태 |
|------|----------|----------|--------|------|
| 차트 렌더링 | Recharts BarChart가 정상 표시되는가? | 모든 학과 막대가 보이고 스택 색상 구분 명확 | QA | [ ] |
| 색상 구분 | 학사(파랑), 석사(초록), 박사(주황) 색상 정확한가? | 범례와 막대 색상 일치 | QA | [ ] |
| Tooltip 표시 | 호버 시 Tooltip이 정확히 표시되는가? | 학과명, 각 과정별 인원, 총합 표시 | QA | [ ] |
| 가로 스크롤 | 학과가 10개 이상일 때 스크롤 작동하는가? | 스크롤 바 표시, 모든 학과 접근 가능 | QA | [ ] |
| Metric Card | 총 재학생 수가 천 단위 쉼표로 표시되는가? | "1,234명" 포맷 | QA | [ ] |
| 필터 UI | 드롭다운과 라디오 버튼이 정상 작동하는가? | 클릭/변경 시 즉시 반영 | QA | [ ] |
| 로딩 상태 | 스켈레톤 UI가 300ms 이상 표시되는가? | 부드러운 로딩 애니메이션 | QA | [ ] |
| Empty State | 데이터 없을 때 안내 메시지 표시되는가? | "학생 데이터가 없습니다" 표시 | QA | [ ] |
| 에러 상태 | API 실패 시 에러 메시지 표시되는가? | 사용자 친화적 에러 메시지 | QA | [ ] |
| 반응형 디자인 | 모바일(768px 이하)에서 레이아웃 정상인가? | 스크롤 가능, 텍스트 겹침 없음 | QA | [ ] |

---

## 4. TDD Workflow Summary

### 4.1 전체 구현 순서 (Outside-In)

```
Phase 1: Infrastructure Layer (DB 기반)
  ├─ Red: Student Model 테스트 작성
  ├─ Green: Student Model 구현
  ├─ Red: StudentRepository 테스트 작성
  └─ Green: StudentRepository 구현

Phase 2: Service Layer (비즈니스 로직)
  ├─ Red: StudentDashboardService 테스트 작성 (Mock Repository)
  └─ Green: StudentDashboardService 구현

Phase 3: Presentation Layer (API)
  ├─ Red: StudentDashboardSerializer 테스트 작성
  ├─ Green: StudentDashboardSerializer 구현
  ├─ Red: StudentDashboardView Integration 테스트 작성
  └─ Green: StudentDashboardView 구현

Phase 4: Frontend Hook (데이터 계층)
  ├─ Red: useStudentDashboardData 테스트 작성
  └─ Green: useStudentDashboardData 구현

Phase 5: Frontend Components (UI 계층)
  ├─ Red: StudentBarChart 테스트 작성
  ├─ Green: StudentBarChart 구현
  ├─ Red: StudentMetricCard 테스트 작성
  ├─ Green: StudentMetricCard 구현
  ├─ Red: StudentDashboardFilters 테스트 작성
  └─ Green: StudentDashboardFilters 구현

Phase 6: Integration (전체 통합)
  ├─ Red: StudentDashboardPage 컴포넌트 생성
  ├─ Red: E2E 테스트 작성 (Cypress)
  ├─ Green: 모든 컴포넌트 통합
  └─ Refactor: 레이아웃 최적화, 성능 개선

Phase 7: QA (수동 테스트)
  ├─ QA Sheet 체크리스트 실행
  └─ 발견된 버그 수정 (TDD 사이클 적용)
```

### 4.2 Commit 포인트 제안

- `feat: Add Student model with required fields` (Phase 1-1)
- `feat: Add StudentRepository with filtering logic` (Phase 1-2)
- `feat: Add StudentDashboardService with validation and aggregation` (Phase 2)
- `feat: Add StudentDashboardSerializer` (Phase 3-1)
- `feat: Add StudentDashboardView API endpoint` (Phase 3-2)
- `feat: Add useStudentDashboardData hook with debouncing` (Phase 4)
- `feat: Add StudentBarChart component with Recharts` (Phase 5-1)
- `feat: Add StudentMetricCard component` (Phase 5-2)
- `feat: Add StudentDashboardFilters component` (Phase 5-3)
- `feat: Add StudentDashboardPage with full integration` (Phase 6)
- `test: Add E2E tests for student dashboard` (Phase 6)
- `docs: Add QA checklist for student dashboard` (Phase 7)

### 4.3 완료 기준 (Definition of Done)

**Phase별 완료 조건:**

- [ ] 모든 테스트 통과 (Unit + Integration + E2E)
- [ ] 코드 커버리지 70% 이상 (Unit Test 기준)
- [ ] **모든 보안 요구사항 구현**:
  - [ ] CSRF 방어: Django 기본 CSRF 미들웨어 활성화
  - [ ] XSS 방어: `validationUtils.sanitize_string()` 구현 및 적용
  - [ ] SQL Injection 방어: validationUtils + 학과 화이트리스트 검증
  - [ ] 입력 검증: 학적상태/학과 Enum 화이트리스트 검증
  - [ ] 보안 테스트 통과: `test_xss_prevention`, `test_sql_injection_prevention`
- [ ] **모든 에러 코드 구현** (400 validation_error, 400 invalid_parameter, 404 not_found, 500 server_error)
- [ ] **에러 UI 컴포넌트 구현**:
  - [ ] ErrorBoundary (React 렌더링 에러 캐치)
  - [ ] ErrorCard (차트 로딩 실패 시 에러 카드 + 재시도 버튼)
  - [ ] ErrorToast (일시적 에러 메시지)
  - [ ] StudentDashboardPage에 에러 처리 통합 (`data-testid="error-message"`)
- [ ] **Helper/Utility 함수 구현**:
  - [ ] formatUtils.js (formatNumber, formatDate, formatPercentage)
  - [ ] validationUtils.py (sanitize_string, validate_department_name, validate_enum_value)
- [ ] **성능 요구사항 충족**:
  - [ ] API 응답 시간 < 500ms (평균, 10회 측정)
  - [ ] 최대 응답 시간 < 1000ms
  - [ ] 차트 초기 렌더링 < 1초
- [ ] **데이터베이스 스키마 검증**:
  - [ ] `test_student_model_matches_database_schema` 통과
  - [ ] database.md 명세와 Student 모델 완전 일치
- [ ] QA Sheet 100% 통과
- [ ] 브라우저 호환성 검증 (Chrome, Firefox, Edge 최신 2개 버전)

**최종 완료 조건:**

- [ ] 모든 Phase 완료
- [ ] Spec 문서의 모든 사용자 스토리 구현
- [ ] **모든 P0 보안 요구사항 충족** (CLAUDE.md "Frequently Omitted" 항목)
- [ ] **모든 P1 품질 요구사항 충족** (Helper Functions, Performance Tests, Schema Validation)
- [ ] 모든 Edge Case 처리
- [ ] 모든 에러 시나리오 구현 (userflow.md Section 7)
- [ ] CTO 리뷰 승인

---

## 5. 핵심 원칙 재확인

### 5.1 TDD 사이클 준수

- **Red Phase**: 실패하는 테스트를 먼저 작성 (한 번에 하나씩)
- **Green Phase**: 테스트를 통과시키는 최소 코드 작성 (YAGNI)
- **Refactor Phase**: 중복 제거, 가독성 개선 (테스트는 항상 Green 유지)

### 5.2 MVP 간결성 유지

- 오버엔지니어링 회피: POST-MVP 기능은 구현하지 않음 (Redis 캐싱, Rate Limiting 등)
- 필수 기능만 구현: 학과/학적상태 필터링, Stacked Bar Chart, Metric Card
- 간단한 데이터 구조: by_grade 제거, API 응답 최소화

### 5.3 Test Pyramid 비율

- **Unit Tests (70%)**: Service, Repository, Hook, Component 단위 테스트
- **Integration Tests (10%)**: API 엔드포인트 + DB 조회 플로우
- **E2E Tests (10%)**: 사용자 시나리오 전체 검증
- **Manual QA (10%)**: 시각적 검증, 브라우저 호환성

### 5.4 FIRST 원칙

- **Fast**: 모든 Unit Test는 1초 이내 완료
- **Independent**: 테스트 간 의존성 없음 (각 테스트 독립 실행 가능)
- **Repeatable**: 동일 입력 → 동일 결과 (Mock 사용)
- **Self-validating**: Assert로 자동 검증 (수동 확인 불필요)
- **Timely**: 코드 작성 직전에 테스트 작성 (Red → Green)

---

## 6. 위험 요소 및 대응 방안

| 위험 요소 | 발생 확률 | 영향도 | 대응 방안 |
|----------|----------|--------|----------|
| Recharts 렌더링 성능 저하 (학과 15개 이상) | 중 | 중 | 가로 스크롤 구현, 차트 높이 조정, 또는 Tremor.so 대안 검토 |
| Django ORM 집계 쿼리 느림 (학생 10,000명 이상) | 중 | 고 | 인덱스 추가 (department, enrollment_status), 쿼리 최적화 |
| API 디바운싱으로 인한 UX 지연 | 저 | 저 | 디바운싱 시간 300ms → 200ms 단축 검토 |
| 학과명 긴 경우 X축 레이블 겹침 | 중 | 중 | 레이블 회전 (45도), Tooltip으로 전체 이름 표시 |
| 학생 데이터 없을 때 빈 화면 | 저 | 저 | Empty State 컴포넌트 구현 (명확한 안내 메시지) |
| 브라우저 호환성 (IE11 등 구형 브라우저) | 저 | 중 | 지원 브라우저 명시 (Chrome/Firefox/Edge 최신 2개 버전만), 미지원 브라우저 안내 페이지 |
| E2E 테스트 불안정 (Flaky Test) | 중 | 중 | cy.wait() 적절히 사용, 네트워크 요청 Mock 처리 |

---

## 7. 참고 자료

- **Spec 문서**: `/docs/003-student-dashboard/spec.md`
- **데이터베이스 스키마**: `/docs/database.md`
- **코드베이스 구조**: `/docs/code_structure.md`
- **TDD 가이드**: `/prompt/tdd.md`
- **샘플 데이터**: `/docs/db/student_roster.csv`

---

**문서 끝**
</file>

<file path="003-student-dashboard/spec.md">
# 학과별 학생 현황 대시보드 기능 상세 유스케이스

**프로젝트:** 대학교 사내 데이터 시각화 대시보드 MVP
**기능 ID:** UC-003
**기능명:** 학과별 학생 현황 시각화 (P0-MVP)
**작성일:** 2025-11-02
**최종 수정일:** 2025-11-02
**수정자:** Claude Code
**버전:** 2.1 (오버엔지니어링 요소 제거, MVP 집중)
**참조:** userflow.md 섹션 3.2.2, prd.md 섹션 3.1

**변경 이력 (v2.1):**
- 미사용 DB 칼럼 저장 제거 (YAGNI 원칙 적용)
- API 응답 간소화 (by_grade, filters_applied 제거)
- POST-MVP 기능 제거 (Redis 캐싱, Rate Limiting, 경고 배지)
- Integration Test 비율 축소 (20% → 10%)
- 브라우저 폴백 전략 단순화

---

## 1. 기능 개요

학과별/과정별/학년별 학생 분포를 Stacked Bar Chart로 시각화하여 대학 내부 직원이 학생 현황을 한눈에 파악할 수 있도록 지원하는 기능입니다.

**핵심 가치:**
- 학과별 학생 수 비교를 통한 자원 배분 의사결정 지원
- 과정별(학사/석사/박사) 학생 구성 비율 파악
- 학적상태별 필터링을 통한 재학생 현황 모니터링

**범위:**
- Recharts 라이브러리 기반 Stacked Bar Chart 구현
- 학과별/학적상태별 필터링 지원
- 총 재학생 수 Metric Card 표시
- 호버 시 상세 정보 Tooltip 제공
- 학과 수가 많을 경우 가로 스크롤 지원

---

## 2. 사용자 스토리 (GIVEN-WHEN-THEN)

### 스토리 1: 학과별 학생 현황 조회
```gherkin
GIVEN 관리자가 student_roster.csv 파일을 업로드하여 학생 데이터가 DB에 저장된 상태
WHEN 내부 직원이 메인 대시보드에 접속하여 학생 현황 차트를 조회할 때
THEN 학과별로 과정별(학사/석사/박사) 학생 수가 누적 막대 그래프로 표시되어야 한다
AND 총 재학생 수가 Metric Card로 상단에 표시되어야 한다
```

### 스토리 2: 학과 필터링
```gherkin
GIVEN 학생 현황 차트가 로드된 상태
WHEN 사용자가 학과 필터 드롭다운에서 "컴퓨터공학과"를 선택할 때
THEN 해당 학과의 학생 분포만 차트에 표시되어야 한다
AND 총 재학생 수 Metric Card가 해당 학과 학생 수로 업데이트되어야 한다
```

### 스토리 3: 학적상태 필터링
```gherkin
GIVEN 학생 현황 차트가 로드된 상태
WHEN 사용자가 학적상태 필터에서 "재학"만 선택할 때
THEN 재학생만 집계된 데이터가 차트에 표시되어야 한다
AND 휴학생 및 졸업생은 차트에서 제외되어야 한다
```

### 스토리 4: 차트 인터랙션
```gherkin
GIVEN 학생 현황 차트가 표시된 상태
WHEN 사용자가 특정 학과의 막대 그래프에 마우스를 올릴 때
THEN Tooltip이 표시되어야 하며
AND "학과명: 컴퓨터공학과, 학사: 120명, 석사: 35명, 박사: 12명, 총: 167명" 형식의 정보가 표시되어야 한다
```

---

## 2.5 CSV 칼럼 처리 방침

### 필수 칼럼 (MVP에서 사용)

| CSV 칼럼 | Django Model Field | 용도 |
|---------|-------------------|------|
| 학번 | student_id (PK) | 고유 식별자 |
| 학과 | department | 집계 및 필터링 |
| 학년 | grade | POST-MVP 확장용 (현재 API 응답에만 포함) |
| 과정구분 | program_type | 스택 바 차트 구분 (학사/석사/박사) |
| 학적상태 | enrollment_status | 필터링 (재학/휴학/졸업) |

### 선택 칼럼 처리 방침 (MVP)

**YAGNI 원칙 적용:**
- CSV에 추가 칼럼이 있어도 **무시하고 파싱 성공**
- 필수 칼럼(학번, 학과, 학년, 과정구분, 학적상태)만 DB에 저장
- POST-MVP 확장 시 Django Migration으로 칼럼 추가

### 데이터 파싱 규칙 (excel_parser.py)

- 필수 칼럼 누락 시: ValidationError 발생, 파일 업로드 실패
- 선택 칼럼은 파싱 과정에서 무시 (DB 저장 안 함)

---

## 3. 상세 유스케이스

### Primary Actor
- 내부 직원 (Internal Staff / Viewer)

### Precondition
- 관리자가 student_roster.csv 파일을 업로드하여 students 테이블에 데이터가 존재함
- 사용자가 메인 대시보드에 접속함
- 브라우저가 Recharts 렌더링을 지원함 (Chrome, Firefox, Edge 최신 버전)

### Trigger
- 사용자가 메인 대시보드 페이지(/) 또는 대시보드 URL(/dashboard)에 접속

### Main Scenario

#### 시나리오 1: 초기 데이터 로드 및 차트 렌더링

**단계 1: 대시보드 접속 및 API 요청**
1. 사용자가 브라우저에서 메인 대시보드 URL 접속
2. React 앱이 로드되고 StudentDashboard 컴포넌트 렌더링 시작
3. useDashboardData Hook이 초기 필터 상태 설정 (department: "all", status: "재학")
4. 스켈레톤 UI 표시 (로딩 인디케이터)
5. 프런트엔드가 `GET /api/dashboard/students/?department=all&status=재학` API 호출

**단계 2: 백엔드 데이터 집계**
6. DRF View가 요청 수신 및 쿼리 파라미터 검증
7. Django ORM을 통해 students 테이블 조회:
   ```python
   queryset = Student.objects.filter(enrollment_status='재학')
   # GROUP BY department, program_type
   aggregated_data = queryset.values('department', 'program_type').annotate(count=Count('id'))
   ```
8. 집계 결과를 JSON 형식으로 직렬화:
   ```json
   {
     "total_students": 1234,
     "by_department": [
       {
         "department": "컴퓨터공학과",
         "학사": 120,
         "석사": 35,
         "박사": 12,
         "total": 167
       },
       {
         "department": "전자공학과",
         "학사": 98,
         "석사": 28,
         "박사": 9,
         "total": 135
       }
     ]
   }
   ```
9. HTTP 200 OK 응답 반환

**단계 3: 프런트엔드 데이터 처리 및 차트 렌더링**
10. useDashboardData Hook이 API 응답 수신
11. 데이터를 Recharts 형식으로 변환:
    ```javascript
    const chartData = response.by_department.map(dept => ({
      name: dept.department,
      학사: dept.학사,
      석사: dept.석사,
      박사: dept.박사
    }));
    ```
12. Stacked Bar Chart 컴포넌트에 데이터 바인딩
13. 차트 렌더링 완료:
    - X축: 학과명 (가로 배치)
    - Y축: 학생 수 (0부터 자동 스케일링)
    - 스택 바: 학사(파랑), 석사(초록), 박사(주황) 색상 구분
    - 범례: 상단 또는 우측에 과정 구분 표시
14. 총 재학생 수 Metric Card 렌더링: "총 재학생: 1,234명"

**단계 4: 사용자 피드백**
- 차트가 화면에 표시됨
- 로딩 인디케이터 제거
- 최종 업데이트 시간 표시: "마지막 업데이트: 2025-11-02 14:35"

#### 시나리오 2: 학과 필터링

**단계 1: 필터 선택**
1. 사용자가 학과 필터 드롭다운 클릭
2. 학과 목록 표시: "전체 학과", "컴퓨터공학과", "전자공학과", ...
3. 사용자가 "컴퓨터공학과" 선택

**단계 2: 필터 적용 및 API 재요청**
4. React State 업데이트 (selectedDepartment: "컴퓨터공학과")
5. 디바운싱 300ms 대기
6. `GET /api/dashboard/students/?department=컴퓨터공학과&status=재학` API 호출
7. 짧은 로딩 스피너 표시 (1초 미만)

**단계 3: 필터링된 데이터 조회**
8. 백엔드에서 WHERE 절 추가하여 조회:
   ```python
   queryset = Student.objects.filter(
       department='컴퓨터공학과',
       enrollment_status='재학'
   )
   ```
9. 해당 학과 데이터만 집계하여 응답

**단계 4: 차트 업데이트**
10. 프런트엔드에서 새 데이터로 차트 리렌더링
11. Recharts 애니메이션 효과 (부드러운 전환)
12. 총 재학생 수 업데이트: "총 재학생: 167명 (컴퓨터공학과)"
13. 필터 드롭다운에 선택된 값 표시
14. "전체 보기" 버튼 활성화

#### 시나리오 3: 학적상태 필터링

**단계 1: 학적상태 필터 선택**
1. 사용자가 학적상태 라디오 버튼 영역 확인
2. 기본값 "재학" 선택됨
3. 사용자가 "전체" 라디오 버튼 클릭

**단계 2: 필터 적용**
4. React State 업데이트 (enrollmentStatus: "all")
5. `GET /api/dashboard/students/?department=all&status=all` API 호출

**단계 3: 전체 학생 데이터 조회**
6. 백엔드에서 enrollment_status 필터 제거:
   ```python
   queryset = Student.objects.all()
   # 재학, 휴학, 졸업 모두 포함
   ```
7. 전체 학생 집계 데이터 반환

**단계 4: 차트 업데이트**
8. 차트가 재학생+휴학생+졸업생 합산 데이터로 업데이트됨
9. 총 학생 수 증가: "총 학생: 2,156명 (재학+휴학+졸업)"

#### 시나리오 4: 차트 인터랙션 (Tooltip)

**단계 1: 마우스 호버**
1. 사용자가 "컴퓨터공학과" 막대 그래프에 마우스 커서 올림
2. Recharts Tooltip 컴포넌트 활성화

**단계 2: Tooltip 표시**
3. 커서 근처에 Tooltip 팝업 표시:
   ```
   컴퓨터공학과
   ─────────────
   학사: 120명
   석사: 35명
   박사: 12명
   ─────────────
   총: 167명
   ```
4. Tooltip은 마우스 움직임에 따라 위치 자동 조정

**단계 3: 호버 종료**
5. 사용자가 마우스를 차트 밖으로 이동
6. Tooltip 자동 숨김

---

## 4. API 명세

### 엔드포인트

```
GET /api/dashboard/students/
```

### 요청 파라미터

| 파라미터 | 타입 | 필수 | 기본값 | 설명 |
|---------|------|------|--------|------|
| department | string | N | "all" | 학과 필터 ("all" 또는 학과명) |
| status | string | N | "재학" | 학적상태 필터 ("all", "재학", "휴학", "졸업") |

### 응답 형식 (성공 - HTTP 200)

```json
{
  "total_students": 1234,
  "by_department": [
    {
      "department": "컴퓨터공학과",
      "학사": 120,
      "석사": 35,
      "박사": 12,
      "total": 167
    },
    {
      "department": "전자공학과",
      "학사": 98,
      "석사": 28,
      "박사": 9,
      "total": 135
    }
  ],
  "updated_at": "2025-11-02T14:35:22Z"
}
```

### 에러 응답

**400 Bad Request - 잘못된 파라미터**
```json
{
  "error": "invalid_parameter",
  "message": "학적상태 값이 유효하지 않습니다. ('재학', '휴학', '졸업', 'all' 중 선택)",
  "field": "status",
  "received_value": "invalid_status"
}
```

**404 Not Found - 데이터 없음**
```json
{
  "error": "no_data",
  "message": "학생 데이터가 존재하지 않습니다. 관리자가 student_roster.csv 파일을 업로드해야 합니다."
}
```

**500 Internal Server Error - 서버 오류**
```json
{
  "error": "server_error",
  "message": "데이터를 조회하는 중 오류가 발생했습니다.",
  "details": "Database connection timeout"
}
```

---

## 5. 백엔드 아키텍처 구현 (Layered Architecture)

### 5.1 레이어별 책임 (CLAUDE.md 준수)

#### Presentation Layer: `api/views.py`

```python
# api/views.py
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status
from .serializers import StudentDashboardSerializer
from ..services.student_dashboard_service import StudentDashboardService

class StudentDashboardView(APIView):
    """Thin Controller - 요청 검증 및 Service 위임만 수행"""

    def get(self, request):
        # 1. 요청 파라미터 검증
        department = request.query_params.get('department', 'all')
        enrollment_status = request.query_params.get('status', '재학')

        # 2. Service Layer 호출
        service = StudentDashboardService()
        try:
            data = service.get_student_dashboard_data(department, enrollment_status)
        except ValidationError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)

        # 3. 직렬화 및 응답
        serializer = StudentDashboardSerializer(data)
        return Response(serializer.data, status=status.HTTP_200_OK)
```

#### Service Layer: `services/student_dashboard_service.py`

```python
# services/student_dashboard_service.py
from django.db.models import Q, Count
from django.utils import timezone
from django.core.exceptions import ValidationError
from ..infrastructure.repositories import StudentRepository

class StudentDashboardService:
    """Business Logic - 집계 로직 및 데이터 변환"""

    ALLOWED_STATUSES = ['all', '재학', '휴학', '졸업']

    def __init__(self):
        self.student_repo = StudentRepository()

    def get_student_dashboard_data(self, department, status):
        """학생 대시보드 데이터 조회 및 집계"""
        # 1. 입력 검증
        self._validate_inputs(department, status)

        # 2. Repository를 통한 데이터 조회
        students = self.student_repo.get_students_by_filter(department, status)

        # 3. 집계 로직 (비즈니스 규칙 적용)
        by_department = self._aggregate_by_department(students)
        total_students = students.count()

        # 4. 응답 데이터 구조화
        return {
            'total_students': total_students,
            'by_department': by_department,
            'updated_at': timezone.now()
        }

    def _validate_inputs(self, department, status):
        """입력 파라미터 검증"""
        # 학적상태 화이트리스트 검증
        if status not in self.ALLOWED_STATUSES:
            raise ValidationError(f"유효하지 않은 학적상태: {status}")

        # 학과 존재 여부 검증
        if department != 'all':
            all_departments = self.student_repo.get_all_departments()
            if department not in all_departments:
                raise ValidationError(f"존재하지 않는 학과: {department}")

    def _aggregate_by_department(self, queryset):
        """학과별/과정별 집계 (DB 레벨에서 한 번에 피봇 집계)"""
        aggregated = queryset.values('department').annotate(
            학사=Count('id', filter=Q(program_type='학사')),
            석사=Count('id', filter=Q(program_type='석사')),
            박사=Count('id', filter=Q(program_type='박사')),
            total=Count('id')
        ).order_by('-total')  # 비즈니스 규칙 4: 학생 수 내림차순

        return list(aggregated)
```

#### Infrastructure Layer: `infrastructure/repositories.py`

```python
# infrastructure/repositories.py
from .models import Student
from django.db.models import Q

class StudentRepository:
    """Data Access Layer - DB 조회 전담"""

    def get_students_by_filter(self, department='all', status='all'):
        """필터 조건에 맞는 학생 QuerySet 반환"""
        queryset = Student.objects.all()

        # 학과 필터
        if department != 'all':
            queryset = queryset.filter(department=department)

        # 학적상태 필터
        if status != 'all':
            queryset = queryset.filter(enrollment_status=status)

        return queryset

    def get_all_departments(self):
        """전체 학과 목록 조회 (중복 제거)"""
        return Student.objects.values_list('department', flat=True).distinct()
```

### 5.2 Serializer (데이터 직렬화)

```python
# serializers.py
from rest_framework import serializers

class StudentDashboardSerializer(serializers.Serializer):
    total_students = serializers.IntegerField()
    by_department = serializers.ListField(
        child=serializers.DictField()
    )
    updated_at = serializers.DateTimeField()
```

### 5.3 SQL 쿼리 (참고용)

**학과별/과정별 집계 SQL:**
```sql
SELECT
    department,
    COUNT(CASE WHEN program_type = '학사' THEN 1 END) AS 학사,
    COUNT(CASE WHEN program_type = '석사' THEN 1 END) AS 석사,
    COUNT(CASE WHEN program_type = '박사' THEN 1 END) AS 박사,
    COUNT(*) AS total
FROM students
WHERE enrollment_status = '재학'
GROUP BY department
ORDER BY total DESC;
```

### 5.4 집계 성능 최적화

**인덱스 활용:**
- `students.department` 인덱스로 학과 필터링 성능 향상
- `students.enrollment_status` 인덱스로 학적상태 필터링 최적화

**쿼리 최적화:**
- `values()` + `annotate()`로 DB 레벨 집계 수행 (Python 레벨 루프 회피)
- `SELECT_RELATED` / `PREFETCH_RELATED` 불필요 (JOIN 없음)

---

## 6. UI 컴포넌트 구조

### 6.1 컴포넌트 계층 구조

```
StudentDashboard (Page)
├── StudentMetricCard (총 재학생 수 표시)
├── FilterPanel
│   ├── DepartmentFilter (드롭다운)
│   └── EnrollmentStatusFilter (라디오 버튼)
├── StudentBarChart (Recharts Wrapper)
│   ├── BarChart (Recharts)
│   ├── XAxis
│   ├── YAxis
│   ├── Tooltip (커스텀)
│   ├── Legend
│   └── Bar (학사/석사/박사 각각)
└── ErrorBoundary (렌더링 에러 처리)
```

### 6.2 주요 컴포넌트 상세

#### StudentBarChart.jsx

```jsx
import React from 'react';
import { BarChart, Bar, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer } from 'recharts';

const StudentBarChart = ({ data, loading }) => {
  if (loading) {
    return <SkeletonLoader />;
  }

  if (!data || data.length === 0) {
    return <EmptyState message="학생 데이터가 없습니다." />;
  }

  return (
    <ResponsiveContainer width="100%" height={400}>
      <BarChart
        data={data}
        margin={{ top: 20, right: 30, left: 20, bottom: 5 }}
      >
        <CartesianGrid strokeDasharray="3 3" />
        <XAxis dataKey="name" />
        <YAxis label={{ value: '학생 수', angle: -90, position: 'insideLeft' }} />
        <Tooltip content={<CustomTooltip />} />
        <Legend />
        <Bar dataKey="학사" stackId="a" fill="#3B82F6" />
        <Bar dataKey="석사" stackId="a" fill="#10B981" />
        <Bar dataKey="박사" stackId="a" fill="#F59E0B" />
      </BarChart>
    </ResponsiveContainer>
  );
};

const CustomTooltip = ({ active, payload, label }) => {
  if (!active || !payload) return null;

  const total = payload.reduce((sum, item) => sum + item.value, 0);

  return (
    <div className="custom-tooltip">
      <p className="label">{label}</p>
      <hr />
      {payload.map((item, index) => (
        <p key={index} style={{ color: item.color }}>
          {item.name}: {item.value}명
        </p>
      ))}
      <hr />
      <p className="total">총: {total}명</p>
    </div>
  );
};
```

#### useDashboardData.js (Hook)

```javascript
import { useState, useEffect } from 'react';
import { fetchStudentData } from '../api/dataApiClient';

export const useStudentDashboardData = () => {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [filters, setFilters] = useState({
    department: 'all',
    status: '재학'
  });

  useEffect(() => {
    const loadData = async () => {
      setLoading(true);
      try {
        const response = await fetchStudentData(filters);
        setData(response);
        setError(null);
      } catch (err) {
        setError(err.message);
      } finally {
        setLoading(false);
      }
    };

    // 디바운싱 300ms
    const timeoutId = setTimeout(loadData, 300);
    return () => clearTimeout(timeoutId);
  }, [filters]);

  const updateFilter = (key, value) => {
    setFilters(prev => ({ ...prev, [key]: value }));
  };

  const resetFilters = () => {
    setFilters({ department: 'all', status: '재학' });
  };

  return { data, loading, error, filters, updateFilter, resetFilters };
};
```

---

## 7. 테스트 요구사항 (TDD)

### 7.1 Unit Tests (70%)

#### 백엔드 테스트 (DRF + Django ORM)

**tests/test_student_dashboard_api.py**
```python
from django.test import TestCase
from rest_framework.test import APIClient
from data_ingestion.infrastructure.models import Student

class StudentDashboardAPITest(TestCase):
    def setUp(self):
        self.client = APIClient()
        # 테스트 데이터 생성
        Student.objects.create(
            student_id='2024001',
            department='컴퓨터공학과',
            grade=3,
            program_type='학사',
            enrollment_status='재학'
        )
        # ... 더 많은 테스트 데이터

    def test_get_all_students_returns_200(self):
        response = self.client.get('/api/dashboard/students/')
        self.assertEqual(response.status_code, 200)
        self.assertIn('total_students', response.json())

    def test_filter_by_department(self):
        response = self.client.get('/api/dashboard/students/?department=컴퓨터공학과')
        data = response.json()
        self.assertEqual(len(data['by_department']), 1)
        self.assertEqual(data['by_department'][0]['department'], '컴퓨터공학과')

    def test_filter_by_enrollment_status(self):
        response = self.client.get('/api/dashboard/students/?status=재학')
        data = response.json()
        # 재학생만 포함되어야 함
        self.assertTrue(all(item['total'] > 0 for item in data['by_department']))

    def test_invalid_status_returns_400(self):
        response = self.client.get('/api/dashboard/students/?status=invalid')
        self.assertEqual(response.status_code, 400)
        self.assertIn('error', response.json())

    def test_no_data_returns_404(self):
        Student.objects.all().delete()
        response = self.client.get('/api/dashboard/students/')
        self.assertEqual(response.status_code, 404)
```

#### 프런트엔드 테스트 (Jest + React Testing Library)

**StudentBarChart.test.jsx**
```javascript
import { render, screen } from '@testing-library/react';
import StudentBarChart from './StudentBarChart';

describe('StudentBarChart', () => {
  const mockData = [
    { name: '컴퓨터공학과', 학사: 120, 석사: 35, 박사: 12 },
    { name: '전자공학과', 학사: 98, 석사: 28, 박사: 9 }
  ];

  it('renders chart with data', () => {
    render(<StudentBarChart data={mockData} loading={false} />);
    expect(screen.getByText('컴퓨터공학과')).toBeInTheDocument();
    expect(screen.getByText('전자공학과')).toBeInTheDocument();
  });

  it('shows loading state', () => {
    render(<StudentBarChart data={null} loading={true} />);
    expect(screen.getByTestId('skeleton-loader')).toBeInTheDocument();
  });

  it('shows empty state when no data', () => {
    render(<StudentBarChart data={[]} loading={false} />);
    expect(screen.getByText('학생 데이터가 없습니다.')).toBeInTheDocument();
  });

  it('displays custom tooltip on hover', async () => {
    const { container } = render(<StudentBarChart data={mockData} loading={false} />);
    // Recharts 호버 시뮬레이션은 복잡하므로 Tooltip 컴포넌트 유닛 테스트로 분리
  });
});
```

**useStudentDashboardData.test.js**
```javascript
import { renderHook, waitFor } from '@testing-library/react';
import { useStudentDashboardData } from './useStudentDashboardData';
import * as api from '../api/dataApiClient';

jest.mock('../api/dataApiClient');

describe('useStudentDashboardData', () => {
  it('loads data on mount', async () => {
    api.fetchStudentData.mockResolvedValue({
      total_students: 1234,
      by_department: []
    });

    const { result } = renderHook(() => useStudentDashboardData());

    expect(result.current.loading).toBe(true);

    await waitFor(() => expect(result.current.loading).toBe(false));
    expect(result.current.data.total_students).toBe(1234);
  });

  it('updates data when filters change', async () => {
    api.fetchStudentData.mockResolvedValue({ total_students: 100 });

    const { result } = renderHook(() => useStudentDashboardData());

    await waitFor(() => expect(result.current.loading).toBe(false));

    act(() => {
      result.current.updateFilter('department', '컴퓨터공학과');
    });

    await waitFor(() => expect(api.fetchStudentData).toHaveBeenCalledWith({
      department: '컴퓨터공학과',
      status: '재학'
    }));
  });

  it('handles error gracefully', async () => {
    api.fetchStudentData.mockRejectedValue(new Error('Network error'));

    const { result } = renderHook(() => useStudentDashboardData());

    await waitFor(() => expect(result.current.error).toBe('Network error'));
  });
});
```

### 7.2 Integration Tests (10%)

**핵심 플로우만 테스트:**

**tests/integration/test_student_dashboard_flow.py**
```python
from django.test import TestCase
from rest_framework.test import APIClient
from data_ingestion.infrastructure.models import Student

class StudentDashboardIntegrationTest(TestCase):
    def setUp(self):
        """테스트 데이터 직접 생성"""
        Student.objects.bulk_create([
            Student(student_id='2024001', department='컴퓨터공학과', grade=1,
                   program_type='학사', enrollment_status='재학'),
            Student(student_id='2024002', department='컴퓨터공학과', grade=2,
                   program_type='석사', enrollment_status='재학'),
            Student(student_id='2024003', department='전자공학과', grade=1,
                   program_type='학사', enrollment_status='휴학'),
        ])

    def test_api_to_db_aggregation_flow(self):
        """API 호출 → DB 집계 → JSON 응답 검증"""
        client = APIClient()
        response = client.get('/api/dashboard/students/?status=재학')

        self.assertEqual(response.status_code, 200)
        data = response.json()
        self.assertEqual(data['total_students'], 2)
        self.assertEqual(len(data['by_department']), 2)

    def test_combined_filters(self):
        """학과 + 학적상태 필터 조합 테스트"""
        client = APIClient()
        response = client.get('/api/dashboard/students/?department=컴퓨터공학과&status=재학')

        data = response.json()
        self.assertEqual(data['total_students'], 2)
        self.assertEqual(data['by_department'][0]['department'], '컴퓨터공학과')
```

**NOTE:** CSV 업로드 플로우는 UC-001의 Integration Test에서 검증

### 7.3 E2E Tests (10%)

**cypress/e2e/student_dashboard.cy.js**
```javascript
describe('Student Dashboard E2E', () => {
  beforeEach(() => {
    cy.visit('/dashboard');
  });

  it('displays student chart on initial load', () => {
    cy.get('[data-testid="student-bar-chart"]').should('be.visible');
    cy.get('[data-testid="total-students-metric"]').should('contain', '명');
  });

  it('filters by department', () => {
    cy.get('[data-testid="department-filter"]').select('컴퓨터공학과');
    cy.wait(500); // 디바운싱
    cy.get('[data-testid="student-bar-chart"]').should('contain', '컴퓨터공학과');
    cy.get('[data-testid="total-students-metric"]').should('not.contain', '전체');
  });

  it('shows tooltip on hover', () => {
    cy.get('[data-testid="student-bar-chart"] .recharts-bar').first().trigger('mouseover');
    cy.get('.custom-tooltip').should('be.visible');
    cy.get('.custom-tooltip').should('contain', '총:');
  });

  it('resets filters', () => {
    cy.get('[data-testid="department-filter"]').select('전자공학과');
    cy.wait(500);
    cy.get('[data-testid="reset-filters-btn"]').click();
    cy.get('[data-testid="department-filter"]').should('have.value', 'all');
  });
});
```

---

## 8. Edge Cases (에러 처리)

### 8.1 데이터 관련 엣지케이스

#### 케이스 1: 학과 수가 많음 (10개 이상)
**문제:** 학과가 15개 이상일 때 차트가 가독성이 떨어짐

**해결 방안:**
- 차트 컨테이너 넓이 자동 확장 (`minWidth: 학과수 * 80px`)
- 가로 스크롤 바 표시
- 또는 페이지네이션: 상위 10개 학과 우선 표시, "더 보기" 버튼

**구현:**
```jsx
<ResponsiveContainer width="100%" height={400} minWidth={data.length * 80}>
  <BarChart data={data}>
    {/* ... */}
  </BarChart>
</ResponsiveContainer>
```

#### 케이스 2: 특정 학과에 데이터 없음
**문제:** 학과 필터링 결과 데이터가 0건

**해결 방안:**
- 빈 상태 일러스트레이션 표시
- 메시지: "선택한 학과에 해당하는 학생이 없습니다."
- "전체 보기" 버튼 강조

#### 케이스 3: 모든 학생이 한 과정에만 속함 (학사만 있음)
**문제:** 스택 바가 단일 색상으로만 표시됨

**해결 방안:**
- 정상 작동 (의도된 동작)
- 범례에는 학사/석사/박사 모두 표시하되, 해당 없는 과정은 "0명" 표시

#### 케이스 4: 학년 데이터 불균형 (1학년만 1000명, 나머지 각 10명)
**문제:** Y축 스케일이 극단적으로 커져서 소수 데이터가 보이지 않음

**해결 방안:**
- Recharts 자동 스케일링 신뢰 (로그 스케일은 MVP 제외)
- Tooltip으로 정확한 숫자 확인 가능

### 8.2 성능 관련 엣지케이스

#### 케이스 5: 학생 수 매우 많음 (10,000명 이상)
**문제:** DB 집계 쿼리가 느려질 수 있음

**해결 방안:**
- 인덱스 활용 (department, enrollment_status)
- DB 레벨 집계 사용 (Django ORM `annotate`)
- 타임아웃: 5초 초과 시 "데이터 로딩 지연" 경고

#### 케이스 6: 차트 렌더링 느림 (구형 브라우저)
**문제:** Recharts SVG 렌더링이 느림

**해결 방안:**
- 브라우저 요구사항 명시: Chrome/Firefox/Edge 최신 2개 버전만 지원
- 미지원 브라우저 접속 시 안내 페이지 표시

### 8.3 UI/UX 엣지케이스

#### 케이스 7: 모바일 화면에서 차트 가독성 저하
**문제:** 작은 화면에서 X축 레이블 겹침

**해결 방안 (POST-MVP):**
- X축 레이블 회전 (45도 또는 90도)
- 모바일에서는 카드 형식으로 대체 표시

#### 케이스 8: 필터 빠른 변경 (연속 클릭)
**문제:** API 요청 과다 발생

**해결 방안:**
- 디바운싱 300ms 적용

---

## 9. Business Rules

### 규칙 1: 학적상태 기본값
- 학생 현황 조회 시 **기본적으로 재학생만 집계**
- 휴학생 및 졸업생은 명시적으로 "전체" 선택 시에만 포함

### 규칙 2: 과정 구분 순서
- 차트 스택 순서: 학사(하단) → 석사(중간) → 박사(상단)
- 범례 순서도 동일하게 유지

### 규칙 3: 데이터 신선도
- 최종 업데이트 시간을 차트 하단에 표시 (`updated_at` 필드)

### 규칙 4: 학과 정렬 (최종 확정)
- **MVP:** 학생 수 내림차순 고정 (많은 학과 → 적은 학과 순)
- **POST-MVP:** 사용자가 정렬 방식 선택 가능 (학생 수 / 가나다 순)
- **구현:** `ORDER BY total DESC` (Service Layer의 `_aggregate_by_department` 메서드)

### 규칙 5: 숫자 포맷
- 1,000명 이상은 쉼표로 구분 표시: "1,234명"
- Tooltip에서도 동일한 포맷 사용

---

## 10. 보안 요구사항

### 10.1 API 접근 제어

**MVP:**
- 별도 인증 없이 내부 네트워크에서만 접근 가능 (Railway 환경 변수 설정)
- CORS 설정: 프런트엔드 도메인만 허용

**POST-MVP:**
- 하드코딩 API Key 또는 간단한 토큰 인증 도입

**구현 예시:**
```python
# settings.py
CORS_ALLOWED_ORIGINS = [
    os.environ.get('FRONTEND_URL', 'http://localhost:3000'),
]
```

### 10.2 입력 검증

**Query Parameter Validation:**

1. **학과 필터 (department):**
   - 화이트리스트 기반 검증 (DB에 존재하는 학과만 허용)
   - `StudentDashboardService._validate_inputs()` 메서드에서 검증
   - 존재하지 않는 학과 입력 시 400 Bad Request 반환

2. **학적상태 필터 (status):**
   - Enum 검증: `['all', '재학', '휴학', '졸업']` 중 하나만 허용
   - 유효하지 않은 값 입력 시 400 Bad Request 반환

**구현 예시:**
```python
# services/student_dashboard_service.py
ALLOWED_STATUSES = ['all', '재학', '휴학', '졸업']

def _validate_inputs(self, department, status):
    # 학적상태 화이트리스트 검증
    if status not in ALLOWED_STATUSES:
        raise ValidationError(f"유효하지 않은 학적상태: {status}")

    # 학과 존재 여부 검증
    if department != 'all':
        all_departments = self.student_repo.get_all_departments()
        if department not in all_departments:
            raise ValidationError(f"존재하지 않는 학과: {department}")
```

### 10.3 SQL Injection 방어

- Django ORM 사용 시 Parameterized Query 자동 처리로 SQL Injection 방어
- **Raw SQL 사용 금지** (모든 쿼리는 Django ORM을 통해서만 실행)
- `values()`, `annotate()`, `filter()` 등 ORM 메서드만 사용

### 10.4 XSS 방어 (프런트엔드)

**React 기본 방어 메커니즘 활용:**
- React는 기본적으로 JSX 내 문자열을 자동 이스케이프 처리
- `dangerouslySetInnerHTML` 사용 금지
- 학과명/과정명은 DB에서 가져온 신뢰 데이터로 추가 검증 불필요

---

## 11. 성능 요구사항 (MVP)

### 11.1 응답 시간 목표

- **API 응답 시간:** 평균 < 500ms (학생 데이터 10,000건 기준)
- **차트 초기 렌더링:** < 1초
- **필터 적용 후 리렌더링:** < 300ms

### 11.2 데이터 규모 제약

- 최대 학생 수: 50,000명
- 최대 학과 수: 50개

---

## 12. Sequence Diagram (PlantUML)

```plantuml
@startuml
actor User
participant FE as "Frontend\n(React)"
participant BE as "Backend\n(DRF View)"
participant Database as "Database\n(Supabase)"

User -> FE: 대시보드 접속 (/)
activate FE
FE -> FE: StudentDashboard 컴포넌트 렌더링
FE -> FE: 스켈레톤 UI 표시
FE -> BE: GET /api/dashboard/students/?status=재학
activate BE

BE -> BE: 요청 파라미터 검증
BE -> Database: SELECT department, program_type, COUNT(*)\nFROM students\nWHERE enrollment_status = '재학'\nGROUP BY department, program_type
activate Database
Database --> BE: 집계 결과 반환
deactivate Database

BE -> BE: 데이터 직렬화 (Serializer)
BE --> FE: HTTP 200 OK\n{total_students: 1234, by_department: [...]}
deactivate BE

FE -> FE: 데이터를 Recharts 형식으로 변환
FE -> FE: Stacked Bar Chart 렌더링
FE -> FE: Metric Card 렌더링 (총 재학생: 1,234명)
FE --> User: 차트 표시 완료
deactivate FE

User -> FE: 학과 필터 선택 (컴퓨터공학과)
activate FE
FE -> FE: State 업데이트\n(selectedDepartment: '컴퓨터공학과')
FE -> FE: 디바운싱 300ms 대기
FE -> BE: GET /api/dashboard/students/?department=컴퓨터공학과&status=재학
activate BE

BE -> Database: SELECT department, program_type, COUNT(*)\nFROM students\nWHERE department = '컴퓨터공학과'\nAND enrollment_status = '재학'\nGROUP BY department, program_type
activate Database
Database --> BE: 필터링된 집계 결과
deactivate Database

BE --> FE: HTTP 200 OK\n{total_students: 167, by_department: [...]}
deactivate BE

FE -> FE: 차트 리렌더링 (애니메이션)
FE -> FE: Metric Card 업데이트 (총 재학생: 167명)
FE --> User: 필터링된 차트 표시
deactivate FE

User -> FE: 막대 그래프에 마우스 호버
activate FE
FE -> FE: Recharts Tooltip 활성화
FE --> User: Tooltip 표시\n(컴퓨터공학과\n학사: 120명, 석사: 35명, 박사: 12명\n총: 167명)
deactivate FE

User -> FE: 마우스 이동 (차트 밖)
activate FE
FE -> FE: Tooltip 숨김
FE --> User: Tooltip 사라짐
deactivate FE

User -> FE: "전체 보기" 버튼 클릭
activate FE
FE -> FE: 필터 초기화\n(department: 'all', status: '재학')
FE -> BE: GET /api/dashboard/students/?status=재학
activate BE

BE -> Database: SELECT department, program_type, COUNT(*)\nFROM students\nWHERE enrollment_status = '재학'\nGROUP BY department, program_type
activate Database
Database --> BE: 전체 집계 결과
deactivate Database

BE --> FE: HTTP 200 OK (전체 데이터)
deactivate BE

FE -> FE: 차트 리렌더링 (전체 학과)
FE --> User: 초기 상태로 복원
deactivate FE
@enduml
```

---

## 문서 변경 이력

| 버전 | 날짜 | 변경 사항 | 작성자 |
|------|------|-----------|--------|
| 1.0 | 2025-11-02 | 초기 유스케이스 문서 작성 | Spec Writer Agent |
| 2.0 | 2025-11-02 | P0 개선사항 적용: CSV 칼럼 매핑, Layered Architecture, 보안/성능 요구사항 추가 | Claude Code |
| 2.1 | 2025-11-02 | 오버엔지니어링 요소 제거 (미사용 칼럼, Redis 캐싱, Rate Limiting, 과도한 SLA), MVP 집중 | Claude Code |

---

## 승인 및 검토

**작성자:** Spec Writer Agent
**검토자:** CTO
**승인일:** 2025-11-02

본 유스케이스 문서는 MVP 범위에 맞춘 학과별 학생 현황 대시보드 기능의 상세 구현 가이드입니다. TDD 원칙에 따라 테스트 시나리오를 포함하며, 모든 엣지케이스 처리 방안을 명시합니다.

---

**문서 끝**
</file>

<file path="004-publication-dashboard/plan.md">
# 논문 실적 대시보드 구현 계획 (TDD 기반)

**기능 ID:** 004
**기능명:** 논문 실적 시각화
**우선순위:** P0-MVP
**작성일:** 2025-11-02
**버전:** 1.0

---

## 1. 개요

### 1.1 모듈 목록

본 구현 계획은 **TDD(Test-Driven Development) 원칙**에 따라 작성되었으며, Red-Green-Refactor 사이클을 기반으로 순차적 개발을 진행합니다.

#### Backend Modules
1. **Publication Model** (`backend/data_ingestion/infrastructure/models.py`)
   - 논문 데이터 스키마 정의
   - Test: Model validation, constraints

2. **Publication Repository** (`backend/data_ingestion/infrastructure/repositories.py`)
   - 데이터 접근 로직 (Django ORM)
   - Test: Query correctness, filtering logic

3. **Publication Service** (`backend/data_ingestion/services/publication_service.py`)
   - 비즈니스 로직 및 집계
   - Test: Business rules, aggregation accuracy

4. **Publication API View** (`backend/data_ingestion/api/views.py`)
   - DRF ViewSet (Thin Controller)
   - Test: HTTP responses, serialization

5. **Publication Serializer** (`backend/data_ingestion/api/serializers.py`)
   - Request/Response contract
   - Test: Data validation, format

#### Frontend Modules
6. **Publication Data Types** (`frontend/src/types/domain.ts`)
   - TypeScript interfaces
   - Test: Type safety (compile-time)

7. **Publication API Client** (`frontend/src/api/publicationApi.ts`)
   - Backend 통신 계층
   - Test: API call mocking, error handling

8. **usePublicationData Hook** (`frontend/src/hooks/usePublicationData.ts`)
   - 상태 관리 및 데이터 fetching
   - Test: State transitions, caching

9. **PublicationDoughnutChart Component** (`frontend/src/components/dashboard/PublicationDoughnutChart.tsx`)
   - Recharts Doughnut Chart
   - Test: Rendering, Tooltip, Empty state

10. **PublicationMetricCards Component** (`frontend/src/components/dashboard/PublicationMetricCards.tsx`)
    - 총 논문 수, 평균 IF 카드
    - Test: Data display, formatting

#### Shared/Common
11. **Constants** (`backend/data_ingestion/domain/constants.py`, `frontend/src/constants/publications.ts`)
    - 저널등급 Enum, 색상 매핑
    - Test: Value consistency

### 1.2 TDD 적용 범위

**Test Pyramid (70% Unit / 20% Integration / 10% E2E)**

- **Unit Tests (70%):**
  - Service Layer: 비즈니스 로직 (집계, 평균 계산, 필터링)
  - Repository Layer: ORM 쿼리 정확성
  - Frontend Hooks: 상태 전이 로직
  - API Client: Mocking 기반 단위 테스트

- **Integration Tests (20%):**
  - API Endpoint: DRF View → Service → Repository 전체 플로우
  - Frontend: Hook + API Client 통합

- **Acceptance Tests (10%):**
  - E2E: Playwright 기반 사용자 시나리오

---

## 2. Architecture Diagram

```mermaid
graph TD
    subgraph Frontend
        A[PublicationDashboard Page] --> B[PublicationMetricCards]
        A --> C[PublicationDoughnutChart]
        A --> D[FilterPanel]

        B --> E[usePublicationData Hook]
        C --> E
        D --> E

        E --> F[Publication API Client]
    end

    subgraph Backend
        F -->|HTTP GET| G[PublicationDashboardView]
        G --> H[PublicationService]
        H --> I[PublicationRepository]
        I --> J[(Publication Model)]
        J --> K[(PostgreSQL/Supabase)]
    end

    subgraph Domain Layer
        L[PublicationEntity]
        M[JOURNAL_TIER_ENUM]
    end

    H -.-> L
    H -.-> M

    style G fill:#e1f5ff
    style H fill:#fff4e1
    style I fill:#e8f5e9
    style E fill:#f3e5f5
```

---

## 3. Implementation Plan

### Module 1: Publication Model

**Location:** `backend/data_ingestion/infrastructure/models.py`

**Responsibility:**
- Django ORM 모델 정의
- DB 테이블 스키마 매핑
- 기본 제약 조건 (NOT NULL, PK, Choices)

**Test Strategy:** Unit Tests

**Test Scenarios (Red Phase):**

```python
# tests/test_models.py

class PublicationModelTestCase(TestCase):
    """Publication 모델 단위 테스트"""

    def test_create_publication_with_valid_data(self):
        """유효한 데이터로 Publication 생성 시 성공"""
        # GIVEN: 유효한 논문 데이터
        publication = Publication(
            paper_id='P001',
            department='컴퓨터공학과',
            journal_tier='SCIE',
            impact_factor=3.5
        )

        # WHEN: 저장 시도
        publication.save()

        # THEN: DB에 저장 성공
        saved = Publication.objects.get(paper_id='P001')
        self.assertEqual(saved.journal_tier, 'SCIE')
        self.assertEqual(saved.impact_factor, 3.5)

    def test_impact_factor_can_be_null(self):
        """Impact Factor가 NULL일 수 있음"""
        # GIVEN: IF가 없는 논문
        publication = Publication(
            paper_id='P002',
            department='전자공학과',
            journal_tier='KCI',
            impact_factor=None
        )

        # WHEN: 저장
        publication.save()

        # THEN: NULL 허용
        saved = Publication.objects.get(paper_id='P002')
        self.assertIsNone(saved.impact_factor)

    def test_journal_tier_choices_validation(self):
        """허용되지 않은 저널등급 입력 시 실패"""
        # GIVEN: 잘못된 저널등급
        publication = Publication(
            paper_id='P003',
            department='기계공학과',
            journal_tier='INVALID_TIER',  # 허용 안 됨
            impact_factor=2.0
        )

        # WHEN/THEN: ValidationError 발생
        with self.assertRaises(ValidationError):
            publication.full_clean()

    def test_duplicate_paper_id_raises_error(self):
        """중복 논문ID 입력 시 IntegrityError"""
        # GIVEN: 동일 PK를 가진 논문 2개
        Publication.objects.create(
            paper_id='P001',
            department='컴공',
            journal_tier='SCIE'
        )

        # WHEN/THEN: 중복 삽입 시도
        with self.assertRaises(IntegrityError):
            Publication.objects.create(
                paper_id='P001',  # 중복
                department='전자공',
                journal_tier='KCI'
            )

    def test_string_representation(self):
        """__str__ 메서드가 올바른 형식 반환"""
        # GIVEN
        publication = Publication.objects.create(
            paper_id='P001',
            department='컴공',
            journal_tier='SCIE'
        )

        # WHEN/THEN
        self.assertEqual(str(publication), 'P001 (SCIE)')
```

**Implementation Order (TDD Cycle):**
1. Red: 위 테스트 작성 → 모두 실패
2. Green: Model 클래스 구현 (최소 코드로 테스트 통과)
3. Refactor: 인덱스 추가, Meta 옵션 정리

**Dependencies:** None (Pure Django Model)

---

### Module 2: Publication Repository

**Location:** `backend/data_ingestion/infrastructure/repositories.py`

**Responsibility:**
- Publication 데이터 조회 전담 (Data Access Layer)
- 필터링 쿼리 로직
- Django ORM 직접 사용 (추상화 없음, MVP 간소화)

**Test Strategy:** Unit Tests

**Test Scenarios (Red Phase):**

```python
# tests/test_repositories.py

class PublicationRepositoryTestCase(TestCase):
    """PublicationRepository 단위 테스트"""

    def setUp(self):
        """테스트 데이터 준비"""
        self.repo = PublicationRepository()

        # SCIE 논문 5편
        for i in range(5):
            Publication.objects.create(
                paper_id=f'SCIE_{i}',
                department='컴퓨터공학과',
                journal_tier='SCIE',
                impact_factor=3.0 + i * 0.5
            )

        # KCI 논문 3편
        for i in range(3):
            Publication.objects.create(
                paper_id=f'KCI_{i}',
                department='컴퓨터공학과',
                journal_tier='KCI',
                impact_factor=1.0 + i * 0.2
            )

    def test_get_all_publications(self):
        """전체 논문 조회"""
        # WHEN
        queryset = self.repo.get_publications_by_filter()

        # THEN
        self.assertEqual(queryset.count(), 8)

    def test_filter_by_department(self):
        """학과 필터링"""
        # GIVEN: 다른 학과 논문 추가
        Publication.objects.create(
            paper_id='OTHER_1',
            department='전자공학과',
            journal_tier='SCIE'
        )

        # WHEN: 컴공만 필터링
        queryset = self.repo.get_publications_by_filter(department='컴퓨터공학과')

        # THEN: 8편만 조회 (전자공 제외)
        self.assertEqual(queryset.count(), 8)

    def test_filter_by_journal_tier(self):
        """저널등급 필터링"""
        # WHEN: SCIE만 필터링
        queryset = self.repo.get_publications_by_filter(journal_tier='SCIE')

        # THEN: 5편만 조회
        self.assertEqual(queryset.count(), 5)

    def test_filter_by_department_and_tier(self):
        """학과 + 저널등급 복합 필터링 (AND 조건)"""
        # GIVEN
        Publication.objects.create(
            paper_id='OTHER_2',
            department='전자공학과',
            journal_tier='SCIE'
        )

        # WHEN: 컴공 + SCIE
        queryset = self.repo.get_publications_by_filter(
            department='컴퓨터공학과',
            journal_tier='SCIE'
        )

        # THEN: 5편 (전자공 SCIE 제외)
        self.assertEqual(queryset.count(), 5)

    def test_get_all_departments(self):
        """전체 학과 목록 조회 (중복 제거)"""
        # GIVEN
        Publication.objects.create(
            paper_id='OTHER_3',
            department='전자공학과',
            journal_tier='KCI'
        )

        # WHEN
        departments = self.repo.get_all_departments()

        # THEN
        self.assertEqual(set(departments), {'컴퓨터공학과', '전자공학과'})
```

**Implementation Order:**
1. Red: 테스트 작성 → 실패
2. Green: Repository 메서드 구현
3. Refactor: 쿼리 최적화 (select_related, prefetch_related 불필요하지만 확인)

**Dependencies:** Publication Model

---

### Module 3: Publication Service

**Location:** `backend/data_ingestion/services/publication_service.py`

**Responsibility:**
- 비즈니스 로직: 집계, 평균 계산, 비율 계산
- 입력 검증 (학과/저널등급 화이트리스트)
- Repository를 통한 데이터 조회

**Test Strategy:** Unit Tests (핵심 비즈니스 로직)

**Test Scenarios (Red Phase):**

```python
# tests/test_services.py

class PublicationServiceTestCase(TestCase):
    """PublicationService 비즈니스 로직 테스트"""

    def setUp(self):
        """테스트 데이터 준비"""
        self.service = PublicationService()

        # SCIE 3편 (IF: 3.0, 4.0, 5.0)
        Publication.objects.create(
            paper_id='S1', department='컴공',
            journal_tier='SCIE', impact_factor=3.0
        )
        Publication.objects.create(
            paper_id='S2', department='컴공',
            journal_tier='SCIE', impact_factor=4.0
        )
        Publication.objects.create(
            paper_id='S3', department='컴공',
            journal_tier='SCIE', impact_factor=5.0
        )

        # KCI 2편 (IF: 1.0, 1.5)
        Publication.objects.create(
            paper_id='K1', department='컴공',
            journal_tier='KCI', impact_factor=1.0
        )
        Publication.objects.create(
            paper_id='K2', department='컴공',
            journal_tier='KCI', impact_factor=1.5
        )

    def test_get_distribution_calculates_percentages_correctly(self):
        """저널 등급별 비율 계산 정확성"""
        # WHEN
        result = self.service.get_distribution()

        # THEN: 총 5편 (SCIE 3편 = 60%, KCI 2편 = 40%)
        self.assertEqual(result['total_papers'], 5)

        distribution = {item['journal_tier']: item for item in result['distribution']}
        self.assertAlmostEqual(distribution['SCIE']['percentage'], 60.0, places=1)
        self.assertAlmostEqual(distribution['KCI']['percentage'], 40.0, places=1)

    def test_get_distribution_calculates_avg_if_correctly(self):
        """평균 Impact Factor 계산 정확성"""
        # WHEN
        result = self.service.get_distribution()

        # THEN: 전체 평균 = (3+4+5+1+1.5)/5 = 2.9
        self.assertAlmostEqual(result['avg_impact_factor'], 2.9, places=2)

        # 등급별 평균
        distribution = {item['journal_tier']: item for item in result['distribution']}
        self.assertAlmostEqual(distribution['SCIE']['avg_if'], 4.0, places=2)  # (3+4+5)/3
        self.assertAlmostEqual(distribution['KCI']['avg_if'], 1.25, places=2)  # (1+1.5)/2

    def test_avg_if_excludes_null_values(self):
        """NULL IF는 평균 계산에서 제외"""
        # GIVEN: IF 없는 논문 추가
        Publication.objects.create(
            paper_id='N1', department='컴공',
            journal_tier='SCIE', impact_factor=None
        )

        # WHEN
        result = self.service.get_distribution()

        # THEN: 총 6편이지만 평균은 5편 기준
        self.assertEqual(result['total_papers'], 6)
        self.assertEqual(result['papers_with_if'], 5)
        self.assertAlmostEqual(result['avg_impact_factor'], 2.9, places=2)

    def test_all_null_if_returns_none(self):
        """모든 논문 IF가 NULL일 때 평균 None 반환"""
        # GIVEN: 모든 IF를 NULL로 변경
        Publication.objects.update(impact_factor=None)

        # WHEN
        result = self.service.get_distribution()

        # THEN
        self.assertIsNone(result['avg_impact_factor'])
        self.assertEqual(result['papers_with_if'], 0)

    def test_filter_by_department_applies_correctly(self):
        """학과 필터 적용 검증"""
        # GIVEN: 다른 학과 논문 추가
        Publication.objects.create(
            paper_id='E1', department='전자공',
            journal_tier='SCIE', impact_factor=2.0
        )

        # WHEN: 컴공만 필터링
        result = self.service.get_distribution(department='컴공')

        # THEN: 5편만 (전자공 제외)
        self.assertEqual(result['total_papers'], 5)

    def test_invalid_journal_tier_raises_validation_error(self):
        """허용되지 않은 저널등급 입력 시 ValidationError"""
        # WHEN/THEN
        with self.assertRaises(ValidationError) as ctx:
            self.service.get_distribution(journal_tier='INVALID')

        self.assertIn('유효하지 않은 저널등급', str(ctx.exception))

    def test_invalid_department_raises_validation_error(self):
        """존재하지 않는 학과 입력 시 ValidationError"""
        # WHEN/THEN
        with self.assertRaises(ValidationError) as ctx:
            self.service.get_distribution(department='존재하지않는학과')

        self.assertIn('존재하지 않는 학과', str(ctx.exception))

    def test_empty_dataset_returns_zero_values(self):
        """데이터 없을 때 0 반환"""
        # GIVEN: 모든 데이터 삭제
        Publication.objects.all().delete()

        # WHEN
        result = self.service.get_distribution()

        # THEN
        self.assertEqual(result['total_papers'], 0)
        self.assertIsNone(result['avg_impact_factor'])
        self.assertEqual(len(result['distribution']), 0)
```

**Edge Cases (추가 테스트):**

```python
def test_single_paper_displays_100_percent(self):
    """논문 1편만 있을 때 100% 표시"""
    # GIVEN
    Publication.objects.all().delete()
    Publication.objects.create(
        paper_id='ONLY_ONE', department='컴공',
        journal_tier='SCIE', impact_factor=3.0
    )

    # WHEN
    result = self.service.get_distribution()

    # THEN
    self.assertEqual(result['total_papers'], 1)
    self.assertEqual(result['distribution'][0]['percentage'], 100.0)

def test_percentage_sum_is_100(self):
    """비율 합계가 100% (반올림 오차 ±0.1 허용)"""
    # WHEN
    result = self.service.get_distribution()

    # THEN
    total_percentage = sum(item['percentage'] for item in result['distribution'])
    self.assertAlmostEqual(total_percentage, 100.0, delta=0.1)
```

**Implementation Order:**
1. Red: 테스트 작성
2. Green: Service 메서드 구현
3. Refactor: 집계 로직 최적화, 메서드 분리

**Dependencies:** PublicationRepository

---

### Module 4: Publication API View

**Location:** `backend/data_ingestion/api/views.py`

**Responsibility:**
- HTTP 요청 처리 (Thin Controller)
- Service Layer 호출
- 에러 핸들링 및 HTTP 응답

**Test Strategy:** Integration Tests (API 엔드포인트)

**Test Scenarios (Red Phase):**

```python
# tests/test_api.py

class PublicationAPITestCase(APITestCase):
    """Publication API 통합 테스트"""

    def setUp(self):
        """테스트 데이터 준비"""
        Publication.objects.create(
            paper_id='P1', department='컴공',
            journal_tier='SCIE', impact_factor=3.5
        )
        Publication.objects.create(
            paper_id='P2', department='컴공',
            journal_tier='KCI', impact_factor=1.2
        )

    def test_get_publications_distribution_success(self):
        """GET /api/dashboard/publications/ 정상 응답"""
        # WHEN
        response = self.client.get('/api/dashboard/publications/')

        # THEN
        self.assertEqual(response.status_code, 200)
        data = response.json()

        self.assertTrue(data['success'])
        self.assertEqual(data['data']['total_papers'], 2)
        self.assertIsNotNone(data['data']['avg_impact_factor'])
        self.assertEqual(len(data['data']['distribution']), 2)

    def test_filter_by_department_query_param(self):
        """department 쿼리 파라미터 필터링"""
        # GIVEN: 다른 학과 논문 추가
        Publication.objects.create(
            paper_id='P3', department='전자공',
            journal_tier='SCIE', impact_factor=2.0
        )

        # WHEN
        response = self.client.get('/api/dashboard/publications/?department=컴공')

        # THEN
        self.assertEqual(response.status_code, 200)
        data = response.json()['data']
        self.assertEqual(data['total_papers'], 2)  # 전자공 제외

    def test_filter_by_journal_tier_query_param(self):
        """journal_tier 쿼리 파라미터 필터링"""
        # WHEN
        response = self.client.get('/api/dashboard/publications/?journal_tier=SCIE')

        # THEN
        self.assertEqual(response.status_code, 200)
        data = response.json()['data']
        self.assertEqual(data['total_papers'], 1)  # SCIE만

    def test_invalid_department_returns_400(self):
        """잘못된 학과명 입력 시 400 Bad Request"""
        # WHEN
        response = self.client.get('/api/dashboard/publications/?department=존재하지않는학과')

        # THEN
        self.assertEqual(response.status_code, 400)
        error = response.json()
        self.assertEqual(error['error'], 'ERR_PUB_001')
        self.assertIn('잘못된 학과명', error['message'])

    def test_invalid_journal_tier_returns_400(self):
        """잘못된 저널등급 입력 시 400 Bad Request"""
        # WHEN
        response = self.client.get('/api/dashboard/publications/?journal_tier=INVALID')

        # THEN
        self.assertEqual(response.status_code, 400)
        error = response.json()
        self.assertEqual(error['error'], 'ERR_PUB_002')

    def test_no_data_returns_404(self):
        """데이터 없을 때 404 Not Found"""
        # GIVEN: 모든 데이터 삭제
        Publication.objects.all().delete()

        # WHEN
        response = self.client.get('/api/dashboard/publications/')

        # THEN
        self.assertEqual(response.status_code, 404)
        error = response.json()
        self.assertEqual(error['error'], 'ERR_PUB_003')

    def test_response_includes_last_updated_timestamp(self):
        """응답에 last_updated 포함"""
        # WHEN
        response = self.client.get('/api/dashboard/publications/')

        # THEN
        data = response.json()['data']
        self.assertIn('last_updated', data)
        # ISO 8601 형식 검증
        from datetime import datetime
        datetime.fromisoformat(data['last_updated'].replace('Z', '+00:00'))
```

**Implementation Order:**
1. Red: API 테스트 작성
2. Green: View 구현 (Service 호출)
3. Refactor: 에러 핸들링 개선

**Dependencies:** PublicationService, PublicationSerializer

---

### Module 5: Publication Serializer

**Location:** `backend/data_ingestion/api/serializers.py`

**Responsibility:**
- API 응답 데이터 직렬화
- 데이터 형식 검증

**Test Strategy:** Unit Tests

**Test Scenarios (Red Phase):**

```python
# tests/test_serializers.py

class PublicationDashboardSerializerTestCase(TestCase):
    """PublicationDashboardSerializer 테스트"""

    def test_valid_data_serialization(self):
        """유효한 데이터 직렬화"""
        # GIVEN
        data = {
            'total_papers': 156,
            'avg_impact_factor': 2.3,
            'papers_with_if': 145,
            'distribution': [
                {
                    'journal_tier': 'SCIE',
                    'count': 89,
                    'percentage': 57.1,
                    'avg_if': 3.2
                }
            ],
            'last_updated': '2025-11-02T14:35:22Z'
        }

        # WHEN
        serializer = PublicationDashboardSerializer(data=data)

        # THEN
        self.assertTrue(serializer.is_valid())

    def test_missing_required_field_raises_error(self):
        """필수 필드 누락 시 ValidationError"""
        # GIVEN: total_papers 누락
        data = {
            'avg_impact_factor': 2.3,
            'distribution': []
        }

        # WHEN
        serializer = PublicationDashboardSerializer(data=data)

        # THEN
        self.assertFalse(serializer.is_valid())
        self.assertIn('total_papers', serializer.errors)
```

**Implementation Order:**
1. Red: 직렬화 테스트
2. Green: Serializer 클래스 작성
3. Refactor: 필드 validation 추가

**Dependencies:** None (DRF Serializers)

---

### Module 6-10: Frontend Modules

#### Module 6: Publication Data Types

**Location:** `frontend/src/types/domain.ts`

**Test Strategy:** TypeScript Compile-time Type Checking

```typescript
// types/domain.ts

export interface PublicationData {
  total_papers: number;
  avg_impact_factor: number | null;
  papers_with_if: number;
  distribution: PublicationDistributionItem[];
  last_updated: string;
}

export interface PublicationDistributionItem {
  journal_tier: 'SCIE' | 'KCI' | '기타';
  count: number;
  percentage: number;
  avg_if: number | null;
}
```

**Dependencies:** None

---

#### Module 7: Publication API Client

**Location:** `frontend/src/api/publicationApi.ts`

**Test Strategy:** Unit Tests (Mocking)

```typescript
// tests/publicationApi.test.ts

describe('PublicationApi', () => {
  it('fetchPublicationData calls correct endpoint', async () => {
    // GIVEN: Mock axios
    const mockGet = jest.spyOn(axios, 'get').mockResolvedValue({
      data: {
        success: true,
        data: mockPublicationData
      }
    });

    // WHEN
    const result = await fetchPublicationData({ department: 'all' });

    // THEN
    expect(mockGet).toHaveBeenCalledWith(
      '/api/dashboard/publications/',
      { params: { department: 'all' } }
    );
    expect(result).toEqual(mockPublicationData);
  });

  it('handles API error correctly', async () => {
    // GIVEN: API 에러
    jest.spyOn(axios, 'get').mockRejectedValue(new Error('Network error'));

    // WHEN/THEN
    await expect(fetchPublicationData({})).rejects.toThrow('Network error');
  });
});
```

**Dependencies:** axios

---

#### Module 8: usePublicationData Hook

**Location:** `frontend/src/hooks/usePublicationData.ts`

**Test Strategy:** Unit Tests (React Testing Library)

```typescript
// tests/usePublicationData.test.ts

describe('usePublicationData', () => {
  it('fetches data on mount', async () => {
    // GIVEN: Mock API
    const mockFetch = jest.fn().mockResolvedValue(mockPublicationData);

    // WHEN
    const { result, waitForNextUpdate } = renderHook(() =>
      usePublicationData({ department: 'all' })
    );

    // THEN: 초기 로딩 상태
    expect(result.current.isLoading).toBe(true);

    await waitForNextUpdate();

    // THEN: 데이터 로드 완료
    expect(result.current.isLoading).toBe(false);
    expect(result.current.data).toEqual(mockPublicationData);
  });

  it('updates data when filters change', async () => {
    // GIVEN
    const { result, rerender } = renderHook(
      ({ filters }) => usePublicationData(filters),
      { initialProps: { filters: { department: 'all' } } }
    );

    // WHEN: 필터 변경
    rerender({ filters: { department: '컴퓨터공학과' } });

    // THEN: API 재호출
    expect(mockFetch).toHaveBeenCalledWith({ department: '컴퓨터공학과' });
  });

  it('sets error state on API failure', async () => {
    // GIVEN: API 에러
    jest.spyOn(api, 'fetchPublicationData').mockRejectedValue(new Error('Failed'));

    // WHEN
    const { result, waitForNextUpdate } = renderHook(() => usePublicationData({}));
    await waitForNextUpdate();

    // THEN
    expect(result.current.error).toBeTruthy();
    expect(result.current.data).toBeNull();
  });
});
```

**Dependencies:** Publication API Client

---

#### Module 9: PublicationDoughnutChart Component

**Location:** `frontend/src/components/dashboard/PublicationDoughnutChart.tsx`

**Test Strategy:** Unit Tests (Jest + React Testing Library)

```typescript
// tests/PublicationDoughnutChart.test.tsx

describe('PublicationDoughnutChart', () => {
  it('renders chart with correct data', () => {
    // GIVEN
    const mockData: PublicationDistributionItem[] = [
      { journal_tier: 'SCIE', count: 89, percentage: 57.1, avg_if: 3.2 },
      { journal_tier: 'KCI', count: 67, percentage: 42.9, avg_if: 1.1 }
    ];

    // WHEN
    render(<PublicationDoughnutChart data={mockData} totalPapers={156} />);

    // THEN: 중앙 텍스트 표시
    expect(screen.getByText('총 156편')).toBeInTheDocument();

    // 범례 표시
    expect(screen.getByText('SCIE')).toBeInTheDocument();
    expect(screen.getByText('KCI')).toBeInTheDocument();
  });

  it('displays empty state when no data', () => {
    // WHEN
    render(<PublicationDoughnutChart data={[]} totalPapers={0} />);

    // THEN
    expect(screen.getByText(/논문 데이터가 없습니다/i)).toBeInTheDocument();
  });

  it('shows tooltip on hover', async () => {
    // GIVEN
    const mockData = [
      { journal_tier: 'SCIE', count: 89, percentage: 57.1, avg_if: 3.2 }
    ];

    render(<PublicationDoughnutChart data={mockData} totalPapers={89} />);

    // WHEN: 차트 섹션 호버
    const scieSection = screen.getByRole('graphics-symbol', { name: /SCIE/i });
    fireEvent.mouseEnter(scieSection);

    // THEN: Tooltip 표시
    await waitFor(() => {
      expect(screen.getByText(/평균 IF: 3.2/i)).toBeInTheDocument();
    });
  });

  it('displays single tier as 100% doughnut', () => {
    // GIVEN: SCIE만 존재
    const mockData = [
      { journal_tier: 'SCIE', count: 50, percentage: 100.0, avg_if: 3.0 }
    ];

    // WHEN
    render(<PublicationDoughnutChart data={mockData} totalPapers={50} />);

    // THEN: 100% 표시
    expect(screen.getByText('100%')).toBeInTheDocument();
  });
});
```

**Dependencies:** Recharts, usePublicationData Hook

---

#### Module 10: PublicationMetricCards Component

**Location:** `frontend/src/components/dashboard/PublicationMetricCards.tsx`

**Test Strategy:** Unit Tests

```typescript
// tests/PublicationMetricCards.test.tsx

describe('PublicationMetricCards', () => {
  it('displays total papers count', () => {
    // WHEN
    render(<PublicationMetricCards totalPapers={156} avgImpactFactor={2.3} />);

    // THEN
    expect(screen.getByText('총 논문 수')).toBeInTheDocument();
    expect(screen.getByText('156편')).toBeInTheDocument();
  });

  it('displays average impact factor', () => {
    // WHEN
    render(<PublicationMetricCards totalPapers={156} avgImpactFactor={2.3} />);

    // THEN
    expect(screen.getByText('평균 Impact Factor')).toBeInTheDocument();
    expect(screen.getByText('2.3')).toBeInTheDocument();
  });

  it('shows "정보 없음" when avg IF is null', () => {
    // WHEN
    render(<PublicationMetricCards totalPapers={10} avgImpactFactor={null} />);

    // THEN
    expect(screen.getByText('정보 없음')).toBeInTheDocument();
  });
});
```

**Dependencies:** None (Presentational Component)

---

## 4. TDD Workflow

### 4.1 시작: Red Phase

**첫 번째 테스트 시나리오 (가장 기본적인 기능)**

```python
# tests/test_models.py
def test_create_publication_with_valid_data(self):
    """유효한 데이터로 Publication 생성 시 성공"""
    publication = Publication(
        paper_id='P001',
        department='컴퓨터공학과',
        journal_tier='SCIE',
        impact_factor=3.5
    )
    publication.save()

    saved = Publication.objects.get(paper_id='P001')
    self.assertEqual(saved.journal_tier, 'SCIE')
```

**실행:** `python manage.py test tests.test_models.PublicationModelTestCase.test_create_publication_with_valid_data`

**결과:** FAILED (Model 아직 구현 안 됨)

---

### 4.2 Green Phase

**최소 구현 (테스트 통과시키기)**

```python
# backend/data_ingestion/infrastructure/models.py

from django.db import models

class Publication(models.Model):
    JOURNAL_TIER_CHOICES = [
        ('SCIE', 'SCIE'),
        ('KCI', 'KCI'),
        ('기타', '기타'),
    ]

    paper_id = models.CharField(max_length=50, primary_key=True)
    department = models.CharField(max_length=100)
    journal_tier = models.CharField(max_length=20, choices=JOURNAL_TIER_CHOICES)
    impact_factor = models.FloatField(null=True, blank=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        db_table = 'publications'

    def __str__(self):
        return f"{self.paper_id} ({self.journal_tier})"
```

**실행:** 테스트 통과 확인

---

### 4.3 Refactor Phase

**코드 개선 (테스트는 여전히 통과)**

```python
# 인덱스 추가, Meta 옵션 정리

class Publication(models.Model):
    # ... (필드 동일)

    class Meta:
        db_table = 'publications'
        verbose_name = '논문'
        verbose_name_plural = '논문 목록'
        ordering = ['-created_at']
        indexes = [
            models.Index(fields=['department'], name='idx_pub_dept'),
            models.Index(fields=['journal_tier'], name='idx_pub_tier'),
        ]
```

**실행:** 모든 테스트 여전히 통과

---

### 4.4 순차적 구현 (모듈별)

**구현 순서:**

1. **Backend (Inside-Out 전략)**
   - Model → Repository → Service → View → Serializer
   - 각 모듈마다 Red-Green-Refactor 사이클 반복

2. **Frontend (Outside-In 전략)**
   - Types → API Client → Hook → Components
   - Mock 데이터로 UI 먼저 구현 후 실제 API 연동

---

### 4.5 Commit 포인트 제안

**Small Commits (각 Green Phase 완료 시)**

1. `feat(backend): Add Publication model with tests`
2. `feat(backend): Implement PublicationRepository with filtering tests`
3. `feat(backend): Add PublicationService business logic and tests`
4. `feat(backend): Implement Publication API endpoint with integration tests`
5. `feat(frontend): Add Publication TypeScript types`
6. `feat(frontend): Implement Publication API client with tests`
7. `feat(frontend): Add usePublicationData hook with tests`
8. `feat(frontend): Implement PublicationDoughnutChart component with tests`
9. `feat(frontend): Add PublicationMetricCards component with tests`
10. `test(e2e): Add Publication dashboard E2E tests`

---

### 4.6 완료 조건

**Definition of Done:**

- [ ] 모든 Unit Tests 통과 (70% 이상 커버리지)
- [ ] Integration Tests 통과 (API 엔드포인트)
- [ ] E2E Acceptance Tests 통과 (Playwright)
- [ ] Refactoring 완료 (중복 코드 제거, 네이밍 정리)
- [ ] Code Review 완료
- [ ] 문서 업데이트 (API 스펙, 컴포넌트 README)

---

## 5. QA Sheet (Presentation Layer)

### 5.1 Manual Test Scenarios

#### Scenario 1: 기본 데이터 로드
- [ ] 브라우저에서 대시보드 접속
- [ ] 논문 실적 Doughnut Chart 렌더링 확인
- [ ] Metric Card에 총 논문 수, 평균 IF 표시 확인
- [ ] 차트 색상이 SCIE(진한 파랑), KCI(연한 파랑)로 표시됨

#### Scenario 2: 학과 필터링
- [ ] 학과 드롭다운에서 "컴퓨터공학과" 선택
- [ ] 차트가 해당 학과 데이터로 업데이트됨
- [ ] Metric Card 수치 변경 확인
- [ ] "전체 보기" 버튼 클릭 시 초기화

#### Scenario 3: Tooltip 인터랙션
- [ ] 마우스를 SCIE 섹션에 올림
- [ ] Tooltip에 "SCIE: XX편 (YY%), 평균 IF: ZZ" 표시
- [ ] 다른 섹션으로 이동 시 Tooltip 업데이트

#### Scenario 4: Empty State
- [ ] DB에서 논문 데이터 전체 삭제 (또는 필터 결과 없음)
- [ ] "논문 데이터가 없습니다" 메시지 표시
- [ ] "전체 보기" 버튼 안내

#### Scenario 5: Error Handling
- [ ] 백엔드 서버 중단
- [ ] "데이터를 불러올 수 없습니다" 에러 카드 표시
- [ ] "새로고침" 버튼 동작 확인

#### Scenario 6: Performance
- [ ] 10,000건 이상 논문 데이터 로드
- [ ] 차트 렌더링 시간 1초 이내 확인
- [ ] 필터 변경 후 리렌더링 300ms 이내

---

## 6. 보안 요구사항

### 6.1 API 인증
- **관리자 API Key 검증:** DRF 미들웨어에서 `X-Admin-Key` 헤더 검증
- **환경 변수 기반:** `ADMIN_API_KEY` 환경 변수 사용 (코드에 하드코딩 금지)

### 6.2 입력 검증
- **화이트리스트 기반:** 학과명, 저널등급 허용 목록 검증
- **SQL Injection 방어:** Django ORM 사용 (Parameterized Queries)
- **최대 길이 검증:** 학과명 100자, 논문ID 50자 제한

**Test Scenarios:**
```python
def test_xss_prevention_in_department_filter():
    """학과 필터에 XSS 시도 시 차단"""
    response = self.client.get('/api/dashboard/publications/?department=<script>alert("XSS")</script>')
    assert response.status_code == 400
    assert 'ERR_PUB_001' in response.json()['error']

def test_sql_injection_prevention():
    """SQL Injection 시도 차단"""
    response = self.client.get('/api/dashboard/publications/?department=\'; DROP TABLE publications; --')
    assert response.status_code == 400
```

### 6.3 XSS 방어
- **React 기본 이스케이프:** JSX 렌더링 시 자동 이스케이프 활용
- **dangerouslySetInnerHTML 금지:** 사용자 입력 직접 렌더링 금지
- **DRF Serializer 이스케이프:** JSON 응답 자동 이스케이프

### 6.4 CSRF 방어
- **Django CSRF 미들웨어:** `django.middleware.csrf.CsrfViewMiddleware` 활성화
- **DRF 기본 설정:** API 엔드포인트는 CSRF 토큰 검증 (설정 확인 필요)

---

## 7. 에러 코드 명세

### 7.1 표준 에러 응답 형식

모든 에러는 다음 JSON 구조로 반환:

```json
{
  "error": "ERR_PUB_XXX",
  "message": "사용자 친화적 에러 메시지 (한글)",
  "details": "상세 정보 (선택적)",
  "timestamp": "2025-11-02T14:35:22Z"
}
```

### 7.2 에러 코드 매핑

| HTTP Status | Error Code | 발생 상황 | 메시지 예시 | 프론트엔드 처리 |
|-------------|------------|----------|-----------|--------------|
| 400 | ERR_PUB_001 | 잘못된 학과명 입력 | "유효하지 않은 학과명입니다" | 필터 초기화 버튼 표시 |
| 400 | ERR_PUB_002 | 잘못된 저널등급 입력 | "허용되지 않은 저널등급입니다" | 허용값 안내 (SCIE, KCI, 기타) |
| 400 | ERR_PUB_003 | 필수 파라미터 누락 | "필수 파라미터가 누락되었습니다" | 요청 재시도 |
| 404 | ERR_PUB_004 | 조건에 해당하는 데이터 없음 | "조건에 맞는 논문 데이터가 없습니다" | Empty State 표시 + 필터 초기화 안내 |
| 500 | ERR_PUB_500 | 서버 내부 오류 | "서버 오류가 발생했습니다" | "잠시 후 다시 시도하세요" 안내 |

### 7.3 에러 처리 테스트 시나리오

```python
# tests/test_api_errors.py

def test_error_response_structure():
    """에러 응답이 표준 구조를 따르는지 검증"""
    response = self.client.get('/api/dashboard/publications/?journal_tier=INVALID')

    assert response.status_code == 400
    data = response.json()
    assert 'error' in data
    assert 'message' in data
    assert 'timestamp' in data
    assert data['error'] == 'ERR_PUB_002'

def test_all_error_codes_have_korean_messages():
    """모든 에러 코드가 한글 메시지를 가지는지 검증"""
    error_codes = ['ERR_PUB_001', 'ERR_PUB_002', 'ERR_PUB_003', 'ERR_PUB_004', 'ERR_PUB_500']

    for code in error_codes:
        message = ERROR_MESSAGES.get(code)
        assert message is not None
        assert any(ord(char) >= 0xAC00 and ord(char) <= 0xD7A3 for char in message)  # 한글 포함 검증
```

---

## 8. 프론트엔드 에러 표시 UI

### 8.1 ErrorBoundary Component

**Location:** `frontend/src/components/ui/ErrorBoundary.tsx`

**Responsibility:**
- React 컴포넌트 렌더링 에러 캐치
- 사용자 친화적 폴백 UI 표시
- 에러 로그 기록 (POST-MVP: Sentry 연동)

**Test Scenarios:**
```typescript
describe('ErrorBoundary', () => {
  it('catches rendering errors and shows fallback UI', () => {
    const ThrowError = () => { throw new Error('Test error'); };

    render(
      <ErrorBoundary>
        <ThrowError />
      </ErrorBoundary>
    );

    expect(screen.getByText('문제가 발생했습니다')).toBeInTheDocument();
    expect(screen.getByText('새로고침')).toBeInTheDocument();
  });
});
```

### 8.2 ChartErrorCard Component

**Location:** `frontend/src/components/dashboard/ChartErrorCard.tsx`

**Responsibility:**
- 차트 로딩 실패 시 에러 카드 표시
- 재시도 버튼 제공
- 에러 타입별 아이콘 및 안내 메시지

**Props:**
```typescript
interface ChartErrorCardProps {
  errorCode: string;  // 'ERR_PUB_001', 'ERR_PUB_004' 등
  message: string;
  onRetry: () => void;
}
```

**Test Scenarios:**
```typescript
describe('ChartErrorCard', () => {
  it('displays error message with retry button', () => {
    const mockRetry = jest.fn();

    render(
      <ChartErrorCard
        errorCode="ERR_PUB_004"
        message="조건에 맞는 논문 데이터가 없습니다"
        onRetry={mockRetry}
      />
    );

    expect(screen.getByText('조건에 맞는 논문 데이터가 없습니다')).toBeInTheDocument();

    const retryButton = screen.getByText('다시 시도');
    fireEvent.click(retryButton);

    expect(mockRetry).toHaveBeenCalled();
  });
});
```

### 8.3 ErrorToast Component

**Location:** `frontend/src/components/ui/ErrorToast.tsx`

**Responsibility:**
- 일시적 에러 메시지 토스트 표시
- 3초 후 자동 사라짐
- 우측 상단 슬라이드 인 애니메이션

**Usage:**
```typescript
// hooks/usePublicationData.ts
import { showErrorToast } from '../components/ui/ErrorToast';

const fetchData = async () => {
  try {
    // API 호출
  } catch (error) {
    if (error.response?.status === 400) {
      showErrorToast(error.response.data.message);
    } else {
      showErrorToast('네트워크 오류가 발생했습니다');
    }
  }
};
```

---

## 9. 핵심 원칙 준수 체크리스트

### TDD Principles
- [x] **Test First:** 모든 모듈에 대해 테스트 먼저 작성
- [x] **Small Steps:** 한 번에 하나의 시나리오만 구현
- [x] **Red-Green-Refactor:** 각 사이클 명확히 구분
- [x] **FIRST:** Fast, Independent, Repeatable, Self-validating, Timely

### Test Pyramid
- [x] **Unit Tests 70%:** Service, Repository, Hook, Component
- [x] **Integration Tests 20%:** API Endpoint (View ↔ Service ↔ Repository)
- [x] **Acceptance Tests 10%:** E2E Playwright

### MVP Constraints
- [x] **간결한 구조:** 불필요한 추상화 배제 (Repository에 인터페이스 없음)
- [x] **당장 필요한 것만:** 복잡한 차트 인터랙션 제외 (기본 Tooltip만)
- [x] **쉬운 인프라:** Django ORM 직접 사용, Recharts 기본 설정

### Security Requirements
- [x] **API 인증:** X-Admin-Key 헤더 검증
- [x] **입력 검증:** 화이트리스트 기반, 최대 길이 검증
- [x] **XSS 방어:** React 이스케이프, dangerouslySetInnerHTML 금지
- [x] **CSRF 방어:** Django CSRF 미들웨어 활성화

---

## 10. Risk & Mitigation

### Risk 1: Recharts 렌더링 성능 이슈
- **완화 방안:** React.memo로 불필요한 리렌더링 방지, 데이터 1000건 이하로 제한

### Risk 2: NULL Impact Factor 처리 누락
- **완화 방안:** Service Layer에서 명시적 NULL 처리 테스트, 프론트엔드에서도 검증

### Risk 3: 비율 계산 반올림 오차
- **완화 방안:** 소수점 1자리로 반올림, 합계 99.9~100.1% 허용 범위 설정

---

## 문서 승인 및 검토

**작성자:** Plan Writer Agent
**검토자:** CTO
**승인일:** 2025-11-02
**현재 버전:** 1.0

본 구현 계획은 **TDD 원칙(Red-Green-Refactor)**을 엄격히 준수하며, Test Pyramid (Unit 70%, Integration 20%, Acceptance 10%)를 기반으로 작성되었습니다. MVP 범위에 맞춰 간결하면서도 확장 가능한 구조를 유지하고, 오버엔지니어링을 철저히 배제합니다.

---

**문서 끝**
</file>

<file path="004-publication-dashboard/spec.md">
# 논문 실적 대시보드 상세 유스케이스 명세

**기능명:** 논문 실적 시각화 (P0-MVP)
**기능 ID:** 004
**작성일:** 2025-11-02
**최종 수정일:** 2025-11-02
**작성자:** Spec Writer Agent
**수정자:** Claude Code
**버전:** 2.0 (High Priority 개선사항 적용 완료)
**우선순위:** P0-MVP (첫 베타테스트 필수)

**변경 이력 (v2.0):**
- Django Model 스키마 정의 추가 (섹션 5)
- Service Layer 아키텍처 명시 (섹션 6)
- Pandas 사용 범위 명확화 - 참고용으로 변경
- 보안 요구사항 섹션 추가 (섹션 10)
- 에러 코드 체계 표준화 (ERR_PUB_XXX 형식)

---

## 1. 기능 개요

### 1.1 목적
대학교 내부 직원이 논문 게재 실적을 저널 등급별로 시각적으로 파악하고, 평균 Impact Factor를 통해 연구 성과의 질적 수준을 빠르게 이해할 수 있도록 지원한다.

### 1.2 범위
- Doughnut Chart를 통한 저널 등급별 논문 비율 시각화
- Metric Card를 통한 총 논문 수 및 평균 Impact Factor 표시
- 학과별/저널등급별 필터링 지원
- Recharts 라이브러리 사용 (PieChart with innerRadius)

### 1.3 데이터 소스
- **파일:** `publication_list.csv`
- **DB 테이블:** `publications`
- **필수 컬럼:** 논문ID, 학과, 저널등급, Impact Factor

### 1.4 기대 효과
- 연구 성과의 질적 지표(저널 등급, IF)를 한눈에 파악
- 학과별 논문 실적 비교 및 의사결정 지원
- 데이터 기반 연구 전략 수립

---

## 2. 사용자 스토리 (GIVEN-WHEN-THEN)

### 2.1 기본 시나리오
```gherkin
GIVEN 사용자가 메인 대시보드에 접속했을 때
WHEN 논문 실적 섹션을 조회하면
THEN 저널 등급별(SCIE, KCI) 논문 비율이 Doughnut Chart로 표시되고
AND 총 논문 수와 평균 Impact Factor가 Metric Card에 표시된다
```

### 2.2 학과별 필터링 시나리오
```gherkin
GIVEN 사용자가 논문 실적 차트를 보고 있을 때
WHEN 학과 필터 드롭다운에서 "컴퓨터공학과"를 선택하면
THEN 해당 학과의 논문 데이터만 집계되어 차트가 업데이트되고
AND Metric Card의 평균 IF는 해당 학과의 IF만으로 재계산된다
```

### 2.3 저널등급별 필터링 시나리오
```gherkin
GIVEN 사용자가 특정 저널 등급의 논문만 보고 싶을 때
WHEN 저널등급 필터에서 "SCIE"를 선택하면
THEN SCIE 논문만 차트에 표시되고
AND 평균 IF는 SCIE 논문의 IF만으로 계산된다
```

### 2.4 차트 호버 상호작용
```gherkin
GIVEN 사용자가 Doughnut Chart를 보고 있을 때
WHEN 마우스를 SCIE 섹션에 올리면
THEN Tooltip에 "SCIE: 89편 (57.1%), 평균 IF: 3.2"가 표시된다
```

---

## 3. 상세 유스케이스

### Primary Actor
- 내부 직원 (관리자 및 일반 사용자)

### Precondition
- 관리자가 `publication_list.csv` 파일을 업로드하여 DB에 논문 데이터가 존재함
- 사용자가 메인 대시보드(`/dashboard`)에 접근할 수 있음

### Trigger
- 사용자가 브라우저에서 메인 대시보드 URL 접속
- 또는 데이터 업로드 완료 후 "대시보드 보기" 버튼 클릭

### Main Scenario (정상 흐름)

#### Step 1: 초기 데이터 로드
1. 사용자가 메인 대시보드 페이지 접속
2. React 앱이 `GET /api/dashboard/publications/` API 호출
3. 백엔드(DRF)가 PostgreSQL에서 다음 쿼리 실행:
   ```sql
   SELECT
       journal_tier,
       COUNT(*) AS paper_count,
       ROUND(COUNT(*) * 100.0 / SUM(COUNT(*)) OVER (), 1) AS percentage,
       AVG(impact_factor) AS avg_if
   FROM publications
   GROUP BY journal_tier;
   ```
4. 집계된 데이터를 JSON으로 반환:
   ```json
   {
     "total_papers": 156,
     "avg_impact_factor": 2.3,
     "distribution": [
       {
         "journal_tier": "SCIE",
         "count": 89,
         "percentage": 57.1,
         "avg_if": 3.2
       },
       {
         "journal_tier": "KCI",
         "count": 67,
         "percentage": 42.9,
         "avg_if": 1.1
       }
     ]
   }
   ```
5. 프런트엔드가 데이터를 Recharts PieChart 컴포넌트에 바인딩
6. Doughnut Chart 렌더링 (innerRadius 설정으로 중앙 공백)

#### Step 2: 시각화 요소 표시
- **Doughnut Chart:**
  - SCIE: 진한 파랑 (#1E40AF)
  - KCI: 연한 파랑 (#60A5FA)
  - 섹션 크기는 논문 수 비율에 따라 자동 계산
  - 중앙에 "총 156편" 텍스트 표시

- **상단 Metric Card (2개):**
  - Card 1: "총 논문 수: 156편"
  - Card 2: "평균 Impact Factor: 2.3"

- **범례 (Legend):**
  - SCIE, KCI 구분 표시
  - 각 항목 옆에 논문 수 표시

#### Step 3: 차트 인터랙션 (Tooltip)
1. 사용자가 마우스 커서를 SCIE 섹션에 올림
2. Recharts Tooltip 컴포넌트가 활성화됨
3. Tooltip 내용 표시:
   ```
   저널 등급: SCIE
   논문 수: 89편 (57.1%)
   평균 IF: 3.2
   ```
4. 커서 이동 시 다른 섹션의 Tooltip 표시
5. 차트 밖으로 커서가 나가면 Tooltip 사라짐

#### Step 4: 필터링 (학과별)
1. 사용자가 학과 필터 드롭다운에서 "컴퓨터공학과" 선택
2. React State 업데이트
3. `GET /api/dashboard/publications/?department=컴퓨터공학과` API 재호출
4. 백엔드에서 WHERE 절 추가된 쿼리 실행:
   ```sql
   SELECT
       journal_tier,
       COUNT(*) AS paper_count,
       ROUND(COUNT(*) * 100.0 / SUM(COUNT(*)) OVER (), 1) AS percentage,
       AVG(impact_factor) AS avg_if
   FROM publications
   WHERE department = '컴퓨터공학과'
   GROUP BY journal_tier;
   ```
5. 필터링된 데이터로 차트 리렌더링
6. Metric Card도 업데이트 (해당 학과 데이터만 반영)

#### Step 5: 필터 초기화
1. 사용자가 "전체 보기" 버튼 클릭
2. 필터 상태를 기본값으로 리셋
3. 전체 데이터로 API 재호출 및 차트 업데이트

### Edge Cases (엣지케이스 및 오류 처리)

#### EC1: 단일 저널 등급만 존재
- **상황:** DB에 SCIE 논문만 있고 KCI 논문은 없음
- **처리:** 전체 도넛이 하나의 색상(SCIE 파랑)으로 표시
- **UI 피드백:** Tooltip에 "100%" 표시, 범례에도 SCIE만 표시

#### EC2: Impact Factor 없는 논문이 전부인 경우
- **상황:** 모든 논문의 `impact_factor` 컬럼이 NULL
- **처리:** 평균 IF 계산에서 제외
- **UI 피드백:** Metric Card에 "평균 Impact Factor: 정보 없음" 표시
- **백엔드 로직:**
  ```sql
  SELECT
      AVG(impact_factor) AS avg_if,
      COUNT(*) FILTER (WHERE impact_factor IS NOT NULL) AS papers_with_if
  FROM publications;
  -- papers_with_if = 0이면 NULL 반환
  ```

#### EC3: 필터 결과가 없음
- **상황:** 선택한 학과에 논문 데이터가 없음
- **처리:** 빈 상태(Empty State) UI 표시
- **UI 피드백:**
  - 차트 영역에 "선택한 학과의 논문 데이터가 없습니다." 메시지
  - "다른 학과를 선택하거나 전체 보기를 클릭하세요" 안내
  - "전체 보기" 버튼 강조

#### EC4: API 호출 실패 (네트워크/서버 에러)
- **상황:** 백엔드 서버 다운 또는 네트워크 타임아웃
- **처리:**
  - HTTP 요청 실패 감지
  - 최대 1회 자동 재시도
  - 재시도 실패 시 에러 UI 표시
- **UI 피드백:**
  - 에러 카드: "논문 데이터를 불러오는 중 문제가 발생했습니다."
  - "새로고침" 버튼 제공
  - 다른 차트(연구비, 학생 등)는 정상 표시 (독립적 처리)

#### EC5: 데이터 로딩 지연
- **상황:** API 응답이 3초 이상 지연
- **처리:**
  - 스켈레톤 UI 표시 (차트 영역에 회색 플레이스홀더)
  - 타임아웃 30초 설정
- **UI 피드백:**
  - 30초 초과 시 "데이터 로딩이 지연되고 있습니다. 잠시 후 다시 시도하세요." 경고

#### EC6: 차트 렌더링 실패
- **상황:** Recharts 라이브러리 예외 발생
- **처리:**
  - React Error Boundary로 예외 캐치
  - 에러 로그 기록
- **UI 피드백:**
  - "차트를 표시할 수 없습니다. 페이지를 새로고침하세요." 메시지
  - "새로고침" 버튼

### Business Rules (비즈니스 규칙)

#### BR1: 평균 Impact Factor 계산 규칙
- IF가 NULL인 논문은 평균 계산에서 제외
- 계산식: `AVG(impact_factor WHERE impact_factor IS NOT NULL)`
- IF 정보가 있는 논문 수도 함께 표시 (예: "평균 IF: 2.3 (89편 중 78편)")

#### BR2: 저널 등급 카테고리
- 허용된 저널 등급: `SCIE`, `KCI`, `기타`
- CSV 파일에서 다른 값이 들어오면 Pandas 파싱 단계에서 검증
- 미정의 등급은 "기타"로 자동 분류

#### BR3: 비율 계산 및 표시
- 백분율은 소수점 1자리까지 표시 (예: 57.1%)
- 합계는 반올림 오차를 고려하여 99.9~100.1% 허용

#### BR4: 필터링 우선순위
- 학과 필터와 저널등급 필터가 동시 적용되면 AND 조건 처리
- 예: "컴퓨터공학과 + SCIE"를 선택하면 해당 학과의 SCIE 논문만 조회

#### BR5: 데이터 갱신 정책
- 관리자가 `publication_list.csv` 재업로드 시 기존 데이터 전체 교체
- 실시간 업데이트 아님 (수동 새로고침 필요)
- 최종 업데이트 시간 표시 (예: "마지막 업데이트: 2025-11-02 14:35")

---

## 4. API 명세

### 4.1 논문 실적 데이터 조회

**엔드포인트:** `GET /api/dashboard/publications/`

**Request Headers:**
- `Content-Type: application/json`

**Query Parameters:**
| 파라미터 | 타입 | 필수 | 기본값 | 설명 |
|---------|------|------|--------|------|
| department | string | No | all | 학과 필터 (예: "컴퓨터공학과", "all") |
| journal_tier | string | No | all | 저널등급 필터 (예: "SCIE", "KCI", "all") |
| year | integer | No | latest | 연도 필터 (추후 구현) |

**Response (200 OK):**
```json
{
  "success": true,
  "data": {
    "total_papers": 156,
    "avg_impact_factor": 2.3,
    "papers_with_if": 145,
    "distribution": [
      {
        "journal_tier": "SCIE",
        "count": 89,
        "percentage": 57.1,
        "avg_if": 3.2
      },
      {
        "journal_tier": "KCI",
        "count": 67,
        "percentage": 42.9,
        "avg_if": 1.1
      }
    ],
    "last_updated": "2025-11-02T14:35:22Z"
  }
}
```

**Error Responses:**

- **400 Bad Request:** 잘못된 학과명 필터
  ```json
  {
    "success": false,
    "error": "ERR_PUB_001",
    "message": "잘못된 학과명입니다. 유효한 학과를 선택하세요.",
    "field": "department"
  }
  ```

- **400 Bad Request:** 잘못된 저널등급 필터
  ```json
  {
    "success": false,
    "error": "ERR_PUB_002",
    "message": "잘못된 저널등급입니다. ('SCIE', 'KCI', '기타', 'all' 중 선택)",
    "field": "journal_tier"
  }
  ```

- **404 Not Found:** 데이터 없음
  ```json
  {
    "success": false,
    "error": "ERR_PUB_003",
    "message": "논문 데이터가 없습니다. 관리자가 데이터를 업로드하면 표시됩니다."
  }
  ```

- **500 Internal Server Error:** DB 조회 실패
  ```json
  {
    "success": false,
    "error": "ERR_PUB_004",
    "message": "서버 오류가 발생했습니다. 잠시 후 다시 시도하세요.",
    "details": "Database connection timeout"
  }
  ```

### 4.2 에러 코드 체계

| 에러 코드 | HTTP Status | 설명 | 발생 조건 |
|---------|------------|------|---------|
| ERR_PUB_001 | 400 | 잘못된 학과명 | 존재하지 않는 학과 입력 |
| ERR_PUB_002 | 400 | 잘못된 저널등급 | 허용되지 않는 저널등급 값 |
| ERR_PUB_003 | 404 | 데이터 없음 | DB에 논문 데이터 없음 |
| ERR_PUB_004 | 500 | DB 조회 실패 | 데이터베이스 연결 오류 |
| ERR_PUB_005 | 500 | 차트 렌더링 실패 | 프런트엔드 Recharts 예외 |

---

## 5. 데이터 모델

### 5.1 Publication 모델

**Django 모델 정의:**

```python
# backend/data_ingestion/infrastructure/models.py

class Publication(models.Model):
    """논문 게재 실적 모델"""

    JOURNAL_TIER_CHOICES = [
        ('SCIE', 'SCIE'),
        ('KCI', 'KCI'),
        ('기타', '기타'),
    ]

    paper_id = models.CharField(
        max_length=50,
        primary_key=True,
        verbose_name='논문ID',
        help_text='CSV의 "논문ID" 칼럼과 매핑'
    )
    department = models.CharField(
        max_length=100,
        db_index=True,
        verbose_name='학과',
        help_text='CSV의 "학과" 칼럼과 매핑'
    )
    journal_tier = models.CharField(
        max_length=20,
        choices=JOURNAL_TIER_CHOICES,
        db_index=True,
        verbose_name='저널등급',
        help_text='CSV의 "저널등급" 칼럼과 매핑 (SCIE/KCI/기타)'
    )
    impact_factor = models.FloatField(
        null=True,
        blank=True,
        verbose_name='Impact Factor',
        help_text='CSV의 "Impact Factor" 칼럼과 매핑 (NULL 허용)'
    )
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        db_table = 'publications'
        verbose_name = '논문'
        verbose_name_plural = '논문 목록'
        ordering = ['-created_at']
        indexes = [
            models.Index(fields=['department'], name='idx_pub_dept'),
            models.Index(fields=['journal_tier'], name='idx_pub_tier'),
        ]

    def __str__(self):
        return f"{self.paper_id} ({self.journal_tier})"
```

### 5.2 CSV 칼럼 매핑

| CSV 칼럼 | Django Model Field | 데이터 타입 | 필수 여부 | 비고 |
|---------|-------------------|----------|---------|------|
| 논문ID | paper_id | CharField(50) | 필수 | Primary Key |
| 학과 | department | CharField(100) | 필수 | 학과별 필터링에 사용 |
| 저널등급 | journal_tier | CharField(20) | 필수 | SCIE/KCI/기타 중 하나 |
| Impact Factor | impact_factor | FloatField | 선택 | NULL 허용, 평균 계산 시 NULL 제외 |

### 5.3 데이터 제약 조건

- `paper_id`: UNIQUE, NOT NULL
- `department`: NOT NULL
- `journal_tier`: NOT NULL, CHECK IN ('SCIE', 'KCI', '기타')
- `impact_factor`: NULL 허용 (일부 저널은 IF 없음)

### 5.4 저널등급 정규화 규칙

CSV 파일 파싱 시 다음 규칙 적용 (`excel_parser.py`에서 처리):

```python
# 저널등급 정규화 매핑
JOURNAL_TIER_MAPPING = {
    'SCIE': 'SCIE',
    'SCI': 'SCIE',
    'SCI-E': 'SCIE',
    'KCI': 'KCI',
    '한국연구재단': 'KCI',
}

def normalize_journal_tier(raw_value):
    """CSV의 저널등급 값을 정규화"""
    if not raw_value or pd.isna(raw_value):
        return '기타'

    normalized = raw_value.strip().upper()
    return JOURNAL_TIER_MAPPING.get(normalized, '기타')
```

---

## 6. 백엔드 아키텍처 구현 (Layered Architecture)

### 6.1 레이어별 책임 (CLAUDE.md 준수)

#### Presentation Layer: `api/views.py`

```python
# backend/data_ingestion/api/views.py
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status
from django.core.exceptions import ValidationError
from .serializers import PublicationDashboardSerializer
from ..services.publication_service import PublicationService

class PublicationDashboardView(APIView):
    """논문 실적 API (Thin Controller)"""

    def get(self, request):
        # 1. Query Parameter 추출
        department = request.query_params.get('department', 'all')
        journal_tier = request.query_params.get('journal_tier', 'all')

        # 2. Service Layer 호출
        service = PublicationService()
        try:
            data = service.get_distribution(
                department=department,
                journal_tier=journal_tier
            )
        except ValidationError as e:
            return Response({
                'success': False,
                'error': 'ERR_PUB_001',
                'message': str(e)
            }, status=status.HTTP_400_BAD_REQUEST)

        # 3. 직렬화 및 응답
        return Response({
            'success': True,
            'data': data
        }, status=status.HTTP_200_OK)
```

#### Service Layer: `services/publication_service.py`

```python
# backend/data_ingestion/services/publication_service.py
from django.db.models import Count, Avg, Q, F, FloatField
from django.db.models.functions import Cast
from django.utils import timezone
from django.core.exceptions import ValidationError
from ..infrastructure.repositories import PublicationRepository

class PublicationService:
    """논문 실적 데이터 집계 서비스 (SRP: 비즈니스 로직만 담당)"""

    ALLOWED_TIERS = ['all', 'SCIE', 'KCI', '기타']

    def __init__(self):
        self.publication_repo = PublicationRepository()

    def get_distribution(self, department='all', journal_tier='all'):
        """저널 등급별 논문 분포 집계"""
        # 1. 입력 검증
        self._validate_inputs(department, journal_tier)

        # 2. Repository를 통한 데이터 조회
        queryset = self.publication_repo.get_publications_by_filter(
            department=department,
            journal_tier=journal_tier
        )

        # 3. 집계 로직 (비즈니스 규칙 적용)
        distribution = self._aggregate_by_tier(queryset)
        total_papers = queryset.count()
        avg_if, papers_with_if = self._calculate_avg_impact_factor(queryset)

        # 4. 응답 데이터 구조화
        return {
            'total_papers': total_papers,
            'avg_impact_factor': round(avg_if, 2) if avg_if else None,
            'papers_with_if': papers_with_if,
            'distribution': list(distribution),
            'last_updated': timezone.now()
        }

    def _validate_inputs(self, department, journal_tier):
        """입력 파라미터 검증"""
        # 저널등급 화이트리스트 검증
        if journal_tier not in self.ALLOWED_TIERS:
            raise ValidationError(f"유효하지 않은 저널등급: {journal_tier}")

        # 학과 존재 여부 검증
        if department != 'all':
            all_departments = self.publication_repo.get_all_departments()
            if department not in all_departments:
                raise ValidationError(f"존재하지 않는 학과: {department}")

    def _aggregate_by_tier(self, queryset):
        """저널 등급별 집계 (DB 레벨)"""
        total_count = queryset.count()
        if total_count == 0:
            return []

        aggregated = queryset.values('journal_tier').annotate(
            count=Count('paper_id'),
            avg_if=Avg('impact_factor', filter=Q(impact_factor__isnull=False))
        ).order_by('-count')

        # 비율 계산
        for item in aggregated:
            item['percentage'] = round((item['count'] / total_count) * 100, 1)

        return aggregated

    def _calculate_avg_impact_factor(self, queryset):
        """평균 Impact Factor 계산 (NULL 제외)"""
        publications_with_if = queryset.filter(impact_factor__isnull=False)
        papers_with_if = publications_with_if.count()

        if papers_with_if == 0:
            return None, 0

        avg_if = publications_with_if.aggregate(
            avg=Avg('impact_factor')
        )['avg']

        return avg_if, papers_with_if
```

#### Infrastructure Layer: `infrastructure/repositories.py`

```python
# backend/data_ingestion/infrastructure/repositories.py
from .models import Publication

class PublicationRepository:
    """Data Access Layer - DB 조회 전담"""

    def get_publications_by_filter(self, department='all', journal_tier='all'):
        """필터 조건에 맞는 논문 QuerySet 반환"""
        queryset = Publication.objects.all()

        # 학과 필터
        if department != 'all':
            queryset = queryset.filter(department=department)

        # 저널등급 필터
        if journal_tier != 'all':
            queryset = queryset.filter(journal_tier=journal_tier)

        return queryset

    def get_all_departments(self):
        """전체 학과 목록 조회 (중복 제거)"""
        return Publication.objects.values_list('department', flat=True).distinct()
```

### 6.2 Serializer (데이터 직렬화)

```python
# backend/data_ingestion/api/serializers.py
from rest_framework import serializers

class PublicationDashboardSerializer(serializers.Serializer):
    total_papers = serializers.IntegerField()
    avg_impact_factor = serializers.FloatField(allow_null=True)
    papers_with_if = serializers.IntegerField()
    distribution = serializers.ListField(
        child=serializers.DictField()
    )
    last_updated = serializers.DateTimeField()
```

---

## 7. 데이터 집계 로직 (참고용)

### 7.1 Django ORM 쿼리 (실제 사용)

**기본 집계:**
```python
from django.db.models import Count, Avg, Q, F, FloatField
from django.db.models.functions import Coalesce

# 저널 등급별 집계
distribution = (
    Publication.objects
    .values('journal_tier')
    .annotate(
        count=Count('paper_id'),
        avg_if=Avg('impact_factor', filter=Q(impact_factor__isnull=False))
    )
    .order_by('-count')
)

# 전체 통계
total_papers = Publication.objects.count()
avg_impact_factor = Publication.objects.aggregate(
    avg_if=Avg('impact_factor', filter=Q(impact_factor__isnull=False))
)['avg_if']
papers_with_if = Publication.objects.filter(impact_factor__isnull=False).count()

# 비율 계산 (Python 레벨)
for item in distribution:
    item['percentage'] = round((item['count'] / total_papers) * 100, 1)
```

**학과 필터링:**
```python
queryset = Publication.objects.all()
if department and department != 'all':
    queryset = queryset.filter(department=department)

distribution = queryset.values('journal_tier').annotate(...)
```

### 7.2 Pandas 집계 (CSV 파싱 검증용 - 참고만)

**⚠️ 주의:** 아래 로직은 CSV 파일 파싱 시 데이터 검증 및 미리보기 목적으로만 사용됩니다.
**실제 대시보드 API는 6.1절의 Django ORM 쿼리 (Service Layer)를 사용합니다.**

```python
# backend/data_ingestion/services/excel_parser.py
# 이 로직은 CSV 업로드 시 데이터 검증 목적으로만 사용
import pandas as pd

def validate_publication_data(csv_file):
    """CSV 파일의 논문 데이터 유효성 검증"""
    df = pd.read_csv(csv_file)

    # 저널 등급별 집계 (데이터 품질 검증용)
    distribution = df.groupby('저널등급').agg(
        count=('논문ID', 'count'),
        avg_if=('Impact Factor', lambda x: x.dropna().mean())
    ).reset_index()

    # 비율 계산
    total = distribution['count'].sum()
    distribution['percentage'] = (distribution['count'] / total * 100).round(1)

    # 전체 평균 IF
    avg_if = df['Impact Factor'].dropna().mean()

    # 검증 결과 반환
    return {
        'total_papers': total,
        'avg_if': avg_if,
        'distribution_preview': distribution.to_dict('records')
    }
```

---

## 6. UI 컴포넌트 구조

### 6.1 컴포넌트 계층
```
PublicationDashboard (pages/)
├─ PublicationMetricCards (components/dashboard/)
│  ├─ TotalPapersCard
│  └─ AvgImpactFactorCard
├─ PublicationDoughnutChart (components/dashboard/)
│  ├─ Recharts PieChart
│  ├─ CustomTooltip
│  └─ CustomLegend
└─ FilterPanel (components/ui/)
   ├─ DepartmentDropdown
   └─ JournalTierDropdown
```

### 6.2 주요 Props 및 State

**PublicationDoughnutChart.jsx:**
```javascript
// Props
{
  data: Array<{
    journal_tier: string,
    count: number,
    percentage: number,
    avg_if: number
  }>,
  totalPapers: number,
  isLoading: boolean,
  onSectionClick: (tier: string) => void  // 선택적
}

// State
const [hoveredSection, setHoveredSection] = useState(null);
```

**useDashboardData.js Hook:**
```javascript
const {
  publicationData,
  isLoading,
  error,
  refetch
} = useDashboardData();
```

### 6.3 Recharts 설정 예시
```jsx
<ResponsiveContainer width="100%" height={400}>
  <PieChart>
    <Pie
      data={data}
      cx="50%"
      cy="50%"
      innerRadius={80}
      outerRadius={120}
      fill="#8884d8"
      dataKey="count"
      label={({ percentage }) => `${percentage}%`}
    >
      {data.map((entry, index) => (
        <Cell
          key={`cell-${index}`}
          fill={COLORS[entry.journal_tier]}
        />
      ))}
    </Pie>
    <Tooltip content={<CustomTooltip />} />
    <Legend />
  </PieChart>
</ResponsiveContainer>
```

---

## 7. 테스트 요구사항 (TDD)

### 7.1 Unit Tests (70%)

**Backend (Django/DRF):**
```python
# tests/test_publications_api.py
class PublicationAPITestCase(TestCase):
    def test_get_publications_distribution_success(self):
        """저널 등급별 논문 집계 API 정상 응답 테스트"""
        # GIVEN: 테스트 데이터 생성 (SCIE 5편, KCI 3편)
        Publication.objects.create(
            paper_id='P001', department='컴공',
            journal_tier='SCIE', impact_factor=3.5
        )
        # ... 총 8편 생성

        # WHEN: API 호출
        response = self.client.get('/api/dashboard/publications/')

        # THEN: 200 응답 및 올바른 집계 검증
        self.assertEqual(response.status_code, 200)
        data = response.json()['data']
        self.assertEqual(data['total_papers'], 8)
        self.assertAlmostEqual(data['avg_impact_factor'], 2.5, places=1)

    def test_avg_if_excludes_null_values(self):
        """IF가 NULL인 논문은 평균 계산에서 제외됨을 검증"""
        # GIVEN: IF 있는 논문 2편(평균 3.0), IF 없는 논문 3편
        Publication.objects.create(..., impact_factor=2.0)
        Publication.objects.create(..., impact_factor=4.0)
        Publication.objects.create(..., impact_factor=None)

        # WHEN: 집계
        response = self.client.get('/api/dashboard/publications/')

        # THEN: 평균 IF = 3.0 (NULL 제외)
        self.assertEqual(response.json()['data']['avg_impact_factor'], 3.0)
        self.assertEqual(response.json()['data']['papers_with_if'], 2)

    def test_department_filter_applies_correctly(self):
        """학과 필터가 올바르게 적용되는지 검증"""
        # GIVEN: 컴공 3편, 전자공 2편
        Publication.objects.create(paper_id='P1', department='컴공', ...)
        Publication.objects.create(paper_id='P2', department='전자공', ...)

        # WHEN: 학과 필터 적용
        response = self.client.get('/api/dashboard/publications/?department=컴공')

        # THEN: 컴공 3편만 반환
        self.assertEqual(response.json()['data']['total_papers'], 3)
```

**Frontend (React/Jest):**
```javascript
// tests/PublicationDoughnutChart.test.js
describe('PublicationDoughnutChart', () => {
  test('renders doughnut chart with correct data', () => {
    const mockData = [
      { journal_tier: 'SCIE', count: 89, percentage: 57.1, avg_if: 3.2 },
      { journal_tier: 'KCI', count: 67, percentage: 42.9, avg_if: 1.1 }
    ];

    render(<PublicationDoughnutChart data={mockData} totalPapers={156} />);

    // 중앙에 총 논문 수 표시 확인
    expect(screen.getByText('총 156편')).toBeInTheDocument();

    // 범례 표시 확인
    expect(screen.getByText('SCIE')).toBeInTheDocument();
    expect(screen.getByText('KCI')).toBeInTheDocument();
  });

  test('displays empty state when no data', () => {
    render(<PublicationDoughnutChart data={[]} totalPapers={0} />);

    expect(screen.getByText(/논문 데이터가 없습니다/i)).toBeInTheDocument();
  });

  test('shows tooltip on hover', async () => {
    // Recharts Tooltip 동작 검증
    const mockData = [...];
    render(<PublicationDoughnutChart data={mockData} />);

    const scieSection = screen.getByRole('graphics-symbol', { name: /SCIE/i });
    fireEvent.mouseEnter(scieSection);

    await waitFor(() => {
      expect(screen.getByText(/평균 IF: 3.2/i)).toBeInTheDocument();
    });
  });
});
```

### 7.2 Integration Tests (20%)

```python
# tests/test_publication_integration.py
class PublicationIntegrationTestCase(TestCase):
    def test_full_flow_upload_to_visualization(self):
        """CSV 업로드 → 파싱 → 저장 → API 조회 전체 플로우 테스트"""
        # GIVEN: publication_list.csv 파일 준비
        csv_file = open('test_data/publication_list.csv', 'rb')

        # WHEN: 파일 업로드 (백그라운드 처리 완료 대기)
        response = self.client.post(
            '/api/upload/',
            {'file': csv_file, 'type': 'publications'},
            headers={'X-Admin-Key': settings.ADMIN_API_KEY}
        )
        job_id = response.json()['job_id']

        # 작업 완료 폴링
        for _ in range(10):
            status = self.client.get(f'/api/upload/status/{job_id}/')
            if status.json()['status'] == 'completed':
                break
            time.sleep(1)

        # THEN: 대시보드 API에서 데이터 조회 가능
        dashboard_response = self.client.get('/api/dashboard/publications/')
        self.assertEqual(dashboard_response.status_code, 200)
        self.assertGreater(dashboard_response.json()['data']['total_papers'], 0)
```

### 7.3 E2E Tests (10%)

```javascript
// e2e/publication-dashboard.spec.js (Playwright 사용)
test('사용자가 논문 실적 차트를 필터링하고 상세 정보를 확인할 수 있다', async ({ page }) => {
  // GIVEN: 대시보드 페이지 접속
  await page.goto('http://localhost:3000/dashboard');

  // WHEN: 논문 실적 차트 로드 확인
  await page.waitForSelector('[data-testid="publication-chart"]');
  const totalPapers = await page.textContent('[data-testid="total-papers"]');
  expect(totalPapers).toContain('156');

  // AND: 학과 필터 선택
  await page.selectOption('[data-testid="department-filter"]', '컴퓨터공학과');
  await page.waitForResponse(resp => resp.url().includes('/api/dashboard/publications/'));

  // THEN: 필터링된 데이터로 차트 업데이트
  const filteredTotal = await page.textContent('[data-testid="total-papers"]');
  expect(parseInt(filteredTotal)).toBeLessThan(156);

  // AND: 차트 섹션 호버 시 Tooltip 표시
  await page.hover('[data-testid="scie-section"]');
  await page.waitForSelector('[data-testid="chart-tooltip"]');
  const tooltipText = await page.textContent('[data-testid="chart-tooltip"]');
  expect(tooltipText).toContain('SCIE');
  expect(tooltipText).toContain('평균 IF');
});
```

---

## 10. 보안 요구사항

### 10.1 API 접근 제어

**MVP:**
- 별도 인증 없이 내부 네트워크에서만 접근 가능 (Railway 환경 변수 설정)
- CORS 설정: 프런트엔드 도메인만 허용

**POST-MVP:**
- 하드코딩 API Key 또는 간단한 토큰 인증 도입

**구현 예시:**
```python
# settings.py
CORS_ALLOWED_ORIGINS = [
    os.environ.get('FRONTEND_URL', 'http://localhost:3000'),
]
```

### 10.2 입력 검증

**Query Parameter Validation:**

1. **학과 필터 (department):**
   - 화이트리스트 기반 검증 (DB에 존재하는 학과만 허용)
   - `PublicationService._validate_inputs()` 메서드에서 검증
   - 존재하지 않는 학과 입력 시 400 Bad Request (ERR_PUB_001) 반환

2. **저널등급 필터 (journal_tier):**
   - Enum 검증: `['all', 'SCIE', 'KCI', '기타']` 중 하나만 허용
   - 유효하지 않은 값 입력 시 400 Bad Request (ERR_PUB_002) 반환

**구현 예시 (Service Layer):**
```python
# services/publication_service.py
ALLOWED_TIERS = ['all', 'SCIE', 'KCI', '기타']

def _validate_inputs(self, department, journal_tier):
    # 저널등급 화이트리스트 검증
    if journal_tier not in ALLOWED_TIERS:
        raise ValidationError(f"유효하지 않은 저널등급: {journal_tier}")

    # 학과 존재 여부 검증
    if department != 'all':
        all_departments = self.publication_repo.get_all_departments()
        if department not in all_departments:
            raise ValidationError(f"존재하지 않는 학과: {department}")
```

### 10.3 SQL Injection 방어

- Django ORM 사용 시 Parameterized Query 자동 처리로 SQL Injection 방어
- **Raw SQL 사용 금지** (모든 쿼리는 Django ORM을 통해서만 실행)
- `values()`, `annotate()`, `filter()` 등 ORM 메서드만 사용

### 10.4 XSS 방어 (프런트엔드)

**Recharts Tooltip에서의 XSS 방어:**
- React는 기본적으로 JSX 내 문자열을 이스케이프 처리
- `dangerouslySetInnerHTML` 사용 금지
- 학과명/저널등급은 DB에서 가져온 신뢰 데이터이지만, 출력 시 명시적 검증 권장

**구현 예시:**
```jsx
const CustomTooltip = ({ active, payload, label }) => {
  if (!active || !payload) return null;

  // HTML 태그 이스케이프 (추가 방어)
  const safeTierName = label.replace(/</g, '&lt;').replace(/>/g, '&gt;');

  return (
    <div className="custom-tooltip">
      <p className="label">{safeTierName}</p>
      {/* ... */}
    </div>
  );
};
```

### 10.5 CSRF 방어

- GET 요청만 사용하므로 CSRF 공격 불가
- 읽기 전용 API로 상태 변경 없음

### 10.6 Rate Limiting (POST-MVP)

- API 호출 빈도 제한: 동일 IP에서 초당 10회 요청 제한
- Django REST Framework Throttling 사용
- 제한 초과 시 429 Too Many Requests 반환

---

## 11. 성능 요구사항

### 11.1 응답 시간
- **API 응답:** 1초 이내 (10,000건 이하 데이터 기준)
- **차트 렌더링:** 500ms 이내 (초기 로드)
- **필터 적용 후 리렌더링:** 300ms 이내

### 8.2 데이터 볼륨
- **MVP 목표:** 최대 50,000건의 논문 데이터 처리 가능
- **인덱스 최적화:** `department`, `journal_tier` 컬럼에 인덱스 적용
- **대용량 데이터 대응 (추후):** 페이지네이션 또는 연도별 필터링 강제

### 8.3 동시 사용자
- **MVP 목표:** 동시 50명 사용자 지원
- **캐싱 전략:** API 응답을 프런트엔드에서 5분간 캐싱

---

## 8. 접근성 (Accessibility)

### 8.1 WCAG 2.1 Level A 준수
- **색상 대비:** SCIE(진한 파랑)와 KCI(연한 파랑) 간 충분한 대비 확보
- **키보드 네비게이션:** Tab 키로 필터 드롭다운 이동 가능
- **스크린 리더:**
  - 차트 영역에 `aria-label="저널 등급별 논문 비율 차트"` 추가
  - Metric Card에 `role="region"` 및 설명 추가

### 8.2 반응형 디자인
- **데스크탑 (1280px 이상):** 차트 우측에 Metric Card 배치
- **태블릿 (768px~1279px):** 차트 상단에 Metric Card 배치
- **모바일 (767px 이하):** 세로 스크롤, 차트 크기 축소

---

## 9. Out of Scope (MVP 제외 항목)

### 9.1 제외 기능
- 차트 확대/축소 (Zoom, Brush)
- 차트 클릭 드릴다운 (섹션 클릭 시 상세 논문 목록 표시)
- 차트 이미지/PDF 내보내기
- 실시간 데이터 업데이트 (자동 폴링)
- 다중 학과 선택 (Multi-select)
- 커스텀 날짜 범위 필터
- 논문별 Impact Factor 분포 히스토그램
- 학과 간 논문 실적 비교 (Side-by-side 차트)

### 9.2 추후 고려 사항
- 연도별 논문 추이 (Trend Line)
- 교수별 논문 실적 집계
- 저널명 기준 필터링
- 논문 상세 정보 팝업 (제목, 저자, 게재일 등)

---

## Sequence Diagram (PlantUML)

```plantuml
@startuml
actor User
participant FE as "Frontend\n(React)"
participant BE as "Backend\n(DRF API)"
database DB as "Database\n(PostgreSQL)"

== 초기 데이터 로드 ==
User -> FE: 대시보드 페이지 접속
activate FE
FE -> FE: 스켈레톤 UI 표시
FE -> BE: GET /api/dashboard/publications/
activate BE
BE -> DB: SELECT journal_tier, COUNT(*), AVG(impact_factor)\nFROM publications\nGROUP BY journal_tier
activate DB
DB --> BE: 집계 결과 반환
deactivate DB
BE -> BE: 비율 계산 및 JSON 생성
BE --> FE: 200 OK\n{ total_papers, avg_if, distribution }
deactivate BE
FE -> FE: Recharts PieChart 렌더링
FE --> User: Doughnut Chart + Metric Cards 표시
deactivate FE

== 차트 호버 인터랙션 ==
User -> FE: SCIE 섹션에 마우스 올림
activate FE
FE -> FE: Tooltip 데이터 추출\n(SCIE: 89편, 57.1%, IF 3.2)
FE --> User: Tooltip 표시
deactivate FE

== 학과별 필터링 ==
User -> FE: 학과 드롭다운에서 "컴퓨터공학과" 선택
activate FE
FE -> FE: State 업데이트 (department='컴공')
FE -> FE: 로딩 인디케이터 표시
FE -> BE: GET /api/dashboard/publications/?department=컴퓨터공학과
activate BE
BE -> DB: SELECT journal_tier, COUNT(*), AVG(impact_factor)\nFROM publications\nWHERE department = '컴퓨터공학과'\nGROUP BY journal_tier
activate DB
DB --> BE: 필터링된 집계 결과
deactivate DB
BE --> FE: 200 OK\n{ 필터링된 데이터 }
deactivate BE
FE -> FE: 차트 리렌더링 (애니메이션)
FE --> User: 업데이트된 차트 표시
deactivate FE

== 필터 초기화 ==
User -> FE: "전체 보기" 버튼 클릭
activate FE
FE -> FE: 필터 State 리셋 (department='all')
FE -> BE: GET /api/dashboard/publications/
activate BE
BE -> DB: SELECT (필터 없음)
activate DB
DB --> BE: 전체 데이터
deactivate DB
BE --> FE: 200 OK
deactivate BE
FE -> FE: 차트 리렌더링
FE --> User: 전체 데이터 차트 표시
deactivate FE

== 에러 처리 (API 실패) ==
User -> FE: 새로고침 버튼 클릭
activate FE
FE -> BE: GET /api/dashboard/publications/
activate BE
BE -> DB: SELECT ...
DB --x BE: 연결 실패 (500 Error)
BE --x FE: 500 Internal Server Error
deactivate BE
FE -> FE: Error Boundary 캐치
FE -> FE: 자동 재시도 (1회)
FE -> BE: GET /api/dashboard/publications/ (재시도)
activate BE
BE --x FE: 500 Internal Server Error
deactivate BE
FE --> User: 에러 카드 표시\n"데이터를 불러올 수 없습니다.\n새로고침 버튼을 클릭하세요."
deactivate FE

@enduml
```

---

## 문서 변경 이력

| 버전 | 날짜 | 변경 사항 | 작성자 |
|------|------|-----------|--------|
| 1.0 | 2025-11-02 | 초기 유스케이스 명세 작성 | Spec Writer Agent |
| 2.0 | 2025-11-02 | High Priority 개선사항 적용: Django Model 추가, Service Layer 명시, 보안 요구사항 추가, 에러 코드 표준화 | Claude Code |

---

## 문서 승인 및 검토

**작성자:** Spec Writer Agent
**최종 수정자:** Claude Code
**검토자:** CTO
**승인일:** 2025-11-02
**현재 버전:** 2.0

본 유스케이스 명세는 TDD 원칙(Red-Green-Refactor, AAA 패턴, Test Pyramid)을 준수하며, MVP 범위에 집중하여 작성되었습니다. Layered Architecture (View → Service → Repository)를 따르며, 구현 시 테스트 우선 개발을 엄격히 따라야 합니다.

---

**문서 끝**
</file>

<file path="005-department-kpi-dashboard/plan.md">
# 학과 KPI 추이 대시보드 구현 계획 (TDD 기반)

**Feature:** UC-005 학과 KPI 추이 시각화
**작성일:** 2025-11-02
**버전:** 1.0
**TDD 전략:** Outside-In (사용자 시나리오 → API → Service → Repository)

---

## 1. 개요

### 1.1 구현 모듈 목록

| 레이어 | 모듈 | 위치 | TDD 범위 |
|--------|------|------|----------|
| **Presentation** | DepartmentKPIView | `backend/data_ingestion/api/views.py` | Integration Tests |
| **Presentation** | DepartmentKPISerializer | `backend/data_ingestion/api/serializers.py` | Unit Tests |
| **Service** | KPIService | `backend/data_ingestion/services/kpi_service.py` | Unit Tests (핵심) |
| **Repository** | KPIRepository | `backend/data_ingestion/infrastructure/kpi_repository.py` | Unit Tests |
| **Database** | DepartmentKPI Model | `backend/data_ingestion/infrastructure/models.py` | Migration + Unit Tests |
| **Frontend Hook** | useDashboardData (KPI) | `frontend/src/hooks/useDashboardData.js` | Unit Tests |
| **Frontend UI** | DualAxisLineChart | `frontend/src/components/dashboard/DualAxisLineChart.jsx` | Unit Tests |
| **Frontend UI** | MetricCard | `frontend/src/components/dashboard/MetricCard.jsx` | Unit Tests |
| **E2E** | Department KPI Flow | `e2e/department-kpi.spec.js` | Acceptance Tests |

### 1.2 TDD 적용 범위

- **Unit Tests (70%)**: Service Layer, Repository, Hooks, Components
- **Integration Tests (20%)**: API Endpoints (DRF View + ORM)
- **Acceptance Tests (10%)**: E2E User Scenarios (US-005-1, US-005-2, US-005-5)

### 1.3 MVP 최소 기능

- 학과 KPI 데이터 조회 API (필터링: 학과, 년도 범위)
- Dual Y-axis Line Chart 렌더링 (Recharts)
- 평균 취업률 Metric Card 표시
- 에러 처리 (잘못된 파라미터, 데이터 없음)
- 빈 상태 UI

---

## 2. Architecture Diagram

```mermaid
graph TB
    subgraph "Frontend (React)"
        A[DashboardPage] --> B[DepartmentKPISection]
        B --> C[useDashboardData Hook]
        B --> D[MetricCard]
        B --> E[DualAxisLineChart]
        C --> F[dataApiClient]
    end

    subgraph "Backend (DRF)"
        F -->|GET /api/dashboard/department-kpi/| G[DepartmentKPIView]
        G --> H[DepartmentKPISerializer]
        G --> I[KPIService]
        I --> J[KPIRepository]
        J --> K[(DepartmentKPI Model)]
    end

    subgraph "Database (Supabase)"
        K --> L[(department_kpis Table)]
    end

    E -->|Recharts| M[LineChart Component]
    E -->|Tooltip| N[CustomTooltip]
```

---

## 3. Implementation Plan (TDD Workflow)

### 3.1 Phase 1: Database Layer (Foundation)

#### Module: DepartmentKPI Model
- **Location**: `backend/data_ingestion/infrastructure/models.py`
- **Responsibility**: 학과 KPI 데이터 스키마 정의 및 DB 제약 조건
- **Test Strategy**: Unit Tests (Model Validation)

**Test Scenarios (Red Phase):**
```python
# test_kpi_model.py
def test_create_department_kpi_with_valid_data():
    """유효한 데이터로 KPI 레코드 생성 성공"""
    # Given: 유효한 KPI 데이터
    # When: DepartmentKPI 객체 생성 및 저장
    # Then: 저장 성공, 필드 값 검증

def test_employment_rate_must_be_between_0_and_100():
    """취업률은 0~100 범위여야 함"""
    # Given: 취업률 101% 데이터
    # When: 저장 시도
    # Then: ValidationError 발생

def test_tech_transfer_income_cannot_be_negative():
    """기술이전 수입액은 음수 불가"""
    # Given: 음수 수입액
    # When: 저장 시도
    # Then: ValidationError 발생

def test_unique_constraint_on_year_and_department():
    """동일 년도+학과 중복 방지"""
    # Given: 이미 존재하는 년도+학과 조합
    # When: 동일 조합으로 재저장 시도
    # Then: IntegrityError 발생

def test_evaluation_year_must_be_after_2000():
    """평가년도는 2000년 이후여야 함"""
    # Given: 1999년 데이터
    # When: 저장 시도
    # Then: ValidationError 발생
```

**Implementation Order:**
1. Django Model 클래스 정의 (필드, validators)
2. Meta 클래스 (db_table, indexes, unique_together)
3. Migration 파일 생성 (`python manage.py makemigrations`)
4. Migration 실행 (`python manage.py migrate`)
5. 테스트 실행 → Green

**Dependencies**: Django, PostgreSQL (Supabase)

---

### 3.2 Phase 2: Repository Layer (Data Access)

#### Module: KPIRepository
- **Location**: `backend/data_ingestion/infrastructure/kpi_repository.py`
- **Responsibility**: Django ORM을 사용한 KPI 데이터 조회 (CRUD)
- **Test Strategy**: Unit Tests (Isolated with Test DB)

**Test Scenarios (Red Phase):**
```python
# test_kpi_repository.py
def test_find_by_department_and_year_returns_filtered_queryset():
    """학과 및 년도 범위로 필터링된 QuerySet 반환"""
    # Arrange: 테스트 데이터 삽입 (2019~2023, 컴공과/전자과)
    # Act: repository.find_by_department_and_year('컴퓨터공학과', 2020, 2022)
    # Assert: 컴공과 2020~2022 데이터만 반환

def test_find_by_department_all_returns_all_departments():
    """department='all' 시 모든 학과 반환"""
    # Arrange: 여러 학과 데이터 삽입
    # Act: repository.find_by_department_and_year('all', 2020, 2023)
    # Assert: 모든 학과 데이터 반환

def test_find_by_year_returns_single_year_data():
    """특정 년도 데이터만 조회"""
    # Arrange: 2019~2023 데이터 삽입
    # Act: repository.find_by_year(2022)
    # Assert: 2022년 데이터만 반환

def test_find_all_returns_all_records():
    """모든 KPI 데이터 조회"""
    # Arrange: 10개 레코드 삽입
    # Act: repository.find_all()
    # Assert: 10개 레코드 반환
```

**Edge Cases:**
```python
def test_empty_queryset_when_no_matching_data():
    """조건에 맞는 데이터 없을 때 빈 QuerySet 반환"""
    # Arrange: 컴공과 데이터만 삽입
    # Act: repository.find_by_department_and_year('물리학과', 2020, 2023)
    # Assert: QuerySet.count() == 0
```

**Implementation Order:**
1. KPIRepository 클래스 뼈대 작성
2. `find_by_department_and_year()` 메서드 구현 (ORM 쿼리)
3. `find_all()`, `find_by_year()` 메서드 구현
4. 테스트 실행 → Green
5. Refactor (쿼리 최적화, select_related/prefetch_related 검토)

**Dependencies**: DepartmentKPI Model, Django ORM

---

### 3.3 Phase 3: Service Layer (Business Logic) - 핵심

#### Module: KPIService
- **Location**: `backend/data_ingestion/services/kpi_service.py`
- **Responsibility**: 비즈니스 로직 검증, 데이터 집계, 메타 정보 생성
- **Test Strategy**: Unit Tests (Mocked Repository)

**Test Scenarios (Red Phase):**
```python
# test_kpi_service.py
def test_get_kpi_trend_returns_aggregated_data():
    """학과 KPI 추이 데이터 정상 집계"""
    # Arrange: Mock Repository (5개 년도 데이터)
    # Act: service.get_kpi_trend('all', 2019, 2023)
    # Assert:
    #   - data 배열 길이 5
    #   - 각 항목에 evaluation_year, avg_employment_rate, total_tech_income 포함
    #   - meta.overall_avg_employment_rate 계산 정확성

def test_get_kpi_trend_with_specific_department():
    """특정 학과 필터링 성공"""
    # Arrange: Mock Repository (컴공과 데이터만)
    # Act: service.get_kpi_trend('컴퓨터공학과', 2020, 2023)
    # Assert: meta.department_filter == '컴퓨터공학과'

def test_validate_year_range_raises_error_when_start_greater_than_end():
    """시작 년도 > 종료 년도 시 ValueError"""
    # Arrange: start_year=2024, end_year=2019
    # Act & Assert: service.get_kpi_trend() raises ValueError

def test_validate_year_range_raises_error_when_range_exceeds_20_years():
    """년도 범위 20년 초과 시 ValueError"""
    # Arrange: start_year=2000, end_year=2025
    # Act & Assert: raises ValueError('년도 범위는 최대 20년까지')

def test_validate_year_range_raises_error_when_future_year():
    """미래 년도 조회 시 ValueError"""
    # Arrange: end_year=2030 (현재 년도+1 초과)
    # Act & Assert: raises ValueError('종료 년도는 {current_year+1}을 초과할 수 없습니다')

def test_validate_year_range_raises_error_when_year_before_2000():
    """2000년 이전 데이터 조회 시 ValueError"""
    # Arrange: start_year=1999
    # Act & Assert: raises ValueError('시작 년도는 2000년 이후여야 합니다')

def test_overall_avg_employment_rate_is_null_when_no_data():
    """데이터 없을 때 overall_avg_employment_rate = null"""
    # Arrange: Mock Repository (빈 QuerySet)
    # Act: service.get_kpi_trend('물리학과', 2020, 2023)
    # Assert:
    #   - data == []
    #   - meta.overall_avg_employment_rate == None
    #   - meta.overall_total_tech_income == None
    #   - meta.total_count == 0
```

**Edge Cases:**
```python
def test_rounds_avg_employment_rate_to_one_decimal():
    """평균 취업률 소수점 첫째자리 반올림"""
    # Arrange: Mock data with 78.456% avg
    # Act: service.get_kpi_trend()
    # Assert: meta.overall_avg_employment_rate == 78.5

def test_handles_single_year_data():
    """단일 년도 데이터만 존재할 때 정상 처리"""
    # Arrange: Mock Repository (2023년 데이터만)
    # Act: service.get_kpi_trend('all', 2023, 2023)
    # Assert: data 배열 길이 1, meta 정상 생성
```

**Implementation Order:**
1. KPIService 클래스 뼈대 작성
2. `_validate_year_range()` 메서드 구현 (비즈니스 규칙 검증)
3. `get_kpi_trend()` 메서드 구현 (Repository 호출, 집계, 응답 생성)
4. 테스트 실행 → Green
5. Refactor (중복 제거, 가독성 개선)

**Dependencies**: KPIRepository (Mocked in tests)

---

### 3.4 Phase 4: Presentation Layer (API)

#### Module: DepartmentKPISerializer
- **Location**: `backend/data_ingestion/api/serializers.py`
- **Responsibility**: 쿼리 파라미터 검증 및 응답 직렬화
- **Test Strategy**: Unit Tests (Serializer Validation)

**Test Scenarios (Red Phase):**
```python
# test_kpi_serializer.py
def test_query_serializer_validates_default_values():
    """파라미터 없을 때 기본값 적용"""
    # Arrange: 빈 query_params
    # Act: serializer = DepartmentKPIQuerySerializer(data={})
    # Assert:
    #   - department == 'all'
    #   - start_year == current_year - 5
    #   - end_year == current_year

def test_query_serializer_accepts_valid_parameters():
    """유효한 파라미터 검증 성공"""
    # Arrange: valid params (department='컴공과', start=2020, end=2023)
    # Act: serializer.is_valid()
    # Assert: True

def test_query_serializer_rejects_invalid_year_range():
    """start_year > end_year 시 검증 실패"""
    # Arrange: start=2024, end=2019
    # Act: serializer.is_valid()
    # Assert: False, errors 포함

def test_query_serializer_rejects_year_below_2000():
    """2000년 미만 년도 거부"""
    # Arrange: start=1999
    # Act: serializer.is_valid()
    # Assert: False

def test_query_serializer_rejects_year_above_2100():
    """2100년 초과 년도 거부"""
    # Arrange: end=2101
    # Act: serializer.is_valid()
    # Assert: False
```

**Implementation Order:**
1. `DepartmentKPIQuerySerializer` 클래스 작성 (CharField, IntegerField)
2. `validate()` 메서드 구현 (년도 범위 체크)
3. 테스트 실행 → Green

---

#### Module: DepartmentKPIView
- **Location**: `backend/data_ingestion/api/views.py`
- **Responsibility**: HTTP 요청 처리 및 Service Layer 위임 (Thin Controller)
- **Test Strategy**: Integration Tests (DRF APITestCase)

**Test Scenarios (Red Phase):**
```python
# test_kpi_api.py
def test_get_kpi_data_all_departments_returns_200():
    """전체 학과 KPI 조회 성공"""
    # Arrange: DB에 테스트 데이터 삽입
    # Act: GET /api/dashboard/department-kpi/?department=all
    # Assert: status_code == 200, response.data['status'] == 'success'

def test_get_kpi_data_specific_department_filters_correctly():
    """특정 학과 필터링 성공"""
    # Arrange: 컴공과, 전자과 데이터 삽입
    # Act: GET /api/dashboard/department-kpi/?department=컴퓨터공학과
    # Assert: 응답 데이터에 컴공과만 포함

def test_get_kpi_data_year_range_filter():
    """년도 범위 필터링 성공"""
    # Arrange: 2019~2024 데이터 삽입
    # Act: GET /api/dashboard/department-kpi/?start_year=2020&end_year=2022
    # Assert: 응답 데이터 년도 범위 2020~2022

def test_invalid_year_range_returns_400():
    """잘못된 년도 범위 시 400 에러"""
    # Arrange: -
    # Act: GET /api/dashboard/department-kpi/?start_year=2024&end_year=2019
    # Assert:
    #   - status_code == 400
    #   - error_code == 'INVALID_YEAR_RANGE'

def test_no_data_returns_empty_list_with_200():
    """데이터 없을 때 빈 리스트 반환 (200 OK)"""
    # Arrange: DB 비어있음
    # Act: GET /api/dashboard/department-kpi/
    # Assert:
    #   - status_code == 200
    #   - data == []
    #   - meta.total_count == 0
```

**Edge Cases:**
```python
def test_future_year_returns_400():
    """미래 년도 조회 시 400 에러"""
    # Arrange: -
    # Act: GET /api/dashboard/department-kpi/?end_year=2030
    # Assert: status_code == 400, error_code == 'FUTURE_YEAR_NOT_ALLOWED'

def test_year_range_exceeds_20_years_returns_400():
    """20년 초과 범위 조회 시 400 에러"""
    # Arrange: -
    # Act: GET /api/dashboard/department-kpi/?start_year=2000&end_year=2025
    # Assert: status_code == 400, error_code == 'YEAR_RANGE_TOO_LARGE'

def test_invalid_department_returns_400():
    """존재하지 않는 학과 조회 시 400 에러"""
    # Arrange: DB에 '물리학과' 없음
    # Act: GET /api/dashboard/department-kpi/?department=존재하지않는학과
    # Assert:
    #   - status_code == 400
    #   - error_code == 'INVALID_DEPARTMENT'
    #   - error_message == '존재하지 않는 학과입니다'
```

**Implementation Order:**
1. `DepartmentKPIView` 클래스 작성 (APIView 상속)
2. `get()` 메서드 구현 (파라미터 추출, Serializer 검증, Service 호출)
3. URL 라우팅 추가 (`urls.py`)
4. 테스트 실행 → Green

**Dependencies**: KPIService, DepartmentKPISerializer, DepartmentKPI Model

---

### 3.5 Phase 5: Frontend Data Layer (Hook)

#### Module: useDashboardData Hook (KPI Extension)
- **Location**: `frontend/src/hooks/useDashboardData.js`
- **Responsibility**: API 호출, 에러 처리, 데이터 변환 (UI 독립적)
- **Test Strategy**: Unit Tests (Mocked Axios)

**Test Scenarios (Red Phase):**
```javascript
// useDashboardData.test.js
test('fetchKPIData calls API with correct parameters', async () => {
  // Arrange: Mock axios.get
  // Act: useDashboardData().fetchKPIData({ department: 'all', startYear: 2019 })
  // Assert: axios.get called with '/api/dashboard/department-kpi/?department=all&start_year=2019...'
});

test('fetchKPIData transforms API response to chart format', async () => {
  // Arrange: Mock API response
  // Act: const data = await fetchKPIData()
  // Assert: data[0] has { year, employmentRate, techIncome }
});

test('fetchKPIData sets loading state correctly', async () => {
  // Arrange: Mock delayed API response
  // Act: fetchKPIData()
  // Assert: loading == true → response → loading == false
});

test('fetchKPIData sets error state on API failure', async () => {
  // Arrange: Mock axios.get to throw error
  // Act: fetchKPIData()
  // Assert: error != null, error.message contains meaningful text
});

test('fetchKPIData returns empty array when API returns no data', async () => {
  // Arrange: Mock API response with data: []
  // Act: const data = await fetchKPIData()
  // Assert: data == []
});
```

**Edge Cases:**
```javascript
test('handles network timeout gracefully', async () => {
  // Arrange: Mock axios timeout error
  // Act: fetchKPIData()
  // Assert: error.message == '데이터 로딩이 지연되고 있습니다. 새로고침하세요'
});

test('calculates overall average employment rate from data', async () => {
  // Arrange: Mock API response with 3 years data
  // Act: const { meta } = await fetchKPIData()
  // Assert: meta.overallAvgEmploymentRate == (sum / 3)
});
```

**Implementation Order:**
1. `useDashboardData.js`에 `fetchKPIData()` 함수 추가
2. Axios 호출 및 에러 처리 로직
3. 응답 데이터 변환 (evaluation_year → year, avg_employment_rate → employmentRate)
4. 테스트 실행 → Green
5. Refactor (중복 제거, React Query 도입 검토)

**Dependencies**: Axios, dataApiClient

---

### 3.6 Phase 6: Frontend UI Layer (Components)

#### Module: MetricCard
- **Location**: `frontend/src/components/dashboard/MetricCard.jsx`
- **Responsibility**: KPI 지표 카드 렌더링 (재사용 가능한 UI)
- **Test Strategy**: Unit Tests (React Testing Library)

**Test Scenarios (Red Phase):**
```javascript
// MetricCard.test.js
test('renders metric card with title and value', () => {
  // Arrange: title='평균 취업률', value='78.5%'
  // Act: render(<MetricCard title={...} value={...} />)
  // Assert: getByText('평균 취업률'), getByText('78.5%')
});

test('renders positive change indicator', () => {
  // Arrange: change=2.3 (positive)
  // Act: render(<MetricCard change={2.3} />)
  // Assert: getByText('↑ 2.3%p'), text color green
});

test('renders negative change indicator', () => {
  // Arrange: change=-1.5 (negative)
  // Act: render(<MetricCard change={-1.5} />)
  // Assert: getByText('↓ 1.5%p'), text color red
});

test('does not render change when undefined', () => {
  // Arrange: change=undefined
  // Act: render(<MetricCard title="평균 취업률" value="78.5%" />)
  // Assert: change indicator not in document
});
```

**Implementation Order:**
1. MetricCard 컴포넌트 뼈대 작성 (props: title, value, change)
2. JSX 구조 작성 (title, value, change indicator)
3. 조건부 렌더링 (change 존재 시만 표시)
4. 테스트 실행 → Green
5. Refactor (Tailwind CSS 스타일 정리)

**Dependencies**: React, Tailwind CSS

---

#### Module: DualAxisLineChart
- **Location**: `frontend/src/components/dashboard/DualAxisLineChart.jsx`
- **Responsibility**: Recharts 기반 이중 축 라인 차트 렌더링
- **Test Strategy**: Unit Tests (Recharts 통합)

**Test Scenarios (Red Phase):**
```javascript
// DualAxisLineChart.test.js
test('renders chart with two lines', () => {
  // Arrange: mockData (3 years)
  // Act: render(<DualAxisLineChart data={mockData} />)
  // Assert: getByText('졸업생 취업률 (%)'), getByText('기술이전 수입액 (억원)')
});

test('renders empty state when data is empty', () => {
  // Arrange: data=[]
  // Act: render(<DualAxisLineChart data={[]} />)
  // Assert: getByText('학과 KPI 데이터가 없습니다')
});

test('displays tooltip on hover (snapshot test)', () => {
  // Arrange: mockData
  // Act: render(<DualAxisLineChart data={mockData} />)
  // Assert: Tooltip component exists (snapshot or DOM query)
});

test('chart has correct Y-axis domains', () => {
  // Arrange: mockData
  // Act: render(<DualAxisLineChart data={mockData} />)
  // Assert: Left YAxis domain [0, 100], Right YAxis domain [0, 'auto']
});
```

**Edge Cases:**
```javascript
test('handles single data point gracefully', () => {
  // Arrange: data with 1 year only
  // Act: render(<DualAxisLineChart data={[{year: 2023, ...}]} />)
  // Assert: chart renders without error, single dot visible
});

test('handles missing year data gracefully', () => {
  // Arrange: 데이터에 2021년 누락 (2019, 2020, 2022, 2023만 존재)
  // Act: render(<DualAxisLineChart data={dataWithGap} />)
  // Assert: 라인이 끊기거나 점선으로 연결됨 (connectNulls 옵션 검증)
});
```

**Implementation Order:**
1. DualAxisLineChart 컴포넌트 뼈대 작성
2. 빈 상태 처리 (data.length === 0)
3. Recharts LineChart 구조 작성 (XAxis, YAxis x2, Line x2, Tooltip, Legend)
4. CustomTooltip 컴포넌트 작성
5. 테스트 실행 → Green
6. Refactor (스타일, 색상 상수화)

**Dependencies**: Recharts, React

---

### 3.7 Phase 7: End-to-End Tests (Acceptance)

#### Module: Department KPI E2E Flow
- **Location**: `e2e/department-kpi.spec.js`
- **Responsibility**: 사용자 시나리오 검증 (US-005-1, US-005-2, US-005-5)
- **Test Strategy**: Acceptance Tests (Playwright)

**Test Scenarios:**
```javascript
// department-kpi.spec.js
test('US-005-1: User views KPI trend chart on dashboard', async ({ page }) => {
  // Given: 메인 대시보드 접속, DB에 KPI 데이터 존재
  // When: 페이지 로드
  // Then:
  //   - 학과 KPI 추이 차트 표시
  //   - 평균 취업률 Metric Card 표시
  //   - 이중 축 라인 차트 렌더링 (2개 라인)
});

test('US-005-2: User filters KPI by department', async ({ page }) => {
  // Given: 학과 KPI 차트 보고 있음
  // When: 학과 필터에서 '컴퓨터공학과' 선택
  // Then:
  //   - 차트 업데이트됨
  //   - Metric Card 평균 취업률 업데이트됨
  //   - URL 쿼리 파라미터 변경 (선택적)
});

test('US-005-5: Empty state displayed when no data', async ({ page }) => {
  // Given: DB에 KPI 데이터 없음
  // When: 대시보드 접속
  // Then: '학과 KPI 데이터가 없습니다' 빈 상태 메시지 표시
});
```

**Implementation Order:**
1. Playwright 설정 파일 작성
2. 테스트 데이터 시드 스크립트 작성 (DB setup)
3. E2E 테스트 시나리오 작성 (위 3개)
4. 테스트 실행 → Green
5. CI/CD 파이프라인에 E2E 테스트 추가

**Dependencies**: Playwright, Test Database

---

## 4. TDD Workflow

### 4.1 구현 순서 (Red → Green → Refactor)

```
1. Database Layer (Phase 1)
   └─ DepartmentKPI Model + Migration
   └─ Run tests → Green

2. Repository Layer (Phase 2)
   └─ KPIRepository (find_by_department_and_year)
   └─ Run tests → Green

3. Service Layer (Phase 3) - 핵심
   └─ KPIService (_validate_year_range)
   └─ Run tests → Green
   └─ KPIService (get_kpi_trend)
   └─ Run tests → Green
   └─ Refactor (중복 제거)

4. Presentation Layer (Phase 4)
   └─ DepartmentKPISerializer
   └─ Run tests → Green
   └─ DepartmentKPIView
   └─ Run integration tests → Green

5. Frontend Data Layer (Phase 5)
   └─ useDashboardData (fetchKPIData)
   └─ Run tests → Green

6. Frontend UI Layer (Phase 6)
   └─ MetricCard
   └─ Run tests → Green
   └─ DualAxisLineChart (빈 상태 먼저)
   └─ Run tests → Green
   └─ DualAxisLineChart (차트 렌더링)
   └─ Run tests → Green

7. E2E Tests (Phase 7)
   └─ US-005-1, US-005-2, US-005-5
   └─ Run acceptance tests → Green

8. Integration & Refactoring
   └─ 모든 테스트 재실행
   └─ 코드 리뷰 및 정리
   └─ 문서화 (API Swagger, Storybook)
```

### 4.2 Commit 포인트 제안

```bash
# Phase 1
git commit -m "feat: Add DepartmentKPI model with validators and indexes"

# Phase 2
git commit -m "feat: Implement KPIRepository for data access layer"

# Phase 3
git commit -m "feat: Add KPIService with year range validation"
git commit -m "feat: Implement KPI trend aggregation in KPIService"

# Phase 4
git commit -m "feat: Add DepartmentKPISerializer for query validation"
git commit -m "feat: Implement DepartmentKPIView API endpoint"

# Phase 5
git commit -m "feat: Add fetchKPIData to useDashboardData hook"

# Phase 6
git commit -m "feat: Create MetricCard component for KPI display"
git commit -m "feat: Implement DualAxisLineChart with Recharts"

# Phase 7
git commit -m "test: Add E2E tests for department KPI dashboard"

# Final
git commit -m "docs: Update API documentation and component Storybook"
```

### 4.3 완료 조건 (Definition of Done)

- [ ] 모든 Unit Tests 통과 (커버리지 목표: Service 100%, Repository 90%)
- [ ] 모든 Integration Tests 통과 (API 엔드포인트 100%)
- [ ] 모든 Acceptance Tests 통과 (US-005-1, US-005-2, US-005-5)
- [ ] 코드 리뷰 완료 (팀원 1명 이상 승인)
- [ ] API 문서 업데이트 (Swagger)
- [ ] 컴포넌트 Storybook 등록
- [ ] 에러 처리 완료 (spec.md Section 13 모든 에러 코드)
- [ ] 보안 요구사항 충족 (spec.md Section 19)
- [ ] CI/CD 파이프라인 통과 (테스트 실패 시 배포 차단)

---

## 5. QA Sheet (Manual Testing - Presentation Layer Only)

### 5.1 UI/UX 수동 테스트 항목

| 항목 | 테스트 시나리오 | 예상 결과 | 실제 결과 | 상태 |
|------|----------------|-----------|----------|------|
| 차트 렌더링 | 대시보드 접속 후 학과 KPI 차트 확인 | 이중 축 라인 차트 표시 (파란색/주황색) | | ⬜ |
| Metric Card | 평균 취업률 카드 확인 | "평균 취업률: XX.X%" 표시 | | ⬜ |
| Tooltip | 차트 데이터 포인트에 마우스 오버 | "YYYY년 / 취업률: XX% / 수입액: XX억원" 표시 | | ⬜ |
| 학과 필터 | 드롭다운에서 특정 학과 선택 | 차트 및 Metric Card 업데이트 | | ⬜ |
| 년도 필터 | "최근 3년" 선택 | X축 년도 범위 조정 | | ⬜ |
| 빈 상태 | DB 데이터 삭제 후 새로고침 | "학과 KPI 데이터가 없습니다" 메시지 표시 | | ⬜ |
| 에러 처리 | 잘못된 년도 파라미터로 API 호출 | 에러 토스트 "데이터 로딩 실패" 표시 | | ⬜ |
| 로딩 상태 | 느린 네트워크 시뮬레이션 | 스켈레톤 UI 표시 → 차트 전환 | | ⬜ |
| 반응형 | 모바일 화면 크기로 조정 | 차트 크기 자동 조정 (ResponsiveContainer) | | ⬜ |
| 접근성 | Tab 키로 필터 접근 | 키보드로 모든 UI 요소 접근 가능 | | ⬜ |
| 색상 대비 | WCAG AA 대비 검사 도구 사용 | 파란색/주황색 대비율 4.5:1 이상 | | ⬜ |

### 5.2 브라우저 호환성 테스트

| 브라우저 | 버전 | 차트 렌더링 | 인터랙션 | 상태 |
|---------|------|-----------|---------|------|
| Chrome | 최신 | | | ⬜ |
| Firefox | 최신 | | | ⬜ |
| Safari | 최신 | | | ⬜ |
| Edge | 최신 | | | ⬜ |

---

## 6. 리스크 및 대응 방안

### 6.1 기술적 리스크

| 리스크 | 영향도 | 대응 방안 |
|--------|--------|----------|
| Recharts 성능 이슈 (대량 데이터) | 중 | 데이터 포인트 20년 제한 (비즈니스 규칙) |
| Django ORM 쿼리 성능 저하 | 중 | 복합 인덱스 추가 (spec.md Section 10.4) |
| 프론트엔드 상태 관리 복잡도 | 낮 | React Query 도입 검토 (캐싱, 리페칭) |
| E2E 테스트 불안정성 | 중 | 테스트 DB 독립 환경, 명시적 wait 사용 |

### 6.2 일정 리스크

| 마일스톤 | 예상 소요 | 리스크 요인 | 대응 |
|---------|----------|-----------|------|
| Phase 1-2 (DB + Repository) | 0.5일 | Django ORM 학습 곡선 | 페어 프로그래밍 |
| Phase 3 (Service) | 1일 | 비즈니스 로직 복잡도 | TDD 엄격 준수 |
| Phase 4 (API) | 0.5일 | DRF Serializer 검증 | 기존 코드 참고 |
| Phase 5-6 (Frontend) | 1.5일 | Recharts 커스터마이징 | 공식 문서 예제 활용 |
| Phase 7 (E2E) | 0.5일 | Playwright 환경 설정 | 템플릿 재사용 |

**총 예상 소요 시간:** 4일 (여유 포함 5일)

---

## 7. 참고 자료

### 7.1 관련 문서
- `docs/005-department-kpi-dashboard/spec.md` - 상세 유스케이스
- `docs/database.md` - DepartmentKPI 모델 스키마
- `docs/techstack.md` - 기술 스택 근거
- `prompt/tdd.md` - TDD 프로세스 가이드라인

### 7.2 외부 라이브러리 문서
- [Django Validators](https://docs.djangoproject.com/en/4.2/ref/validators/)
- [DRF Serializers](https://www.django-rest-framework.org/api-guide/serializers/)
- [Recharts Documentation](https://recharts.org/en-US/api)
- [React Testing Library](https://testing-library.com/docs/react-testing-library/intro/)
- [Playwright](https://playwright.dev/docs/intro)

### 7.3 코드 예제 참고
- spec.md Section 10: 레이어드 아키텍처 코드 예제
- spec.md Section 11: Recharts 구현 예제
- spec.md Section 12: 테스트 코드 예제

---

## 8. 구현 체크리스트 (TodoWrite 연동용)

### Backend
- [ ] DepartmentKPI Model 구현 및 Migration
- [ ] KPIRepository 구현 (find_by_department_and_year, find_all, find_by_year)
- [ ] KPIService 구현 (_validate_year_range, get_kpi_trend)
- [ ] DepartmentKPISerializer 구현 (쿼리 파라미터 검증)
- [ ] DepartmentKPIView 구현 (API 엔드포인트)
- [ ] URL 라우팅 추가
- [ ] 단위 테스트 작성 및 통과 (최소 15개)
- [ ] 통합 테스트 작성 및 통과 (최소 6개 - INVALID_DEPARTMENT 포함)
- [ ] 에러 처리 구현 (9개 에러 코드 - INVALID_DEPARTMENT 포함)

### Frontend
- [ ] useDashboardData Hook에 fetchKPIData 추가
- [ ] MetricCard 컴포넌트 구현
- [ ] DualAxisLineChart 컴포넌트 구현
- [ ] CustomTooltip 컴포넌트 구현
- [ ] 빈 상태 UI 구현
- [ ] 에러 상태 UI 구현
- [ ] 로딩 스켈레톤 구현
- [ ] 학과/년도 필터 연동
- [ ] 년도 데이터 누락 처리 (connectNulls 옵션)
- [ ] 단위 테스트 작성 및 통과 (최소 9개 - 년도 데이터 누락 케이스 포함)
- [ ] E2E 테스트 작성 및 통과 (3개)

### Documentation
- [ ] API 문서 Swagger 추가
- [ ] 컴포넌트 Storybook 등록
- [ ] README 업데이트 (실행 방법)
- [ ] 보안 체크리스트 완료 (spec.md Section 19.6)

---

**문서 끝**

**작성자:** Plan Writer Agent
**검토자:** CTO
**승인일:** 2025-11-02
**버전:** 1.0 (TDD 기반 설계 완료)
</file>

<file path="005-department-kpi-dashboard/spec.md">
# 학과 KPI 추이 대시보드 상세 유스케이스 (UC-005)

**기능명:** 학과 KPI 추이 시각화
**우선순위:** P0-MVP
**작성일:** 2025-11-02
**최종 수정일:** 2025-11-02
**수정자:** Claude Code
**버전:** 3.1 (speccheck.md P0/P1 개선사항 완전 적용)

**변경 이력 (v3.1 - 2025-11-02):**
- **[P0] 보안 요구사항 추가:** Section 20 신규 작성 (인증/인가, CSRF/XSS 방어)
- **[P0] 에러 코드 보완:** Section 13.1에 누락된 3개 에러 코드 추가
  - YEAR_RANGE_TOO_LARGE, FUTURE_YEAR_NOT_ALLOWED, YEAR_TOO_OLD
- **[P1] DB 모델 제약 조건 추가:** Section 10.4에 validators 명시
- **[P1] 테스트 커버리지 목표 추가:** Section 12.4 신규 작성

**변경 이력 (v3.0 - 2025-11-02):**
- **[P0] Section 10 완전 재작성:** View → Service → Repository 레이어 분리
  - 10.1: Presentation Layer (api/views.py) - Thin Controller 패턴
  - 10.2: Service Layer (services/kpi_service.py) - 비즈니스 로직 및 검증
  - 10.3: Repository Layer (infrastructure/kpi_repository.py) - Django ORM 전담
  - 10.4: Database Indexes - 복합 인덱스 명세 추가
  - 10.5: SQL 쿼리 참고 (EXPLAIN ANALYZE 포함)
- **[P0] 쿼리 파라미터 추가 검증:** 년도 범위 상한(20년), 미래 년도 방지, 최소 년도(2000년) 검증
- **[P0] 비즈니스 규칙을 Service Layer에서 검증:** _validate_year_range() 메서드
- CLAUDE.md의 Simple Layered Architecture 원칙 완전 준수

**변경 이력 (v2.0 - 이전):**
- Service Layer 아키텍처 명시 및 Thin Controller 패턴 적용
- Repository Pattern 구현 (kpi_repository.py)
- 데이터베이스 인덱스 전략 추가 (복합 인덱스 포함)
- 쿼리 파라미터 추가 검증 (년도 범위 제한, 미래 년도 방지)

---

## 1. 기능 개요

### 1.1 목적
대학 내부 직원이 학과별 핵심 성과 지표(취업률, 기술이전 수입액)의 연도별 추이를 직관적인 이중 축(Dual-axis) 라인 차트로 파악하여 의사결정을 지원한다.

### 1.2 범위
- 학과 KPI 데이터 조회 및 시각화 (Dual Y-axis Line Chart)
- 평균 취업률 지표 카드 표시
- 학과별/년도별 필터링 기능
- Recharts 라이브러리 기반 구현

### 1.3 데이터 소스
- **파일:** department_kpi.csv
- **필수 컬럼:**
  - 평가년도 (INTEGER): 평가 기준 년도
  - 학과 (VARCHAR): 학과명
  - 졸업생 취업률(%) (NUMERIC): 0~100 범위의 취업률
  - 연간 기술이전 수입액(억원) (NUMERIC): 기술이전 수입액

### 1.4 핵심 가치
- **신속성:** Recharts 기본 컴포넌트 활용으로 빠른 구현
- **간결성:** 단순 드롭다운 필터만 제공 (복잡한 UI 배제)
- **확장성:** 컴포넌트 구조로 추후 추가 지표 확장 가능

---

## 2. 사용자 스토리 (GIVEN-WHEN-THEN)

### US-005-1: KPI 추이 조회
```
GIVEN 내부 직원이 메인 대시보드에 접속했고
  AND 학과 KPI 데이터가 DB에 존재할 때
WHEN 학과 KPI 추이 차트 영역을 확인하면
THEN 연도별 취업률과 기술이전 수입액이 이중 축 라인 차트로 표시되고
  AND 평균 취업률이 지표 카드로 표시된다
```

### US-005-2: 학과별 필터링
```
GIVEN 사용자가 학과 KPI 차트를 보고 있을 때
WHEN 학과 필터 드롭다운에서 특정 학과를 선택하면
THEN 선택한 학과의 KPI 추이만 차트에 표시되고
  AND 해당 학과의 평균 취업률이 지표 카드에 업데이트된다
```

### US-005-3: 년도별 필터링
```
GIVEN 사용자가 학과 KPI 차트를 보고 있을 때
WHEN 기간 필터에서 특정 년도 범위를 선택하면
THEN 선택한 기간의 데이터만 차트에 표시되고
  AND X축 년도 범위가 조정된다
```

### US-005-4: 차트 인터랙션
```
GIVEN 사용자가 학과 KPI 차트를 보고 있을 때
WHEN 차트의 특정 데이터 포인트에 마우스를 올리면
THEN Tooltip이 표시되어 해당 년도의 취업률과 수입액이 보인다
```

### US-005-5: 데이터 없음 처리
```
GIVEN 메인 대시보드에 접속했으나
  AND 학과 KPI 데이터가 DB에 존재하지 않을 때
WHEN 학과 KPI 차트 영역을 확인하면
THEN "학과 KPI 데이터가 없습니다" 빈 상태 메시지가 표시된다
```

---

## 3. Primary Actor
- **내부 직원 (Internal Staff / Viewer)**: 대학 직원 전체 (읽기 전용)

---

## 4. Precondition
- 사용자가 메인 대시보드 페이지에 접근 가능
- department_kpi.csv 파일이 관리자에 의해 최소 1회 업로드되어 DB에 데이터 존재

---

## 5. Trigger
- 사용자가 메인 대시보드 URL (`/` 또는 `/dashboard`)에 접속
- 브라우저에서 자동으로 학과 KPI API 호출 실행

---

## 6. Main Scenario

### Step 1: 페이지 로드 및 초기 데이터 요청
1. 사용자가 메인 대시보드 접속
2. React 앱이 `useDashboardData.js` Hook 실행
3. `GET /api/dashboard/department-kpi/` API 호출 (기본 필터: 전체 학과, 최근 5년)
4. 스켈레톤 UI 표시

### Step 2: 백엔드 데이터 집계
1. DRF View에서 요청 수신
2. 쿼리 파라미터 검증 (학과, 년도 범위)
3. Django ORM을 통해 Supabase 쿼리 실행:
   ```python
   queryset = DepartmentKPI.objects.filter(
       evaluation_year__gte=start_year,
       evaluation_year__lte=end_year
   )
   if department != 'all':
       queryset = queryset.filter(department=department)

   data = queryset.values('evaluation_year').annotate(
       avg_employment_rate=Avg('employment_rate'),
       total_tech_income=Sum('tech_transfer_income')
   ).order_by('evaluation_year')
   ```
4. JSON 응답 반환

### Step 3: 프런트엔드 데이터 처리 및 렌더링
1. API 응답 데이터를 Recharts 형식으로 변환:
   ```javascript
   const chartData = response.data.map(item => ({
     year: item.evaluation_year,
     employmentRate: item.avg_employment_rate,
     techIncome: item.total_tech_income
   }));
   ```
2. 평균 취업률 계산:
   ```javascript
   const avgRate = chartData.reduce((sum, d) => sum + d.employmentRate, 0) / chartData.length;
   ```
3. 차트 컴포넌트에 데이터 바인딩

### Step 4: 차트 표시
1. **Dual Y-axis Line Chart 렌더링:**
   - X축: 평가년도 (2019, 2020, 2021, ...)
   - Y축 (좌): 취업률 (0~100%)
   - Y축 (우): 기술이전 수입액 (억원)
   - 라인 1: 취업률 (실선, 파란색, #3B82F6)
   - 라인 2: 수입액 (점선, 주황색, #F59E0B)
   - 범례: "졸업생 취업률 (%)", "기술이전 수입액 (억원)"

2. **Metric Card 렌더링:**
   - 제목: "평균 취업률"
   - 값: "78.5%"
   - 전년 대비 증감: "↑ 2.3%p" (옵션)

### Step 5: 사용자 인터랙션
1. 사용자가 차트 데이터 포인트에 마우스 오버
2. Tooltip 표시:
   ```
   2023년
   취업률: 78.5%
   수입액: 12.3억원
   ```

---

## 7. Edge Cases

### EC-005-1: 년도 데이터 누락
**상황:** 특정 년도의 KPI 데이터가 없음 (예: 2021년 데이터 없음)
**처리:**
- 해당 년도에서 라인이 끊기거나 점선으로 연결
- Tooltip에 "데이터 없음" 표시
- 차트 하단에 "일부 년도 데이터가 누락되었습니다" 안내

### EC-005-2: 음수 값 발견
**상황:** 취업률 또는 수입액이 음수로 저장됨 (데이터 오류)
**처리:**
- Pandas 파싱 단계에서 음수 값 검증 및 제외
- 에러 로그 기록: "department_kpi.csv 45번째 행의 취업률이 음수(-5.2)입니다"
- 해당 행은 DB 삽입 제외

### EC-005-3: 취업률 범위 초과
**상황:** 취업률이 100% 초과 또는 0% 미만
**처리:**
- Pandas 검증: `0 <= employment_rate <= 100`
- 범위 위반 시 해당 행 제외 + 경고 로그
- 관리자에게 "취업률 값 검증 실패" 메시지 표시

### EC-005-4: 단일 년도만 존재
**상황:** DB에 1개 년도 데이터만 있음
**처리:**
- 라인 차트에 단일 점만 표시
- 차트 하단 안내: "추가 데이터 업로드 시 추이를 확인할 수 있습니다"
- 지표 카드는 정상 표시

### EC-005-5: 학과 필터 결과 없음
**상황:** 특정 학과 선택 시 해당 학과의 KPI 데이터 없음
**처리:**
- 차트 영역에 빈 상태 표시
- 메시지: "'컴퓨터공학과'의 KPI 데이터가 없습니다"
- 권장: "다른 학과를 선택하거나 '전체 학과'를 클릭하세요"
- 필터 초기화 버튼 강조

### EC-005-6: API 타임아웃
**상황:** 백엔드 응답 30초 초과
**처리:**
- 에러 토스트: "데이터 로딩이 지연되고 있습니다. 새로고침하세요"
- "재시도" 버튼 표시
- 기존 차트 유지 (마지막 성공 데이터)

### EC-005-7: 급격한 변화 (이상치)
**상황:** 연도 간 취업률 또는 수입액이 30% 이상 급변
**처리:**
- 해당 데이터 포인트 강조 표시 (색상 변경 또는 마커 크기 증가)
- Tooltip에 "전년 대비 +35.2% 급증" 추가 정보
- 관리자에게 알림 (POST-MVP)

---

## 8. Business Rules

### BR-005-1: 데이터 집계 방식
- 평가년도별 GROUP BY 집계
- 학과별 필터 적용 시: 선택 학과의 데이터만 조회
- 전체 학과 선택 시: 모든 학과의 평균 취업률 및 총 수입액 집계

### BR-005-2: 취업률 계산
- 평균 취업률 = AVG(employment_rate) WHERE 필터 조건
- 소수점 첫째 자리까지 표시 (78.5%)

### BR-005-3: 기술이전 수입액 표시
- 단위: 억원 (DB에 억원 단위로 저장)
- 소수점 첫째 자리까지 표시 (12.3억원)
- 라벨: "기술이전 수입액 (억원)"

### BR-005-4: 년도 범위 기본값
- 기본 필터: 최근 5년 데이터
- 사용자 선택 가능 옵션: "최근 3년", "최근 5년", "최근 10년", "전체"

### BR-005-5: 차트 색상 규칙
- 취업률 라인: 파란색 (#3B82F6), 실선, 두께 2px
- 수입액 라인: 주황색 (#F59E0B), 점선(dash: [5, 5]), 두께 2px
- 데이터 포인트: 원형 마커, 반지름 4px

### BR-005-6: 정렬 순서
- X축 년도: 오름차순 정렬 (2019 → 2024)
- 학과 드롭다운: 가나다순 정렬

### BR-005-7: 빈 데이터 처리
- 데이터 없음: 빈 상태 UI 표시
- 부분 데이터: 존재하는 년도만 표시 + 누락 안내

---

## 9. API 명세

### 9.1 GET /api/dashboard/department-kpi/

**용도:** 학과 KPI 추이 데이터 조회

**요청:**
```http
GET /api/dashboard/department-kpi/?department=all&start_year=2019&end_year=2024
```

**쿼리 파라미터:**
| 파라미터 | 타입 | 필수 | 기본값 | 설명 |
|---------|------|------|--------|------|
| department | string | No | "all" | 학과명 또는 "all" |
| start_year | integer | No | (current_year - 5) | 시작 년도 |
| end_year | integer | No | current_year | 종료 년도 |

**응답 (성공):**
```json
{
  "status": "success",
  "data": [
    {
      "evaluation_year": 2019,
      "avg_employment_rate": 76.2,
      "total_tech_income": 8.5
    },
    {
      "evaluation_year": 2020,
      "avg_employment_rate": 77.8,
      "total_tech_income": 10.2
    },
    {
      "evaluation_year": 2021,
      "avg_employment_rate": 79.1,
      "total_tech_income": 11.8
    },
    {
      "evaluation_year": 2022,
      "avg_employment_rate": 78.5,
      "total_tech_income": 12.3
    },
    {
      "evaluation_year": 2023,
      "avg_employment_rate": 80.2,
      "total_tech_income": 14.7
    }
  ],
  "meta": {
    "department_filter": "all",
    "year_range": "2019-2023",
    "overall_avg_employment_rate": 78.4,
    "total_count": 5
  }
}
```

**응답 (에러 - 잘못된 년도 범위):**
```json
{
  "status": "error",
  "error_code": "INVALID_YEAR_RANGE",
  "message": "시작 년도는 종료 년도보다 작아야 합니다.",
  "details": {
    "start_year": 2024,
    "end_year": 2019
  }
}
```

**응답 (데이터 없음):**
```json
{
  "status": "success",
  "data": [],
  "meta": {
    "department_filter": "컴퓨터공학과",
    "year_range": "2019-2023",
    "overall_avg_employment_rate": null,
    "total_count": 0
  }
}
```

**HTTP 상태 코드:**
- 200 OK: 정상 조회 (데이터 없어도 200)
- 400 Bad Request: 잘못된 파라미터
- 500 Internal Server Error: 서버 오류

---

## 10. 데이터 집계 로직 (레이어드 아키텍처)

### 10.1 Presentation Layer (api/views.py) - Thin Controller

```python
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status
from datetime import datetime

class DepartmentKPIView(APIView):
    """학과 KPI 추이 조회 API (Thin Controller)"""

    def get(self, request):
        # 1. 요청 파라미터 추출
        department = request.query_params.get('department', 'all')
        start_year = int(request.query_params.get('start_year', datetime.now().year - 5))
        end_year = int(request.query_params.get('end_year', datetime.now().year))

        # 2. Service Layer로 위임
        from data_ingestion.services.kpi_service import KPIService
        kpi_service = KPIService()

        try:
            result = kpi_service.get_kpi_trend(department, start_year, end_year)
            return Response(result, status=status.HTTP_200_OK)
        except ValueError as e:
            return Response({
                'status': 'error',
                'error_code': 'INVALID_YEAR_RANGE',
                'message': str(e)
            }, status=status.HTTP_400_BAD_REQUEST)
```

### 10.2 Service Layer (services/kpi_service.py) - Business Logic

```python
from datetime import datetime
from typing import Dict, List
from django.db.models import Avg, Sum

class KPIService:
    """학과 KPI 데이터 집계 및 비즈니스 로직"""

    def get_kpi_trend(self, department: str, start_year: int, end_year: int) -> Dict:
        """
        학과 KPI 추이 데이터 조회 및 집계

        Args:
            department: 학과명 또는 'all'
            start_year: 시작 년도
            end_year: 종료 년도

        Returns:
            집계된 KPI 데이터 및 메타 정보

        Raises:
            ValueError: 잘못된 년도 범위
        """
        # 1. 비즈니스 규칙 검증
        self._validate_year_range(start_year, end_year)

        # 2. Repository를 통한 데이터 조회
        from data_ingestion.infrastructure.kpi_repository import KPIRepository
        repository = KPIRepository()

        queryset = repository.find_by_department_and_year(
            department=department,
            start_year=start_year,
            end_year=end_year
        )

        # 3. 년도별 집계
        trend_data = queryset.values('evaluation_year').annotate(
            avg_employment_rate=Avg('employment_rate'),
            total_tech_income=Sum('tech_transfer_income')
        ).order_by('evaluation_year')

        # 4. 전체 평균 취업률 계산
        overall_avg = queryset.aggregate(avg=Avg('employment_rate'))['avg']

        # 5. 응답 구성
        return {
            'status': 'success',
            'data': list(trend_data),
            'meta': {
                'department_filter': department,
                'year_range': f'{start_year}-{end_year}',
                'overall_avg_employment_rate': round(overall_avg, 1) if overall_avg else None,
                'total_count': len(trend_data)
            }
        }

    def _validate_year_range(self, start_year: int, end_year: int):
        """년도 범위 검증 (비즈니스 규칙)"""
        # 1. 시작 년도 <= 종료 년도
        if start_year > end_year:
            raise ValueError('시작 년도는 종료 년도보다 작거나 같아야 합니다.')

        # 2. 년도 범위 상한 (최대 20년)
        if end_year - start_year > 20:
            raise ValueError('년도 범위는 최대 20년까지 조회 가능합니다.')

        # 3. 미래 년도 방지
        current_year = datetime.now().year
        if end_year > current_year + 1:
            raise ValueError(f'종료 년도는 {current_year + 1}을 초과할 수 없습니다.')

        # 4. 시작 년도 최소값 (예: 2000년 이후)
        if start_year < 2000:
            raise ValueError('시작 년도는 2000년 이후여야 합니다.')
```

### 10.3 Repository Layer (infrastructure/kpi_repository.py) - Data Access

```python
from django.db.models import QuerySet
from data_ingestion.infrastructure.models import DepartmentKPI

class KPIRepository:
    """학과 KPI 데이터 접근 계층 (Django ORM)"""

    @staticmethod
    def find_by_department_and_year(
        department: str,
        start_year: int,
        end_year: int
    ) -> QuerySet:
        """
        학과 및 년도 범위로 KPI 데이터 조회

        Args:
            department: 학과명 또는 'all'
            start_year: 시작 년도
            end_year: 종료 년도

        Returns:
            필터링된 QuerySet
        """
        # 기본 쿼리셋 (복합 인덱스 활용)
        queryset = DepartmentKPI.objects.filter(
            evaluation_year__gte=start_year,
            evaluation_year__lte=end_year
        )

        # 학과 필터 적용
        if department != 'all':
            queryset = queryset.filter(department=department)

        return queryset

    @staticmethod
    def find_all() -> QuerySet:
        """모든 KPI 데이터 조회"""
        return DepartmentKPI.objects.all()

    @staticmethod
    def find_by_year(year: int) -> QuerySet:
        """특정 년도 KPI 데이터 조회"""
        return DepartmentKPI.objects.filter(evaluation_year=year)
```

### 10.4 Database Indexes (models.py 또는 Migration)

```python
# infrastructure/models.py
from django.db import models
from django.core.validators import MinValueValidator, MaxValueValidator

class DepartmentKPI(models.Model):
    """학과 KPI 모델"""
    evaluation_year = models.IntegerField(
        db_index=True,
        validators=[MinValueValidator(2000), MaxValueValidator(2100)],
        null=False,
        blank=False,
        help_text='평가 기준 년도 (2000년 이후)'
    )
    department = models.CharField(
        max_length=100,
        db_index=True,
        null=False,
        blank=False,
        help_text='학과명'
    )
    employment_rate = models.FloatField(
        validators=[MinValueValidator(0.0), MaxValueValidator(100.0)],
        null=False,
        blank=False,
        help_text='졸업생 취업률 (0~100%)'
    )
    tech_transfer_income = models.FloatField(
        validators=[MinValueValidator(0.0)],
        null=False,
        blank=False,
        help_text='연간 기술이전 수입액 (억원)'
    )
    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        db_table = 'department_kpis'
        indexes = [
            # 복합 인덱스: 학과 + 년도 동시 필터링 쿼리 최적화
            models.Index(fields=['department', 'evaluation_year'], name='idx_dept_year'),
            # 년도 범위 쿼리 최적화
            models.Index(fields=['evaluation_year'], name='idx_year'),
        ]
        verbose_name = '학과 KPI'
        verbose_name_plural = '학과 KPI 목록'

    def __str__(self):
        return f'{self.department} - {self.evaluation_year}년'
```

### 10.5 SQL 쿼리 (참고 - ORM이 생성하는 쿼리)

```sql
-- 전체 학과 년도별 집계 (복합 인덱스 활용)
SELECT
    evaluation_year,
    ROUND(AVG(employment_rate), 1) AS avg_employment_rate,
    ROUND(SUM(tech_transfer_income), 1) AS total_tech_income
FROM department_kpis
WHERE evaluation_year BETWEEN 2019 AND 2024
GROUP BY evaluation_year
ORDER BY evaluation_year;

-- 특정 학과 년도별 데이터 (복합 인덱스 활용)
SELECT
    evaluation_year,
    employment_rate AS avg_employment_rate,
    tech_transfer_income AS total_tech_income
FROM department_kpis
WHERE department = '컴퓨터공학과'
  AND evaluation_year BETWEEN 2019 AND 2024
ORDER BY evaluation_year;

-- EXPLAIN ANALYZE 결과 (성능 검증)
-- Index Scan using idx_dept_year on department_kpis (cost=0.29..12.31 rows=5 width=20)
```

---

## 11. UI 컴포넌트 구조

### 11.1 컴포넌트 계층
```
DashboardPage
  └─ DepartmentKPISection
       ├─ MetricCard (평균 취업률)
       └─ DualAxisLineChart
            ├─ LineChart (Recharts)
            ├─ XAxis (년도)
            ├─ YAxis (좌: 취업률)
            ├─ YAxis (우: 수입액)
            ├─ Line (취업률)
            ├─ Line (수입액)
            ├─ Tooltip
            └─ Legend
```

### 11.2 Recharts 코드 예시
```jsx
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer } from 'recharts';

function DualAxisLineChart({ data }) {
  return (
    <ResponsiveContainer width="100%" height={400}>
      <LineChart data={data}>
        <CartesianGrid strokeDasharray="3 3" />

        <XAxis
          dataKey="year"
          label={{ value: '평가년도', position: 'insideBottom', offset: -5 }}
        />

        <YAxis
          yAxisId="left"
          label={{ value: '취업률 (%)', angle: -90, position: 'insideLeft' }}
          domain={[0, 100]}
        />

        <YAxis
          yAxisId="right"
          orientation="right"
          label={{ value: '수입액 (억원)', angle: 90, position: 'insideRight' }}
          domain={[0, 'auto']}
        />

        <Tooltip content={<CustomTooltip />} />

        <Legend />

        <Line
          yAxisId="left"
          type="monotone"
          dataKey="employmentRate"
          stroke="#3B82F6"
          strokeWidth={2}
          name="졸업생 취업률 (%)"
          dot={{ r: 4 }}
        />

        <Line
          yAxisId="right"
          type="monotone"
          dataKey="techIncome"
          stroke="#F59E0B"
          strokeWidth={2}
          strokeDasharray="5 5"
          name="기술이전 수입액 (억원)"
          dot={{ r: 4 }}
        />
      </LineChart>
    </ResponsiveContainer>
  );
}

function CustomTooltip({ active, payload, label }) {
  if (active && payload && payload.length) {
    return (
      <div className="bg-white p-3 border border-gray-300 rounded shadow-lg">
        <p className="font-semibold">{label}년</p>
        <p className="text-blue-600">취업률: {payload[0].value}%</p>
        <p className="text-orange-600">수입액: {payload[1].value}억원</p>
      </div>
    );
  }
  return null;
}
```

### 11.3 Metric Card 예시
```jsx
function MetricCard({ title, value, change }) {
  const isPositive = change >= 0;

  return (
    <div className="bg-white p-6 rounded-lg shadow">
      <h3 className="text-gray-500 text-sm font-medium">{title}</h3>
      <div className="mt-2 flex items-baseline">
        <p className="text-3xl font-semibold text-gray-900">{value}%</p>
        {change !== undefined && (
          <p className={`ml-2 text-sm ${isPositive ? 'text-green-600' : 'text-red-600'}`}>
            {isPositive ? '↑' : '↓'} {Math.abs(change)}%p
          </p>
        )}
      </div>
    </div>
  );
}
```

---

## 12. 테스트 요구사항 (TDD)

### 12.1 단위 테스트 (Unit Tests)

#### 백엔드 (Python/Django)
**파일:** `backend/data_ingestion/tests/test_kpi_api.py`

```python
class DepartmentKPIAPITestCase(TestCase):
    def setUp(self):
        # 테스트 데이터 생성
        DepartmentKPI.objects.create(
            evaluation_year=2023,
            department='컴퓨터공학과',
            employment_rate=78.5,
            tech_transfer_income=12.3
        )

    def test_get_kpi_data_all_departments(self):
        """전체 학과 KPI 조회 성공"""
        response = self.client.get('/api/dashboard/department-kpi/?department=all')
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.data['status'], 'success')
        self.assertGreater(len(response.data['data']), 0)

    def test_get_kpi_data_specific_department(self):
        """특정 학과 KPI 조회 성공"""
        response = self.client.get('/api/dashboard/department-kpi/?department=컴퓨터공학과')
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.data['data'][0]['evaluation_year'], 2023)

    def test_get_kpi_data_year_range_filter(self):
        """년도 범위 필터링 성공"""
        response = self.client.get('/api/dashboard/department-kpi/?start_year=2020&end_year=2023')
        self.assertEqual(response.status_code, 200)
        for item in response.data['data']:
            self.assertGreaterEqual(item['evaluation_year'], 2020)
            self.assertLessEqual(item['evaluation_year'], 2023)

    def test_invalid_year_range(self):
        """잘못된 년도 범위 요청 시 에러"""
        response = self.client.get('/api/dashboard/department-kpi/?start_year=2024&end_year=2019')
        self.assertEqual(response.status_code, 400)
        self.assertEqual(response.data['error_code'], 'INVALID_YEAR_RANGE')

    def test_no_data_returns_empty_list(self):
        """데이터 없을 때 빈 리스트 반환"""
        DepartmentKPI.objects.all().delete()
        response = self.client.get('/api/dashboard/department-kpi/')
        self.assertEqual(response.status_code, 200)
        self.assertEqual(len(response.data['data']), 0)
        self.assertIsNone(response.data['meta']['overall_avg_employment_rate'])
```

#### 프런트엔드 (JavaScript/React)
**파일:** `frontend/src/components/dashboard/__tests__/DualAxisLineChart.test.js`

```javascript
describe('DualAxisLineChart', () => {
  const mockData = [
    { year: 2021, employmentRate: 76.2, techIncome: 8.5 },
    { year: 2022, employmentRate: 78.5, techIncome: 12.3 },
    { year: 2023, employmentRate: 80.2, techIncome: 14.7 }
  ];

  test('차트가 정상 렌더링됨', () => {
    render(<DualAxisLineChart data={mockData} />);
    expect(screen.getByText('졸업생 취업률 (%)')).toBeInTheDocument();
    expect(screen.getByText('기술이전 수입액 (억원)')).toBeInTheDocument();
  });

  test('빈 데이터일 때 빈 상태 표시', () => {
    render(<DualAxisLineChart data={[]} />);
    expect(screen.getByText('학과 KPI 데이터가 없습니다')).toBeInTheDocument();
  });

  test('Tooltip이 호버 시 표시됨', async () => {
    render(<DualAxisLineChart data={mockData} />);
    const dataPoint = screen.getByRole('img'); // 차트 요소
    userEvent.hover(dataPoint);
    await waitFor(() => {
      expect(screen.getByText(/2022년/)).toBeInTheDocument();
      expect(screen.getByText(/78.5%/)).toBeInTheDocument();
    });
  });
});
```

### 12.2 통합 테스트 (Integration Tests)
**파일:** `backend/data_ingestion/tests/test_kpi_integration.py`

```python
class KPIIntegrationTestCase(TestCase):
    def test_full_kpi_data_flow(self):
        """CSV 업로드 → DB 저장 → API 조회 전체 플로우"""
        # 1. CSV 파일 업로드
        with open('test_data/department_kpi.csv', 'rb') as f:
            response = self.client.post('/api/upload/', {'file': f}, HTTP_X_ADMIN_KEY='test-key')
        self.assertEqual(response.status_code, 202)

        # 2. 작업 완료 대기
        job_id = response.data['job_id']
        time.sleep(2)

        # 3. API 조회
        response = self.client.get('/api/dashboard/department-kpi/')
        self.assertEqual(response.status_code, 200)
        self.assertGreater(len(response.data['data']), 0)
```

### 12.3 E2E 테스트 (End-to-End Tests)
**파일:** `e2e/department-kpi.spec.js` (Playwright)

```javascript
test('사용자가 학과 KPI 차트를 조회하고 필터링함', async ({ page }) => {
  // 1. 대시보드 접속
  await page.goto('http://localhost:3000/dashboard');

  // 2. 학과 KPI 차트 영역 확인
  await expect(page.locator('text=학과 KPI 추이')).toBeVisible();

  // 3. 차트 렌더링 확인
  await expect(page.locator('.recharts-line')).toHaveCount(2); // 2개 라인

  // 4. 학과 필터 선택
  await page.selectOption('select[name="department"]', '컴퓨터공학과');

  // 5. 차트 업데이트 확인
  await page.waitForTimeout(500);
  await expect(page.locator('text=평균 취업률')).toBeVisible();

  // 6. Tooltip 인터랙션
  await page.hover('.recharts-line-dot');
  await expect(page.locator('.recharts-tooltip-wrapper')).toBeVisible();
});
```

### 12.4 테스트 커버리지 목표

**백엔드 (Python/Django):**
- **Unit Tests**: 80% 이상 코드 커버리지
  - Service Layer: 100% (모든 비즈니스 로직 검증 필수)
  - Repository Layer: 90% 이상
  - API Views: 80% 이상
- **Integration Tests**: 주요 API 엔드포인트 100% 커버
  - `/api/dashboard/department-kpi/` 전체 시나리오

**프론트엔드 (JavaScript/React):**
- **Unit Tests**: 70% 이상 코드 커버리지
  - Hooks (useDashboardData): 90% 이상
  - Components: 70% 이상
- **E2E Tests**: 핵심 사용자 시나리오 100% 커버
  - US-005-1, US-005-2, US-005-5 필수

**커버리지 측정 도구:**
- 백엔드: `coverage.py` 사용
  ```bash
  coverage run --source='.' manage.py test
  coverage report -m
  ```
- 프론트엔드: Jest coverage 사용
  ```bash
  npm run test -- --coverage
  ```

**CI/CD 파이프라인:**
- 테스트 실패 시 배포 차단
- 커버리지 목표 미달 시 경고 (차단하지 않음, MVP 단계)

---

## 13. 에러 처리

### 13.1 에러 코드 정의
| 코드 | HTTP 상태 | 설명 | 복구 방법 |
|------|-----------|------|----------|
| INVALID_YEAR_RANGE | 400 | 시작 년도 > 종료 년도 | 년도 범위 수정 |
| YEAR_RANGE_TOO_LARGE | 400 | 년도 범위가 20년 초과 | 범위 축소 (최대 20년) |
| FUTURE_YEAR_NOT_ALLOWED | 400 | 미래 년도 조회 불가 | 현재 또는 과거 년도 선택 |
| YEAR_TOO_OLD | 400 | 2000년 이전 데이터 조회 불가 | 2000년 이후 년도 선택 |
| INVALID_DEPARTMENT | 400 | 존재하지 않는 학과 | 학과 목록 확인 |
| NO_DATA | 200 | 조회 조건에 맞는 데이터 없음 | 필터 조정 또는 데이터 업로드 |
| DB_CONNECTION_ERROR | 500 | 데이터베이스 연결 실패 | 재시도 또는 관리자 문의 |
| TIMEOUT | 500 | 쿼리 타임아웃 | 필터 범위 축소 |

### 13.2 프런트엔드 에러 표시
```jsx
function DepartmentKPISection() {
  const { data, loading, error } = useDashboardData('kpi');

  if (loading) return <SkeletonChart />;

  if (error) {
    return (
      <ErrorCard
        title="학과 KPI 데이터 로딩 실패"
        message={error.message}
        action={<Button onClick={refetch}>재시도</Button>}
      />
    );
  }

  if (data.length === 0) {
    return (
      <EmptyState
        icon={<ChartIcon />}
        title="학과 KPI 데이터가 없습니다"
        description="관리자가 데이터를 업로드하면 여기에 표시됩니다"
      />
    );
  }

  return (
    <>
      <MetricCard title="평균 취업률" value={avgRate} />
      <DualAxisLineChart data={data} />
    </>
  );
}
```

---

## 14. 성능 요구사항

### 14.1 응답 시간
- API 조회: 평균 200ms 이하, 최대 1초
- 차트 렌더링: 500ms 이하
- 필터 적용: 300ms 이하

### 14.2 데이터 규모
- 최대 년도 범위: 20년
- 최대 학과 수: 50개
- 최대 레코드 수: 1,000건 (20년 × 50학과)

### 14.3 최적화 전략
- 백엔드: Django ORM 쿼리 최적화 (인덱스 활용)
- 프런트엔드: 디바운싱 (300ms), 데이터 메모이제이션
- 캐싱: React Query 캐시 5분

---

## 15. 접근성 (Accessibility)

### 15.1 키보드 내비게이션
- Tab 키로 필터 드롭다운 접근
- Enter/Space 키로 필터 선택

### 15.2 스크린 리더 지원
- 차트 영역에 `aria-label` 추가: "학과 KPI 추이 그래프"
- Metric Card에 `role="region"` 추가
- Tooltip 내용 스크린 리더 읽기 가능

### 15.3 색상 대비
- WCAG AA 기준 충족 (4.5:1 이상)
- 파란색 라인: #3B82F6 (충분한 대비)
- 주황색 라인: #F59E0B (충분한 대비)

---

## 16. Out of Scope (MVP 제외)

### 16.1 고급 기능
- 차트 확대/축소 (Zoom)
- 데이터 드릴다운 (클릭 시 상세 페이지 이동)
- 차트 데이터 내보내기 (CSV/PNG)
- 차트 비교 모드 (여러 학과 동시 비교)

### 16.2 추가 지표
- 연구비 대비 기술이전 수입 비율
- 학과별 순위 표시
- 목표 취업률 대비 달성률

### 16.3 알림 기능
- 취업률 하락 경고
- 목표 미달 알림
- 이메일 리포트 전송

---

## 17. Sequence Diagram (PlantUML)

```plantuml
@startuml
actor User
participant FE as "Frontend\n(React)"
participant BE as "Backend\n(DRF)"
participant DB as "Database\n(Supabase)"

User -> FE: 대시보드 접속
activate FE
FE -> FE: 스켈레톤 UI 표시
FE -> BE: GET /api/dashboard/department-kpi/\n?department=all&start_year=2019&end_year=2024
activate BE

BE -> BE: 쿼리 파라미터 검증
BE -> DB: SELECT evaluation_year,\nAVG(employment_rate),\nSUM(tech_transfer_income)\nFROM department_kpis\nWHERE evaluation_year BETWEEN 2019 AND 2024\nGROUP BY evaluation_year
activate DB
DB --> BE: 집계 결과 반환
deactivate DB

BE -> BE: JSON 응답 생성
BE --> FE: 200 OK\n{data: [...], meta: {...}}
deactivate BE

FE -> FE: 데이터 변환\n(Recharts 형식)
FE -> FE: 평균 취업률 계산
FE -> FE: 차트 렌더링
FE --> User: Dual-axis Line Chart 표시\n+ Metric Card
deactivate FE

User -> FE: 데이터 포인트에 마우스 오버
activate FE
FE -> FE: Tooltip 표시\n(년도, 취업률, 수입액)
FE --> User: Tooltip 표시
deactivate FE

User -> FE: 학과 필터 선택\n(예: 컴퓨터공학과)
activate FE
FE -> FE: 필터 상태 업데이트
FE -> BE: GET /api/dashboard/department-kpi/\n?department=컴퓨터공학과&start_year=2019&end_year=2024
activate BE

BE -> DB: SELECT evaluation_year,\nemployment_rate,\ntech_transfer_income\nFROM department_kpis\nWHERE department='컴퓨터공학과'\nAND evaluation_year BETWEEN 2019 AND 2024\nORDER BY evaluation_year
activate DB
DB --> BE: 필터링된 결과 반환
deactivate DB

BE --> FE: 200 OK\n{data: [...]}
deactivate BE

FE -> FE: 차트 리렌더링
FE --> User: 필터링된 차트 표시
deactivate FE

@enduml
```

---

## 18. 구현 체크리스트

### 백엔드
- [ ] DRF ViewSet 구현 (`DepartmentKPIView`)
- [ ] Serializer 구현 (`DepartmentKPISerializer`)
- [ ] 쿼리 파라미터 검증 로직
- [ ] Django ORM 집계 쿼리 (GROUP BY 년도)
- [ ] 에러 핸들링 (400, 500)
- [ ] 단위 테스트 (최소 5개)
- [ ] 통합 테스트 (1개)

### 프런트엔드
- [ ] `useDashboardData.js` Hook에 KPI API 호출 추가
- [ ] `DualAxisLineChart.jsx` 컴포넌트 구현
- [ ] `MetricCard.jsx` 컴포넌트 구현 (평균 취업률)
- [ ] Recharts 설정 (Dual Y-axis, Legend, Tooltip)
- [ ] 학과/년도 필터 드롭다운 연동
- [ ] 빈 상태 UI
- [ ] 에러 상태 UI
- [ ] 로딩 스켈레톤
- [ ] 단위 테스트 (최소 3개)
- [ ] E2E 테스트 (1개)

### 문서
- [x] 상세 유스케이스 문서 작성
- [x] PlantUML Sequence Diagram
- [ ] API 문서 Swagger 추가
- [ ] 컴포넌트 Storybook 등록

---

## 19. 보안 요구사항 (MVP Simplified)

### 19.1 인증/인가

**읽기 전용 API (본 유스케이스):**
- `/api/dashboard/department-kpi/` 엔드포인트는 **인증 불필요**
- 이유: 내부 직원 전체가 읽기 전용 접근 가능 (CLAUDE.md 정책)
- 네트워크 레벨 보안: 대학 내부 네트워크 또는 VPN 접근만 허용 (인프라 설정)

**관리자 업로드 API (별도 spec 참조):**
- `POST /api/upload/` 엔드포인트는 `X-Admin-Key` 헤더 필수
- 검증 방식: 환경 변수 `ADMIN_API_KEY`와 비교
- 예시:
  ```http
  POST /api/upload/
  X-Admin-Key: {ADMIN_API_KEY}
  Content-Type: multipart/form-data
  ```

### 19.2 입력 검증 (Input Validation)

**쿼리 파라미터 검증 (DRF Serializer):**
```python
from rest_framework import serializers

class DepartmentKPIQuerySerializer(serializers.Serializer):
    """쿼리 파라미터 검증 Serializer"""
    department = serializers.CharField(
        required=False,
        default='all',
        max_length=100,
        allow_blank=False
    )
    start_year = serializers.IntegerField(
        required=False,
        min_value=2000,
        max_value=2100
    )
    end_year = serializers.IntegerField(
        required=False,
        min_value=2000,
        max_value=2100
    )

    def validate(self, data):
        """추가 검증: 년도 범위 체크"""
        start = data.get('start_year')
        end = data.get('end_year')
        if start and end and start > end:
            raise serializers.ValidationError(
                'start_year는 end_year보다 작거나 같아야 합니다.'
            )
        return data
```

**SQL Injection 방어:**
- Django ORM 사용으로 자동 이스케이프 처리
- Raw SQL 사용 금지 (MVP 범위 내에서는 불필요)

**데이터 타입 검증:**
- Section 10.4의 Django 모델 validators 활용
- Pandas 파싱 단계에서 1차 검증 (CSV 업로드 시)

### 19.3 XSS (Cross-Site Scripting) 방어

**프론트엔드 (React):**
- React의 자동 이스케이프 기능 활용
- JSX에서 데이터 바인딩 시 기본적으로 HTML 이스케이프
- `dangerouslySetInnerHTML` 사용 금지

**백엔드 (Django):**
- DRF Serializer를 통한 응답 데이터 직렬화
- JSON 응답에서 HTML 태그 이스케이프 (자동 처리)

**주의사항:**
- 본 유스케이스는 사용자 입력이 없는 **읽기 전용 대시보드**
- 학과명, 년도 등은 모두 시스템 생성 데이터
- XSS 위험도: 낮음

### 19.4 CSRF (Cross-Site Request Forgery) 방어

**GET 요청 (본 유스케이스):**
- CSRF 토큰 불필요 (읽기 전용 GET 요청)
- Django의 CSRF 미들웨어는 GET 요청 검증 생략

**POST 요청 (파일 업로드, 별도 spec):**
- Django CSRF 미들웨어 활용
- 프론트엔드에서 CSRF 토큰 자동 전송
- 예시:
  ```javascript
  // CSRF 토큰 획득 (쿠키에서)
  const csrfToken = document.cookie
    .split('; ')
    .find(row => row.startsWith('csrftoken='))
    ?.split('=')[1];

  // API 요청 시 헤더 추가
  fetch('/api/upload/', {
    method: 'POST',
    headers: {
      'X-CSRFToken': csrfToken,
      'X-Admin-Key': adminKey
    },
    body: formData
  });
  ```

### 19.5 데이터 보안

**데이터베이스 연결:**
- Supabase PostgreSQL 연결은 TLS 암호화
- Django `settings.py`에서 `CONN_MAX_AGE` 설정으로 연결 풀링

**환경 변수 관리:**
- `.env` 파일에 민감 정보 저장 (Git 제외)
- Railway 대시보드에서 환경 변수 관리
- 필수 환경 변수:
  ```bash
  DATABASE_URL=postgresql://...
  ADMIN_API_KEY=your-secret-key
  SECRET_KEY=django-secret-key
  DEBUG=False  # 프로덕션 환경
  ```

**로깅 및 모니터링:**
- 민감 정보 (API 키, 비밀번호) 로그 출력 금지
- 에러 로그에 스택 트레이스 포함 (개발 환경만)
- 프로덕션 환경에서는 Sentry 등 모니터링 도구 활용 (POST-MVP)

### 19.6 보안 체크리스트

**구현 전 필수 확인:**
- [ ] DRF Serializer로 쿼리 파라미터 검증
- [ ] Django 모델에 validators 적용
- [ ] 환경 변수로 민감 정보 관리 (.env 파일)
- [ ] Supabase 연결 TLS 암호화 확인
- [ ] React에서 dangerouslySetInnerHTML 미사용
- [ ] Django CSRF 미들웨어 활성화 (POST 요청용)
- [ ] DEBUG=False 설정 (프로덕션 배포 시)
- [ ] 에러 메시지에 민감 정보 노출 방지

**POST-MVP 고려사항:**
- Rate Limiting (API 요청 제한)
- JWT 기반 인증 (현재는 Hardcoded API Key)
- Content Security Policy (CSP) 헤더 추가
- HTTPS 강제 리다이렉트

---

## 20. 문서 승인

**작성자:** Spec Writer Agent
**검토자:** CTO
**승인일:** 2025-11-02
**버전:** 3.1

본 유스케이스 문서는 **P0-MVP** 범위로 학과 KPI 추이 대시보드 기능의 필수 요구사항만 포함합니다. TDD 원칙을 준수하여 테스트 작성 후 구현을 진행해야 합니다.

**v3.1 주요 개선사항:**
- 보안 요구사항 섹션 추가 (인증/인가, 입력 검증, XSS/CSRF 방어)
- 에러 코드 완전성 확보 (3개 누락 에러 코드 추가)
- DB 모델 제약 조건 명시 (validators)
- 테스트 커버리지 목표 정의

---

**문서 끝**
</file>

<file path="006-dashboard-filtering/plan.md">
# Dashboard Filtering Implementation Plan

## 1. 개요

대시보드 필터링 기능을 TDD 원칙에 따라 구현하기 위한 모듈화 설계 문서입니다. MVP 목표에 맞춰 **간결하면서도 확장 가능한 구조**를 유지하며, Red-Green-Refactor 사이클을 통해 점진적으로 구현합니다.

### 1.1 핵심 모듈 목록

**Backend (Django):**
- `api/validators.py` - 필터 파라미터 검증 로직 + 보안 검증 (CSRF, XSS, SQL Injection)
- **`api/error_codes.py`** - 표준화된 에러 코드 및 응답 포맷 (신규)
- `services/filtering_service.py` - 필터링 비즈니스 로직 및 집계
- **`utils/filter_helpers.py`** - 재사용 가능한 유틸리티 함수 (신규)
- `infrastructure/repositories.py` - Django ORM 쿼리 (기존 확장)
- `api/views.py` - 필터링 API 엔드포인트 (기존 확장)

**Frontend (React):**
- `hooks/useDashboardFilter.js` - 필터 상태 관리 및 디바운싱
- `hooks/useFilterOptions.js` - 필터 옵션 메타데이터 관리
- `hooks/useDashboardData.js` - 필터 기반 데이터 조회 (기존 확장)
- **`utils/filterHelpers.js`** - 재사용 가능한 유틸리티 함수 (신규)
- `components/dashboard/FilterPanel.jsx` - 필터 UI 컴포넌트
- `components/dashboard/EmptyState.jsx` - 필터 결과 없음 UI
- **`components/ui/ErrorToast.jsx`** - 에러 토스트 알림 컴포넌트 (신규)
- **`components/dashboard/ChartErrorCard.jsx`** - 차트 영역 에러 카드 컴포넌트 (신규)

**E2E Tests:**
- **`tests/e2e/dashboard-filtering.spec.js`** - Playwright E2E 테스트 (신규)

### 1.2 TDD 적용 범위

**Unit Tests (70%):**
- 필터 파라미터 검증 로직 (validators.py)
- 필터 조건 구성 로직 (filtering_service.py)
- React Hook 상태 관리 (useDashboardFilter.js)
- 디바운싱 로직

**Integration Tests (20%):**
- 필터링 API 엔드포인트 전체 플로우
- 병렬 API 호출 로직 (Promise.all)

**Acceptance Tests (10%):**
- 사용자 필터 선택 → 차트 업데이트 E2E 시나리오
- 필터 초기화 플로우

---

## 2. Architecture Diagram

```mermaid
graph TB
    subgraph Frontend
        A[FilterPanel.jsx] --> B[useDashboardFilter]
        A --> C[useFilterOptions]
        B --> D[useDashboardData]
        C --> E[dataApiClient]
        D --> E
    end

    subgraph Backend
        E --> F[views.py]
        F --> G[validators.py]
        F --> H[filtering_service.py]
        H --> I[repositories.py]
        I --> J[(Supabase)]
    end

    subgraph State Flow
        B -.300ms debounce.-> D
        D -.Promise.all.-> E
    end

    style B fill:#e1f5ff
    style H fill:#fff4e1
    style G fill:#ffe1e1
```

**데이터 흐름:**
1. 사용자가 `FilterPanel`에서 필터 선택
2. `useDashboardFilter`가 상태 업데이트 + 300ms 디바운싱
3. `useDashboardData`가 4개 API를 병렬 호출 (Promise.all)
4. Backend `views.py`가 요청 수신
5. `validators.py`로 파라미터 검증
6. `filtering_service.py`로 비즈니스 로직 위임
7. `repositories.py`로 Django ORM 쿼리 실행
8. 집계된 데이터를 JSON으로 응답
9. Frontend에서 차트 리렌더링

---

## 3. Implementation Plan

### 3.1 Backend - Filter Validators (api/validators.py)

**Location:** `backend/data_ingestion/api/validators.py` (신규 생성)

**Responsibility:**
- 필터 파라미터의 Whitelist 검증
- 타입 및 범위 검증
- 보안 취약점 방어 (SQL Injection, XSS)

**Test Strategy:** Unit Tests

**Test Scenarios (Red Phase):**

```python
# Test 1: 유효한 학과 필터 통과
def test_validate_department_filter_with_valid_department():
    # Arrange
    params = {'department': '컴퓨터공학과'}

    # Act & Assert
    validate_filter_params(params)  # Should not raise

# Test 2: 잘못된 학과 필터 거부
def test_validate_department_filter_with_invalid_department():
    # Arrange
    params = {'department': 'InvalidDept'}

    # Act & Assert
    with pytest.raises(ValidationError) as exc_info:
        validate_filter_params(params)
    assert 'department' in exc_info.value.detail

# Test 3: 유효한 연도 형식 (YYYY) 통과
def test_validate_year_filter_with_valid_year():
    # Arrange
    params = {'year': '2024'}

    # Act & Assert
    validate_filter_params(params)  # Should not raise

# Test 4: 잘못된 연도 형식 거부
def test_validate_year_filter_with_invalid_format():
    # Arrange
    params = {'year': '24'}  # 2-digit year

    # Act & Assert
    with pytest.raises(ValidationError) as exc_info:
        validate_filter_params(params)
    assert 'year' in exc_info.value.detail

# Test 5: 'latest' 키워드 허용
def test_validate_year_filter_with_latest_keyword():
    # Arrange
    params = {'year': 'latest'}

    # Act & Assert
    validate_filter_params(params)  # Should not raise

# Test 6: 학적상태 Enum 검증
def test_validate_enrollment_status_with_valid_values():
    # Arrange
    valid_statuses = ['재학', '졸업', '휴학', 'all']

    # Act & Assert
    for status in valid_statuses:
        validate_filter_params({'studentStatus': status})

# Test 7: 저널등급 Enum 검증
def test_validate_journal_tier_with_valid_values():
    # Arrange
    valid_tiers = ['SCIE', 'KCI', 'all']

    # Act & Assert
    for tier in valid_tiers:
        validate_filter_params({'journalTier': tier})

# Edge Case 1: 빈 파라미터 허용 (기본값 적용)
def test_validate_filter_params_with_empty_params():
    # Arrange
    params = {}

    # Act & Assert
    validate_filter_params(params)  # Should not raise

# Edge Case 2: SQL Injection 시도 거부
def test_validate_filter_params_reject_sql_injection():
    # Arrange
    params = {'department': "'; DROP TABLE students; --"}

    # Act & Assert
    with pytest.raises(ValidationError):
        validate_filter_params(params)

# Edge Case 3: XSS 시도 거부
def test_validate_filter_params_reject_xss():
    # Arrange
    params = {'department': '<script>alert("XSS")</script>'}

    # Act & Assert
    with pytest.raises(ValidationError):
        validate_filter_params(params)
```

**Implementation Order (TDD Cycle):**
1. Test 1 작성 → Fail (Red)
2. Whitelist 기반 학과 검증 로직 구현 → Pass (Green)
3. Test 2-7 순차 작성 및 구현
4. Edge Case 1-3 작성 및 구현
5. Refactor: 검증 로직을 함수로 분리 (DRY)

**Dependencies:**
- `rest_framework.exceptions.ValidationError`
- 학과/상태/등급 Whitelist 상수

---

### 3.1.1 Security Validation Requirements

**Location:** Integrated into `api/validators.py` and `api/views.py`

**Responsibility:**
- CSRF 토큰 검증
- 입력값 살균화 (Sanitization)
- SQL Injection 및 XSS 방어
- Rate Limiting

**Test Strategy:** Unit Tests + Integration Tests

**Security Specifications:**

```python
# REQUIRED: CSRF Protection
from django.views.decorators.csrf import csrf_protect
from django.utils.decorators import method_decorator

@method_decorator(csrf_protect, name='dispatch')
class FilteredDashboardView(APIView):
    """
    CSRF 보호가 활성화된 대시보드 필터링 뷰
    """
    pass

# REQUIRED: Input Sanitization
import re

def sanitize_filter_input(value: str) -> str:
    """
    필터 입력값에서 위험한 문자 제거.
    Whitelist: 영문자, 숫자, 한글, 하이픈, 언더스코어

    Args:
        value: 사용자 입력 필터 값

    Returns:
        살균화된 문자열

    Examples:
        sanitize_filter_input("컴퓨터공학과") -> "컴퓨터공학과"
        sanitize_filter_input("<script>alert('XSS')</script>") -> "scriptalertXSSscript"
    """
    return re.sub(r'[^\w가-힣\-_]', '', value)

# REQUIRED: Rate Limiting (MVP: Simple)
# settings.py
REST_FRAMEWORK = {
    'DEFAULT_THROTTLE_CLASSES': [
        'rest_framework.throttling.AnonRateThrottle',
        'rest_framework.throttling.UserRateThrottle',
    ],
    'DEFAULT_THROTTLE_RATES': {
        'anon': '10/minute',
        'user': '30/minute',
    }
}
```

**Test Scenarios (Red Phase):**

```python
# Test 1: CSRF 토큰 없이 요청 시 거부
def test_filter_api_requires_csrf_token():
    # Arrange
    client = APIClient(enforce_csrf_checks=True)
    url = '/api/dashboard/research-funding/'
    params = {'department': '컴퓨터공학과'}

    # Act
    response = client.get(url, params)

    # Assert
    assert response.status_code == 403  # CSRF token missing

# Test 2: CSRF 토큰이 있으면 허용
def test_filter_api_accepts_valid_csrf_token():
    # Arrange
    client = APIClient(enforce_csrf_checks=True)
    url = '/api/dashboard/research-funding/'

    # Get CSRF token
    csrf_token = client.get('/api/csrf-token/').cookies['csrftoken'].value

    # Act
    response = client.get(url, {'department': '컴퓨터공학과'}, HTTP_X_CSRFTOKEN=csrf_token)

    # Assert
    assert response.status_code == 200

# Test 3: Rate Limiting - 11번째 요청 거부
def test_filter_api_rate_limit():
    # Arrange
    client = APIClient()
    url = '/api/dashboard/research-funding/'

    # Act: Make 11 requests rapidly
    responses = []
    for _ in range(11):
        responses.append(client.get(url))

    # Assert
    assert responses[-1].status_code == 429  # Too many requests
    assert 'Retry-After' in responses[-1].headers

# Test 4: 입력값 살균화 - XSS 차단
def test_sanitize_filter_input_removes_xss():
    # Arrange
    malicious_input = "<script>alert('XSS')</script>"

    # Act
    sanitized = sanitize_filter_input(malicious_input)

    # Assert
    assert '<' not in sanitized
    assert '>' not in sanitized
    assert 'script' not in sanitized

# Test 5: 입력값 살균화 - SQL Injection 차단
def test_sanitize_filter_input_removes_sql_injection():
    # Arrange
    malicious_input = "'; DROP TABLE students; --"

    # Act
    sanitized = sanitize_filter_input(malicious_input)

    # Assert
    assert ';' not in sanitized
    assert '--' not in sanitized
    assert 'DROP' not in sanitized

# Test 6: 입력값 살균화 - 한글 보존
def test_sanitize_filter_input_preserves_korean():
    # Arrange
    korean_input = "컴퓨터공학과"

    # Act
    sanitized = sanitize_filter_input(korean_input)

    # Assert
    assert sanitized == "컴퓨터공학과"

# Test 7: 입력값 살균화 - 하이픈/언더스코어 보존
def test_sanitize_filter_input_preserves_hyphen_underscore():
    # Arrange
    valid_input = "2024-01_data"

    # Act
    sanitized = sanitize_filter_input(valid_input)

    # Assert
    assert sanitized == "2024-01_data"
```

**Implementation Order (TDD Cycle):**
1. Test 1-2 작성 → CSRF 보호 미들웨어 설정
2. Test 3 작성 → DRF Throttling 설정
3. Test 4-7 작성 → sanitize_filter_input 함수 구현
4. Refactor: 살균화 로직을 validator에 통합

**Dependencies:**
- `django.views.decorators.csrf`
- `rest_framework.throttling`
- Python `re` module

---

### 3.2 Backend - Filtering Service (services/filtering_service.py)

**Location:** `backend/data_ingestion/services/filtering_service.py` (신규 생성)

**Responsibility:**
- 필터 조건에 따른 동적 쿼리 조건 구성
- 집계 로직 실행 (잔액, 추이, 학생 수 등)
- 비즈니스 규칙 적용 (AND 조건 결합)

**Test Strategy:** Unit Tests

**Test Scenarios (Red Phase):**

```python
# Test 1: 학과 필터 적용 시 WHERE 절 생성
def test_build_filter_conditions_with_department():
    # Arrange
    filters = {'department': '컴퓨터공학과', 'year': 'latest'}

    # Act
    conditions = FilteringService._build_filter_conditions(filters)

    # Assert
    assert conditions['department'] == '컴퓨터공학과'
    assert 'execution_date__gte' in conditions

# Test 2: 연도 필터 (YYYY) 적용
def test_build_filter_conditions_with_year():
    # Arrange
    filters = {'year': '2024'}

    # Act
    conditions = FilteringService._build_filter_conditions(filters)

    # Assert
    assert conditions['execution_date__year'] == 2024

# Test 3: 'latest' 키워드는 최근 1년 범위로 변환
def test_build_filter_conditions_with_latest_keyword():
    # Arrange
    filters = {'year': 'latest'}

    # Act
    conditions = FilteringService._build_filter_conditions(filters)

    # Assert
    assert 'execution_date__gte' in conditions
    # 날짜가 현재 - 365일인지 검증

# Test 4: 다중 필터 AND 조건 결합
def test_build_filter_conditions_with_multiple_filters():
    # Arrange
    filters = {'department': '컴퓨터공학과', 'year': '2024', 'studentStatus': '재학'}

    # Act
    conditions = FilteringService._build_filter_conditions(filters)

    # Assert
    assert conditions['department'] == '컴퓨터공학과'
    assert conditions['execution_date__year'] == 2024
    assert conditions['enrollment_status'] == '재학'

# Test 5: 'all' 값은 필터 조건에서 제외
def test_build_filter_conditions_exclude_all_keyword():
    # Arrange
    filters = {'department': 'all', 'year': 'latest'}

    # Act
    conditions = FilteringService._build_filter_conditions(filters)

    # Assert
    assert 'department' not in conditions

# Test 6: 연구비 잔액 계산 (총연구비 - 집행금액)
def test_calculate_research_balance(research_projects_fixture):
    # Arrange
    queryset = ResearchProject.objects.filter(department='컴퓨터공학과')

    # Act
    balance = FilteringService._calculate_balance(queryset)

    # Assert
    expected_balance = sum(p.total_budget for p in queryset) - sum(p.execution_amount for p in queryset)
    assert balance == expected_balance

# Test 7: 월별 집행 추이 집계
def test_calculate_monthly_trend(research_projects_fixture):
    # Arrange
    queryset = ResearchProject.objects.filter(department='컴퓨터공학과')

    # Act
    trend = FilteringService._calculate_monthly_trend(queryset)

    # Assert
    assert isinstance(trend, list)
    assert all('month' in item and 'execution_amount' in item for item in trend)

# Test 8: 학과별 학생 수 집계 (과정별 breakdown)
def test_calculate_student_breakdown(students_fixture):
    # Arrange
    queryset = Student.objects.filter(department='컴퓨터공학과', enrollment_status='재학')

    # Act
    breakdown = FilteringService._calculate_student_breakdown(queryset)

    # Assert
    assert '학사' in breakdown
    assert '석사' in breakdown
    assert isinstance(breakdown['학사'], int)

# Edge Case 1: 빈 쿼리셋 처리
def test_calculate_balance_with_empty_queryset():
    # Arrange
    queryset = ResearchProject.objects.none()

    # Act
    balance = FilteringService._calculate_balance(queryset)

    # Assert
    assert balance == 0

# Edge Case 2: NULL Impact Factor 처리
def test_calculate_avg_impact_factor_with_nulls(publications_fixture):
    # Arrange
    queryset = Publication.objects.filter(journal_tier='KCI')  # IF가 NULL일 수 있음

    # Act
    avg_if = FilteringService._calculate_avg_impact_factor(queryset)

    # Assert
    # NULL 제외하고 평균 계산되어야 함
    assert avg_if is not None or queryset.filter(impact_factor__isnull=False).count() == 0
```

**Implementation Order (TDD Cycle):**
1. Test 1-2 작성 → 필터 조건 구성 로직 구현
2. Test 3-5 작성 → 특수 키워드 처리
3. Test 6-8 작성 → 집계 로직 구현
4. Edge Cases → 엣지 케이스 처리
5. Refactor: 집계 함수들을 별도 메서드로 분리

**Dependencies:**
- `infrastructure.repositories.ResearchProjectRepository`
- Django ORM aggregation (Sum, Avg, Count)

---

### 3.3 Backend - API Views (api/views.py 확장)

**Location:** `backend/data_ingestion/api/views.py` (기존 확장)

**Responsibility:**
- 쿼리 파라미터 파싱
- Validator 호출
- Service Layer 위임 (Thin Controller)
- 에러 응답 표준화

**Test Strategy:** Integration Tests

**Test Scenarios (Red Phase):**

```python
# Test 1: GET /api/dashboard/research-funding/?department=컴퓨터공학과
def test_research_funding_filter_by_department(api_client, research_projects_fixture):
    # Arrange
    url = '/api/dashboard/research-funding/'
    params = {'department': '컴퓨터공학과'}

    # Act
    response = api_client.get(url, params)

    # Assert
    assert response.status_code == 200
    data = response.json()
    assert 'current_balance' in data
    assert 'trend' in data

# Test 2: GET /api/dashboard/students/?status=재학
def test_students_filter_by_enrollment_status(api_client, students_fixture):
    # Arrange
    url = '/api/dashboard/students/'
    params = {'status': '재학'}

    # Act
    response = api_client.get(url, params)

    # Assert
    assert response.status_code == 200
    data = response.json()
    assert data['total_students'] > 0

# Test 3: 다중 필터 조합 (학과 + 연도)
def test_research_funding_filter_by_department_and_year(api_client, research_projects_fixture):
    # Arrange
    url = '/api/dashboard/research-funding/'
    params = {'department': '컴퓨터공학과', 'year': '2024'}

    # Act
    response = api_client.get(url, params)

    # Assert
    assert response.status_code == 200
    # 응답 데이터가 필터 조건을 만족하는지 검증

# Test 4: 잘못된 필터 값 → 400 Bad Request
def test_research_funding_filter_with_invalid_department(api_client):
    # Arrange
    url = '/api/dashboard/research-funding/'
    params = {'department': 'InvalidDept'}

    # Act
    response = api_client.get(url, params)

    # Assert
    assert response.status_code == 400
    data = response.json()
    assert data['error'] == 'invalid_parameter'
    assert 'department' in data['details']

# Test 5: 필터 결과 없음 → 빈 배열 반환
def test_research_funding_filter_with_no_results(api_client):
    # Arrange
    url = '/api/dashboard/research-funding/'
    params = {'department': '존재하지않는학과', 'year': '2024'}

    # Act
    response = api_client.get(url, params)

    # Assert
    assert response.status_code == 200  # 빈 결과도 성공 응답
    data = response.json()
    assert data['current_balance'] == 0
    assert data['trend'] == []

# Test 6: GET /api/dashboard/filter-options/ - 필터 옵션 메타데이터
def test_get_filter_options(api_client, research_projects_fixture, students_fixture):
    # Arrange
    url = '/api/dashboard/filter-options/'

    # Act
    response = api_client.get(url)

    # Assert
    assert response.status_code == 200
    data = response.json()
    assert 'departments' in data
    assert 'years' in data
    assert 'student_statuses' in data
    assert 'journal_tiers' in data
    assert '컴퓨터공학과' in data['departments']

# Edge Case 1: 파라미터 없이 호출 시 기본값 적용
def test_research_funding_filter_without_params(api_client, research_projects_fixture):
    # Arrange
    url = '/api/dashboard/research-funding/'

    # Act
    response = api_client.get(url)

    # Assert
    assert response.status_code == 200
    # 기본값(department=all, year=latest) 적용됨

# Edge Case 2: 서버 에러 시 500 응답
def test_research_funding_filter_with_server_error(api_client, mocker):
    # Arrange
    url = '/api/dashboard/research-funding/'
    mocker.patch('services.filtering_service.FilteringService.get_research_funding', side_effect=Exception('DB Error'))

    # Act
    response = api_client.get(url)

    # Assert
    assert response.status_code == 500
    data = response.json()
    assert data['error'] == 'server_error'
```

**Implementation Order (TDD Cycle):**
1. Test 1 작성 → research_funding_view 필터 기능 추가
2. Test 2-3 작성 → 다른 엔드포인트에 필터 기능 추가
3. Test 4-5 작성 → 에러 핸들링 추가
4. Test 6 작성 → filter-options API 구현
5. Edge Cases → 엣지 케이스 처리
6. Refactor: 에러 응답 포맷을 공통 함수로 추출

**Dependencies:**
- `api.validators.validate_filter_params`
- `services.filtering_service.FilteringService`
- DRF Serializers (기존)

---

### 3.3.1 Error Response Specification

**Location:** `backend/data_ingestion/api/error_codes.py` (신규 생성)

**Responsibility:**
- 표준화된 에러 코드 정의
- 일관된 에러 응답 포맷 제공
- 프론트엔드와 에러 코드 계약 명시

**Error Code Definitions:**

```python
# api/error_codes.py (NEW FILE)

class FilterErrorCode:
    """
    대시보드 필터링 API의 표준 에러 코드.
    프론트엔드와 계약(Contract)으로 사용.
    """
    VALIDATION_ERROR = 'validation_error'
    INVALID_PARAMETER = 'invalid_parameter'
    SERVER_ERROR = 'server_error'
    RATE_LIMIT_EXCEEDED = 'rate_limit_exceeded'
    NO_DATA_FOUND = 'no_data_found'
    CSRF_ERROR = 'csrf_error'

# Standard Error Response Format
# {
#   "error": "invalid_parameter",  # Error code from FilterErrorCode
#   "message": "유효하지 않은 파라미터입니다.",  # User-friendly Korean message
#   "details": {
#     "field": "department",
#     "value": "InvalidDept",
#     "valid_values": ["전체 학과", "컴퓨터공학과", "전자공학과"]
#   },
#   "timestamp": "2025-11-02T14:35:22Z",
#   "request_id": "a1b2c3d4"  # For debugging
# }


def format_error_response(error_code: str, message: str, details: dict = None) -> dict:
    """
    표준화된 에러 응답 생성.

    Args:
        error_code: FilterErrorCode 클래스의 에러 코드
        message: 사용자에게 표시할 한글 메시지
        details: 추가 상세 정보 (선택적)

    Returns:
        표준 포맷의 에러 응답 딕셔너리

    Examples:
        format_error_response(
            FilterErrorCode.INVALID_PARAMETER,
            "유효하지 않은 학과입니다.",
            {"field": "department", "value": "InvalidDept"}
        )
    """
    import uuid
    from datetime import datetime

    response = {
        "error": error_code,
        "message": message,
        "timestamp": datetime.utcnow().isoformat() + 'Z',
        "request_id": str(uuid.uuid4())[:8]
    }

    if details:
        response["details"] = details

    return response
```

**Test Strategy:** Unit Tests

**Test Scenarios (Red Phase):**

```python
# Test 1: 에러 응답 포맷 검증
def test_format_error_response_basic():
    # Arrange
    error_code = FilterErrorCode.INVALID_PARAMETER
    message = "유효하지 않은 파라미터입니다."

    # Act
    response = format_error_response(error_code, message)

    # Assert
    assert response['error'] == 'invalid_parameter'
    assert response['message'] == message
    assert 'timestamp' in response
    assert 'request_id' in response

# Test 2: 에러 응답에 details 포함
def test_format_error_response_with_details():
    # Arrange
    error_code = FilterErrorCode.VALIDATION_ERROR
    message = "필터 검증 실패"
    details = {"field": "year", "value": "invalid", "reason": "형식 오류"}

    # Act
    response = format_error_response(error_code, message, details)

    # Assert
    assert response['details'] == details
    assert response['details']['field'] == 'year'

# Test 3: timestamp가 ISO 8601 형식
def test_format_error_response_timestamp_format():
    # Arrange & Act
    response = format_error_response(FilterErrorCode.SERVER_ERROR, "서버 오류")

    # Assert
    assert response['timestamp'].endswith('Z')
    # ISO 8601 형식 검증
    from datetime import datetime
    datetime.fromisoformat(response['timestamp'].replace('Z', '+00:00'))  # Should not raise

# Test 4: request_id가 고유함
def test_format_error_response_unique_request_id():
    # Arrange & Act
    response1 = format_error_response(FilterErrorCode.SERVER_ERROR, "오류 1")
    response2 = format_error_response(FilterErrorCode.SERVER_ERROR, "오류 2")

    # Assert
    assert response1['request_id'] != response2['request_id']

# Integration Test: API가 표준 에러 응답 반환
def test_filter_api_returns_standard_error_format(api_client):
    # Arrange
    url = '/api/dashboard/research-funding/'
    params = {'department': 'InvalidDept'}

    # Act
    response = api_client.get(url, params)

    # Assert
    assert response.status_code == 400
    data = response.json()
    assert data['error'] == FilterErrorCode.INVALID_PARAMETER
    assert 'message' in data
    assert 'details' in data
    assert 'timestamp' in data
    assert 'request_id' in data
    assert data['details']['field'] == 'department'

# Integration Test: Rate Limit 초과 시 에러 코드
def test_filter_api_rate_limit_error_code(api_client):
    # Arrange
    url = '/api/dashboard/research-funding/'

    # Act: 11번 요청
    for _ in range(10):
        api_client.get(url)

    response = api_client.get(url)

    # Assert
    assert response.status_code == 429
    data = response.json()
    assert data['error'] == FilterErrorCode.RATE_LIMIT_EXCEEDED
    assert '잠시 후 다시 시도' in data['message']

# Integration Test: 서버 에러 시 에러 코드
def test_filter_api_server_error_code(api_client, mocker):
    # Arrange
    url = '/api/dashboard/research-funding/'
    mocker.patch('services.filtering_service.FilteringService.get_research_funding', side_effect=Exception('DB Error'))

    # Act
    response = api_client.get(url)

    # Assert
    assert response.status_code == 500
    data = response.json()
    assert data['error'] == FilterErrorCode.SERVER_ERROR
    assert '일시적인 오류' in data['message']
    assert 'request_id' in data  # 디버깅용
```

**Error Code Usage in views.py:**

```python
# api/views.py
from .error_codes import FilterErrorCode, format_error_response
from rest_framework.response import Response
from rest_framework import status

class ResearchFundingView(APIView):
    def get(self, request):
        try:
            # Validation
            validate_filter_params(request.query_params)

            # Service logic
            data = FilteringService.get_research_funding(request.query_params)

            return Response(data, status=status.HTTP_200_OK)

        except ValidationError as e:
            return Response(
                format_error_response(
                    FilterErrorCode.VALIDATION_ERROR,
                    "필터 파라미터 검증에 실패했습니다.",
                    {"validation_errors": e.detail}
                ),
                status=status.HTTP_400_BAD_REQUEST
            )

        except ValueError as e:
            return Response(
                format_error_response(
                    FilterErrorCode.INVALID_PARAMETER,
                    str(e),
                    {"parameter": request.query_params}
                ),
                status=status.HTTP_400_BAD_REQUEST
            )

        except Exception as e:
            logger.error(f"Unexpected error in filtering: {str(e)}", exc_info=True)
            return Response(
                format_error_response(
                    FilterErrorCode.SERVER_ERROR,
                    "일시적인 오류가 발생했습니다. 잠시 후 다시 시도해주세요.",
                    None  # 보안을 위해 내부 에러 상세 정보는 숨김
                ),
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )
```

**Implementation Order (TDD Cycle):**
1. Test 1-4 작성 → format_error_response 함수 구현
2. Integration Tests 작성 → views.py에 에러 핸들링 추가
3. Refactor: 에러 메시지를 constants.py로 분리

**Dependencies:**
- Python `uuid` module
- Python `datetime` module
- DRF `Response`, `status`

---

### 3.4 Frontend - Filter State Hook (hooks/useDashboardFilter.js)

**Location:** `frontend/src/hooks/useDashboardFilter.js` (신규 생성)

**Responsibility:**
- 필터 상태 관리 (React State)
- 디바운싱 로직 (300ms)
- 필터 변경/초기화 핸들러

**Test Strategy:** Unit Tests

**Test Scenarios (Red Phase):**

```javascript
// Test 1: 초기 상태 값 확인
test('useDashboardFilter should initialize with default filter values', () => {
  // Arrange & Act
  const { result } = renderHook(() => useDashboardFilter());

  // Assert
  expect(result.current.filters.department).toBe('all');
  expect(result.current.filters.year).toBe('latest');
  expect(result.current.filters.studentStatus).toBe('all');
  expect(result.current.filters.journalTier).toBe('all');
  expect(result.current.isFilterApplied).toBe(false);
});

// Test 2: 필터 변경 시 state 업데이트
test('handleFilterChange should update filter state', () => {
  // Arrange
  const { result } = renderHook(() => useDashboardFilter());

  // Act
  act(() => {
    result.current.handleFilterChange('department', '컴퓨터공학과');
  });

  // Assert
  expect(result.current.filters.department).toBe('컴퓨터공학과');
});

// Test 3: 디바운싱 - 300ms 이전에는 isFilterApplied가 false
test('handleFilterChange should debounce for 300ms', async () => {
  // Arrange
  jest.useFakeTimers();
  const { result } = renderHook(() => useDashboardFilter());

  // Act
  act(() => {
    result.current.handleFilterChange('department', '컴퓨터공학과');
    jest.advanceTimersByTime(299);
  });

  // Assert
  expect(result.current.isFilterApplied).toBe(false);

  // Cleanup
  jest.useRealTimers();
});

// Test 4: 디바운싱 - 300ms 후에 isFilterApplied가 true
test('handleFilterChange should set isFilterApplied to true after 300ms', async () => {
  // Arrange
  jest.useFakeTimers();
  const { result } = renderHook(() => useDashboardFilter());

  // Act
  act(() => {
    result.current.handleFilterChange('department', '컴퓨터공학과');
    jest.advanceTimersByTime(300);
  });

  // Assert
  expect(result.current.isFilterApplied).toBe(true);

  // Cleanup
  jest.useRealTimers();
});

// Test 5: 빠른 연속 변경 시 마지막 값만 적용 (디바운싱)
test('handleFilterChange should debounce rapid changes', async () => {
  // Arrange
  jest.useFakeTimers();
  const { result } = renderHook(() => useDashboardFilter());

  // Act
  act(() => {
    result.current.handleFilterChange('department', '컴퓨터공학과');
    jest.advanceTimersByTime(100);
    result.current.handleFilterChange('department', '전자공학과');
    jest.advanceTimersByTime(100);
    result.current.handleFilterChange('department', '기계공학과');
    jest.advanceTimersByTime(300);
  });

  // Assert
  expect(result.current.filters.department).toBe('기계공학과');
  expect(result.current.isFilterApplied).toBe(true);

  // Cleanup
  jest.useRealTimers();
});

// Test 6: 필터 초기화
test('handleResetFilters should reset all filters to default', () => {
  // Arrange
  const { result } = renderHook(() => useDashboardFilter());

  act(() => {
    result.current.handleFilterChange('department', '컴퓨터공학과');
    result.current.handleFilterChange('year', '2024');
  });

  // Act
  act(() => {
    result.current.handleResetFilters();
  });

  // Assert
  expect(result.current.filters.department).toBe('all');
  expect(result.current.filters.year).toBe('latest');
  expect(result.current.isFilterApplied).toBe(false);
});

// Test 7: Cleanup on unmount - 디바운스 타이머 정리
test('should cleanup debounce timer on unmount', () => {
  // Arrange
  jest.useFakeTimers();
  const clearTimeoutSpy = jest.spyOn(global, 'clearTimeout');
  const { result, unmount } = renderHook(() => useDashboardFilter());

  // Act
  act(() => {
    result.current.handleFilterChange('department', '컴퓨터공학과');
  });

  unmount();

  // Assert
  expect(clearTimeoutSpy).toHaveBeenCalled();

  // Cleanup
  jest.useRealTimers();
  clearTimeoutSpy.mockRestore();
});
```

**Implementation Order (TDD Cycle):**
1. Test 1 작성 → 기본 Hook 구조 및 초기값 설정
2. Test 2 작성 → handleFilterChange 구현
3. Test 3-5 작성 → 디바운싱 로직 구현 (useRef + setTimeout)
4. Test 6 작성 → handleResetFilters 구현
5. Test 7 작성 → useEffect cleanup 추가
6. Refactor: 디바운스 로직을 커스텀 Hook으로 분리 고려

**Dependencies:**
- React (useState, useRef, useEffect, useCallback)

---

### 3.5 Frontend - Filter Options Hook (hooks/useFilterOptions.js)

**Location:** `frontend/src/hooks/useFilterOptions.js` (신규 생성)

**Responsibility:**
- 필터 옵션 메타데이터 로딩 (학과 목록, 연도 목록 등)
- API 실패 시 Fallback 기본값 제공
- 로딩 상태 관리

**Test Strategy:** Unit Tests

**Test Scenarios (Red Phase):**

```javascript
// Test 1: 성공 시 필터 옵션 로드
test('useFilterOptions should fetch and set filter options', async () => {
  // Arrange
  const mockOptions = {
    departments: ['전체 학과', '컴퓨터공학과', '전자공학과'],
    years: ['최근 1년', '2024년', '2023년'],
    student_statuses: ['전체', '재학', '졸업'],
    journal_tiers: ['SCIE', 'KCI']
  };

  jest.spyOn(dataApiClient, 'get').mockResolvedValue({ data: mockOptions });

  // Act
  const { result, waitForNextUpdate } = renderHook(() => useFilterOptions());
  await waitForNextUpdate();

  // Assert
  expect(result.current.options).toEqual(mockOptions);
  expect(result.current.isLoading).toBe(false);
});

// Test 2: API 실패 시 기본값 유지
test('useFilterOptions should use default options on API failure', async () => {
  // Arrange
  jest.spyOn(dataApiClient, 'get').mockRejectedValue(new Error('Network error'));
  jest.spyOn(console, 'warn').mockImplementation(() => {});

  // Act
  const { result, waitForNextUpdate } = renderHook(() => useFilterOptions());
  await waitForNextUpdate();

  // Assert
  expect(result.current.options.departments).toContain('전체 학과');
  expect(result.current.isLoading).toBe(false);
  expect(console.warn).toHaveBeenCalled();

  // Cleanup
  console.warn.mockRestore();
});

// Test 3: 초기 로딩 상태 확인
test('useFilterOptions should start with isLoading true', () => {
  // Arrange & Act
  const { result } = renderHook(() => useFilterOptions());

  // Assert
  expect(result.current.isLoading).toBe(true);
});

// Test 4: API 호출은 마운트 시 1회만
test('useFilterOptions should fetch options only once on mount', async () => {
  // Arrange
  const getSpy = jest.spyOn(dataApiClient, 'get').mockResolvedValue({ data: {} });

  // Act
  const { rerender, waitForNextUpdate } = renderHook(() => useFilterOptions());
  await waitForNextUpdate();

  rerender();
  rerender();

  // Assert
  expect(getSpy).toHaveBeenCalledTimes(1);

  // Cleanup
  getSpy.mockRestore();
});
```

**Implementation Order (TDD Cycle):**
1. Test 1 작성 → API 호출 및 성공 케이스 구현
2. Test 2 작성 → 에러 핸들링 및 Fallback
3. Test 3-4 작성 → 로딩 상태 및 useEffect 의존성 관리
4. Refactor: 기본값 상수를 별도 파일로 분리

**Dependencies:**
- `api/dataApiClient.js`
- React (useState, useEffect)

---

### 3.6 Frontend - Data Fetching Hook (hooks/useDashboardData.js 확장)

**Location:** `frontend/src/hooks/useDashboardData.js` (기존 확장)

**Responsibility:**
- 필터 파라미터를 포함한 API 호출
- 4개 API 병렬 호출 (Promise.all)
- 로딩 및 에러 상태 관리

**Test Strategy:** Integration Tests

**Test Scenarios (Red Phase):**

```javascript
// Test 1: 필터 변경 시 API 재호출
test('useDashboardData should refetch when filters change', async () => {
  // Arrange
  const getSpy = jest.spyOn(dataApiClient, 'get').mockResolvedValue({ data: {} });
  const initialFilters = { department: 'all', year: 'latest' };

  // Act
  const { result, rerender, waitForNextUpdate } = renderHook(
    ({ filters }) => useDashboardData(filters),
    { initialProps: { filters: initialFilters } }
  );

  await waitForNextUpdate();

  const newFilters = { department: '컴퓨터공학과', year: '2024' };
  rerender({ filters: newFilters });

  await waitForNextUpdate();

  // Assert
  expect(getSpy).toHaveBeenCalledTimes(8);  // 초기 4회 + 재호출 4회
  expect(getSpy).toHaveBeenCalledWith('/api/dashboard/research-funding/', { params: newFilters });

  // Cleanup
  getSpy.mockRestore();
});

// Test 2: Promise.all로 4개 API 병렬 호출
test('useDashboardData should fetch all APIs in parallel', async () => {
  // Arrange
  const mockResponses = [
    { data: { current_balance: 1530000000 } },
    { data: { total_students: 1234 } },
    { data: { total_papers: 156 } },
    { data: { trend: [] } }
  ];

  const getSpy = jest.spyOn(dataApiClient, 'get')
    .mockImplementation((url) => {
      if (url.includes('research-funding')) return Promise.resolve(mockResponses[0]);
      if (url.includes('students')) return Promise.resolve(mockResponses[1]);
      if (url.includes('publications')) return Promise.resolve(mockResponses[2]);
      if (url.includes('department-kpi')) return Promise.resolve(mockResponses[3]);
    });

  // Act
  const { result, waitForNextUpdate } = renderHook(() =>
    useDashboardData({ department: 'all', year: 'latest' })
  );

  await waitForNextUpdate();

  // Assert
  expect(result.current.data.researchFunding).toEqual(mockResponses[0].data);
  expect(result.current.data.students).toEqual(mockResponses[1].data);
  expect(result.current.data.publications).toEqual(mockResponses[2].data);
  expect(result.current.data.departmentKpi).toEqual(mockResponses[3].data);

  // Cleanup
  getSpy.mockRestore();
});

// Test 3: API 에러 시 에러 상태 설정
test('useDashboardData should set error state on API failure', async () => {
  // Arrange
  const error = new Error('Network error');
  jest.spyOn(dataApiClient, 'get').mockRejectedValue(error);
  jest.spyOn(console, 'error').mockImplementation(() => {});

  // Act
  const { result, waitForNextUpdate } = renderHook(() =>
    useDashboardData({ department: 'all', year: 'latest' })
  );

  await waitForNextUpdate();

  // Assert
  expect(result.current.error).toBe(error);
  expect(result.current.isLoading).toBe(false);

  // Cleanup
  console.error.mockRestore();
});

// Test 4: 로딩 상태 관리
test('useDashboardData should manage loading state correctly', async () => {
  // Arrange
  jest.spyOn(dataApiClient, 'get').mockResolvedValue({ data: {} });

  // Act
  const { result, waitForNextUpdate } = renderHook(() =>
    useDashboardData({ department: 'all', year: 'latest' })
  );

  // Assert - 초기 로딩
  expect(result.current.isLoading).toBe(true);

  await waitForNextUpdate();

  // Assert - 로딩 완료
  expect(result.current.isLoading).toBe(false);
});
```

**Implementation Order (TDD Cycle):**
1. Test 1 작성 → filters를 useEffect 의존성에 추가
2. Test 2 작성 → Promise.all 병렬 호출 구현
3. Test 3-4 작성 → 에러 및 로딩 상태 관리
4. Refactor: API 호출 로직을 별도 함수로 추출

**Dependencies:**
- `api/dataApiClient.js`
- React (useState, useEffect)

---

### 3.7 Frontend - Filter Panel Component (components/dashboard/FilterPanel.jsx)

**Location:** `frontend/src/components/dashboard/FilterPanel.jsx` (신규 생성)

**Responsibility:**
- 필터 UI 렌더링 (드롭다운, 라디오, 체크박스)
- 사용자 입력 이벤트 핸들링
- 필터 초기화 버튼

**Test Strategy:** Unit Tests (Presentation Layer는 최소 테스트)

**Test Scenarios (Red Phase):**

```javascript
// Test 1: 필터 드롭다운 렌더링
test('FilterPanel should render department dropdown', () => {
  // Arrange
  const mockProps = {
    filters: { department: 'all' },
    onFilterChange: jest.fn(),
    onReset: jest.fn(),
    isApplied: false
  };

  // Act
  render(<FilterPanel {...mockProps} />);

  // Assert
  expect(screen.getByTestId('department-filter')).toBeInTheDocument();
});

// Test 2: 드롭다운 선택 시 onFilterChange 호출
test('FilterPanel should call onFilterChange when dropdown value changes', () => {
  // Arrange
  const mockOnFilterChange = jest.fn();
  const mockProps = {
    filters: { department: 'all' },
    onFilterChange: mockOnFilterChange,
    onReset: jest.fn(),
    isApplied: false
  };

  // Act
  render(<FilterPanel {...mockProps} />);
  const dropdown = screen.getByTestId('department-filter');

  fireEvent.change(dropdown, { target: { value: '컴퓨터공학과' } });

  // Assert
  expect(mockOnFilterChange).toHaveBeenCalledWith('department', '컴퓨터공학과');
});

// Test 3: 필터 초기화 버튼 클릭 시 onReset 호출
test('FilterPanel should call onReset when reset button is clicked', () => {
  // Arrange
  const mockOnReset = jest.fn();
  const mockProps = {
    filters: { department: '컴퓨터공학과' },
    onFilterChange: jest.fn(),
    onReset: mockOnReset,
    isApplied: true
  };

  // Act
  render(<FilterPanel {...mockProps} />);
  const resetButton = screen.getByText('전체 보기');

  fireEvent.click(resetButton);

  // Assert
  expect(mockOnReset).toHaveBeenCalled();
});

// Test 4: isApplied=true일 때 초기화 버튼 활성화
test('FilterPanel should enable reset button when filters are applied', () => {
  // Arrange
  const mockProps = {
    filters: { department: '컴퓨터공학과' },
    onFilterChange: jest.fn(),
    onReset: jest.fn(),
    isApplied: true
  };

  // Act
  render(<FilterPanel {...mockProps} />);
  const resetButton = screen.getByText('전체 보기');

  // Assert
  expect(resetButton).not.toBeDisabled();
});

// Test 5: isApplied=false일 때 초기화 버튼 비활성화
test('FilterPanel should disable reset button when no filters are applied', () => {
  // Arrange
  const mockProps = {
    filters: { department: 'all' },
    onFilterChange: jest.fn(),
    onReset: jest.fn(),
    isApplied: false
  };

  // Act
  render(<FilterPanel {...mockProps} />);
  const resetButton = screen.getByText('전체 보기');

  // Assert
  expect(resetButton).toBeDisabled();
});
```

**Implementation Order (TDD Cycle):**
1. Test 1 작성 → 기본 컴포넌트 구조 및 드롭다운 렌더링
2. Test 2 작성 → onChange 이벤트 핸들러 연결
3. Test 3-5 작성 → 초기화 버튼 구현
4. Refactor: 드롭다운을 재사용 가능한 컴포넌트로 분리

**Dependencies:**
- React
- UI 라이브러리 (선택적)

**QA Sheet (Presentation Layer):**

수동 테스트 항목:
- [ ] 드롭다운 클릭 시 옵션 목록이 표시됨
- [ ] 옵션 선택 시 드롭다운에 선택 값이 반영됨
- [ ] 필터 초기화 버튼 클릭 시 모든 드롭다운이 기본값으로 변경됨
- [ ] 필터 적용 시 "전체 보기" 버튼이 활성화되고 색상이 변경됨
- [ ] 키보드 네비게이션 (Tab, Enter)이 정상 작동함
- [ ] 모바일 화면에서도 드롭다운이 정상 표시됨

---

### 3.8 Frontend - Empty State Component (components/dashboard/EmptyState.jsx)

**Location:** `frontend/src/components/dashboard/EmptyState.jsx` (신규 생성)

**Responsibility:**
- 필터 결과 없음 UI 표시
- 필터 초기화 추천 메시지

**Test Strategy:** Unit Tests

**Test Scenarios (Red Phase):**

```javascript
// Test 1: 빈 상태 메시지 렌더링
test('EmptyState should render empty message', () => {
  // Arrange & Act
  render(<EmptyState onReset={jest.fn()} />);

  // Assert
  expect(screen.getByText(/선택한 조건에 해당하는 데이터가 없습니다/i)).toBeInTheDocument();
});

// Test 2: 필터 초기화 버튼 클릭 시 onReset 호출
test('EmptyState should call onReset when reset button is clicked', () => {
  // Arrange
  const mockOnReset = jest.fn();

  // Act
  render(<EmptyState onReset={mockOnReset} />);
  const resetButton = screen.getByText('전체 보기');

  fireEvent.click(resetButton);

  // Assert
  expect(mockOnReset).toHaveBeenCalled();
});

// Test 3: 추천 메시지 표시
test('EmptyState should render recommendation message', () => {
  // Arrange & Act
  render(<EmptyState onReset={jest.fn()} />);

  // Assert
  expect(screen.getByText(/다른 필터 조건을 선택하거나/i)).toBeInTheDocument();
});
```

**Implementation Order (TDD Cycle):**
1. Test 1 작성 → 기본 메시지 렌더링
2. Test 2 작성 → 초기화 버튼 연결
3. Test 3 작성 → 추천 메시지 추가
4. Refactor: CSS 스타일링 추가

**Dependencies:**
- React

**QA Sheet (Presentation Layer):**

수동 테스트 항목:
- [ ] 빈 상태 일러스트레이션이 표시됨
- [ ] 메시지가 중앙 정렬되어 있음
- [ ] 초기화 버튼이 강조 표시됨 (파란색 테두리)
- [ ] 다크 모드에서도 가독성이 유지됨

---

### 3.9 Frontend - Error Display Components

**Location:**
- `frontend/src/components/ui/ErrorToast.jsx` (신규 생성)
- `frontend/src/components/dashboard/ChartErrorCard.jsx` (신규 생성)

**Responsibility:**
- API 에러를 사용자에게 시각적으로 표시
- 에러 토스트 알림 (transient errors)
- 차트 영역 에러 카드 (persistent errors)
- 재시도 버튼 제공

**Test Strategy:** Unit Tests + QA Sheet

#### 3.9.1 ErrorToast Component

**Responsibility:**
- 일시적 에러를 화면 우측 하단에 토스트로 표시
- 5초 후 자동 닫힘
- 닫기 버튼 제공
- 다중 에러 스택 지원

**Test Scenarios (Red Phase):**

```javascript
// Test 1: 에러 메시지 표시
test('ErrorToast should display error message', () => {
  // Arrange
  const message = "네트워크 오류가 발생했습니다";

  // Act
  render(<ErrorToast message={message} onClose={jest.fn()} />);

  // Assert
  expect(screen.getByText(message)).toBeInTheDocument();
});

// Test 2: 5초 후 자동 닫힘
test('ErrorToast should auto-dismiss after 5 seconds', () => {
  // Arrange
  jest.useFakeTimers();
  const mockOnClose = jest.fn();

  // Act
  render(<ErrorToast message="Test Error" onClose={mockOnClose} />);
  jest.advanceTimersByTime(5000);

  // Assert
  expect(mockOnClose).toHaveBeenCalled();

  // Cleanup
  jest.useRealTimers();
});

// Test 3: 닫기 버튼 클릭 시 즉시 닫힘
test('ErrorToast should close immediately when close button clicked', () => {
  // Arrange
  const mockOnClose = jest.fn();
  render(<ErrorToast message="Test Error" onClose={mockOnClose} />);

  // Act
  const closeButton = screen.getByTestId('toast-close-button');
  fireEvent.click(closeButton);

  // Assert
  expect(mockOnClose).toHaveBeenCalled();
});

// Test 4: 에러 타입에 따른 아이콘 표시
test('ErrorToast should display error icon for error type', () => {
  // Arrange & Act
  render(<ErrorToast message="Error" type="error" onClose={jest.fn()} />);

  // Assert
  const icon = screen.getByTestId('toast-error-icon');
  expect(icon).toBeInTheDocument();
});

// Test 5: 경고 타입 토스트
test('ErrorToast should display warning icon for warning type', () => {
  // Arrange & Act
  render(<ErrorToast message="Warning" type="warning" onClose={jest.fn()} />);

  // Assert
  const icon = screen.getByTestId('toast-warning-icon');
  expect(icon).toBeInTheDocument();
});
```

**Component Specification:**

```jsx
// components/ui/ErrorToast.jsx

/**
 * ErrorToast Component
 *
 * Props:
 * - message: string (required) - 표시할 에러 메시지
 * - type: 'error' | 'warning' | 'info' (default: 'error')
 * - onClose: function (required) - 닫힘 핸들러
 * - duration: number (default: 5000ms) - 자동 닫힘 시간
 *
 * Position: fixed, bottom-right (우측 하단)
 * Z-index: 9999
 */

export default function ErrorToast({ message, type = 'error', onClose, duration = 5000 }) {
  // Auto-dismiss after duration
  // Close button handler
  // Icon rendering based on type
}
```

**Implementation Order (TDD Cycle):**
1. Test 1 작성 → 기본 메시지 렌더링
2. Test 2 작성 → useEffect로 자동 닫힘 구현
3. Test 3 작성 → 닫기 버튼 핸들러
4. Test 4-5 작성 → 타입별 아이콘 렌더링
5. Refactor: CSS 스타일링 추가

---

#### 3.9.2 ChartErrorCard Component

**Responsibility:**
- 차트 영역에서 데이터 로딩 실패 시 에러 카드 표시
- 재시도 버튼 제공
- request_id 표시 (디버깅용)

**Test Scenarios (Red Phase):**

```javascript
// Test 1: 에러 메시지 표시
test('ChartErrorCard should display error message', () => {
  // Arrange
  const message = "데이터를 불러올 수 없습니다";

  // Act
  render(<ChartErrorCard message={message} onRetry={jest.fn()} />);

  // Assert
  expect(screen.getByText(/데이터를 불러올 수 없습니다/i)).toBeInTheDocument();
});

// Test 2: 재시도 버튼 클릭 시 onRetry 호출
test('ChartErrorCard should call onRetry when retry button clicked', () => {
  // Arrange
  const mockOnRetry = jest.fn();
  render(<ChartErrorCard message="Error" onRetry={mockOnRetry} />);

  // Act
  const retryButton = screen.getByText('재시도');
  fireEvent.click(retryButton);

  // Assert
  expect(mockOnRetry).toHaveBeenCalled();
});

// Test 3: request_id 표시 (옵션)
test('ChartErrorCard should display request_id when provided', () => {
  // Arrange
  const requestId = 'a1b2c3d4';

  // Act
  render(<ChartErrorCard message="Error" onRetry={jest.fn()} requestId={requestId} />);

  // Assert
  expect(screen.getByText(/a1b2c3d4/i)).toBeInTheDocument();
});

// Test 4: request_id 없을 때 숨김
test('ChartErrorCard should not display request_id section when not provided', () => {
  // Arrange & Act
  render(<ChartErrorCard message="Error" onRetry={jest.fn()} />);

  // Assert
  expect(screen.queryByText(/요청 ID/i)).not.toBeInTheDocument();
});

// Test 5: 에러 아이콘 표시
test('ChartErrorCard should display error icon', () => {
  // Arrange & Act
  render(<ChartErrorCard message="Error" onRetry={jest.fn()} />);

  // Assert
  const icon = screen.getByTestId('chart-error-icon');
  expect(icon).toBeInTheDocument();
});
```

**Component Specification:**

```jsx
// components/dashboard/ChartErrorCard.jsx

/**
 * ChartErrorCard Component
 *
 * Props:
 * - message: string (required) - 표시할 에러 메시지
 * - onRetry: function (required) - 재시도 버튼 핸들러
 * - requestId: string (optional) - 디버깅용 request ID
 *
 * Layout: 차트 영역 전체를 차지하는 카드
 * Background: 연한 빨간색 (#FFF5F5)
 * Border: 1px solid #FEB2B2
 */

export default function ChartErrorCard({ message, onRetry, requestId }) {
  // Error icon
  // Error message
  // Retry button
  // Conditional request_id display
}
```

**Implementation Order (TDD Cycle):**
1. Test 1 작성 → 기본 메시지 렌더링
2. Test 2 작성 → 재시도 버튼 핸들러
3. Test 3-4 작성 → requestId 조건부 렌더링
4. Test 5 작성 → 에러 아이콘 추가
5. Refactor: CSS 스타일링 및 접근성 개선

---

#### 3.9.3 Error Handling Integration

**useDashboardData.js에 에러 처리 통합:**

```javascript
// hooks/useDashboardData.js (확장)

import { useState, useEffect } from 'react';
import dataApiClient from '../api/dataApiClient';

export function useDashboardData(filters) {
  const [data, setData] = useState(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState(null);

  const fetchData = async () => {
    setIsLoading(true);
    setError(null);

    try {
      const [researchFunding, students, publications, departmentKpi] = await Promise.all([
        dataApiClient.get('/api/dashboard/research-funding/', { params: filters }),
        dataApiClient.get('/api/dashboard/students/', { params: filters }),
        dataApiClient.get('/api/dashboard/publications/', { params: filters }),
        dataApiClient.get('/api/dashboard/department-kpi/', { params: filters }),
      ]);

      setData({
        researchFunding: researchFunding.data,
        students: students.data,
        publications: publications.data,
        departmentKpi: departmentKpi.data,
      });
    } catch (err) {
      // 백엔드의 표준 에러 응답 파싱
      const errorResponse = err.response?.data || {};
      setError({
        message: errorResponse.message || '데이터를 불러오는 중 오류가 발생했습니다',
        code: errorResponse.error || 'unknown_error',
        requestId: errorResponse.request_id,
      });
    } finally {
      setIsLoading(false);
    }
  };

  useEffect(() => {
    fetchData();
  }, [filters]);

  return { data, isLoading, error, refetch: fetchData };
}
```

**Dashboard Page에서 에러 표시:**

```jsx
// pages/Dashboard.jsx (확장)

import ErrorToast from '../components/ui/ErrorToast';
import ChartErrorCard from '../components/dashboard/ChartErrorCard';

export function Dashboard() {
  const { filters, handleFilterChange, handleResetFilters } = useDashboardFilter();
  const { data, isLoading, error, refetch } = useDashboardData(filters);
  const [showErrorToast, setShowErrorToast] = useState(false);

  // 에러 발생 시 토스트 표시
  useEffect(() => {
    if (error) {
      setShowErrorToast(true);
    }
  }, [error]);

  return (
    <div>
      <FilterPanel filters={filters} onChange={handleFilterChange} />

      {error ? (
        <ChartErrorCard
          message={error.message}
          onRetry={refetch}
          requestId={error.requestId}
        />
      ) : (
        <Charts data={data} isLoading={isLoading} />
      )}

      {showErrorToast && error && (
        <ErrorToast
          message={error.message}
          onClose={() => setShowErrorToast(false)}
        />
      )}
    </div>
  );
}
```

**Test for Integration:**

```javascript
// Test: 에러 발생 시 ErrorToast와 ChartErrorCard 모두 표시
test('Dashboard should display both ErrorToast and ChartErrorCard on error', async () => {
  // Arrange
  const error = { message: '네트워크 오류', code: 'server_error', requestId: 'abc123' };
  jest.spyOn(dataApiClient, 'get').mockRejectedValue({ response: { data: error } });

  // Act
  render(<Dashboard />);
  await waitFor(() => expect(screen.getByText(/네트워크 오류/i)).toBeInTheDocument());

  // Assert
  expect(screen.getByTestId('error-toast')).toBeInTheDocument();
  expect(screen.getByTestId('chart-error-card')).toBeInTheDocument();
  expect(screen.getByText('재시도')).toBeInTheDocument();
});
```

**QA Sheet (Presentation Layer):**

수동 테스트 항목:
- [ ] API 에러 발생 시 화면 우측 하단에 에러 토스트가 표시됨
- [ ] 에러 토스트가 5초 후 자동으로 사라짐
- [ ] 에러 토스트의 닫기 버튼(X) 클릭 시 즉시 사라짐
- [ ] 차트 영역에 ChartErrorCard가 표시됨
- [ ] ChartErrorCard의 "재시도" 버튼 클릭 시 API 재호출됨
- [ ] 재시도 성공 시 ChartErrorCard가 사라지고 차트가 표시됨
- [ ] request_id가 ChartErrorCard 하단에 작게 표시됨
- [ ] 에러 메시지가 한글로 명확히 표시됨
- [ ] Rate Limit 에러 시 "잠시 후 다시 시도해주세요" 메시지 표시
- [ ] 다중 에러 발생 시 토스트가 스택 형태로 쌓임
- [ ] 모바일 화면에서도 에러 UI가 정상 표시됨

**Dependencies:**
- React (useState, useEffect)
- CSS 스타일링

---

### 3.10 Acceptance Tests (E2E with Playwright)

**Location:** `tests/e2e/dashboard-filtering.spec.js` (신규 생성)

**Responsibility:**
- 사용자 관점의 전체 플로우 검증
- 필터 적용 → 차트 업데이트 시나리오
- 에러 핸들링 시나리오
- 성능 벤치마크
- 크로스 브라우저 테스트

**Test Strategy:** E2E Tests (Acceptance Tests - 10%)

**Test Scenarios:**

```javascript
// tests/e2e/dashboard-filtering.spec.js

import { test, expect } from '@playwright/test';

// Scenario 1: Happy Path - 학과 필터 적용
test('User filters dashboard by department', async ({ page }) => {
  // Arrange
  await page.goto('http://localhost:3000/dashboard');
  await page.waitForSelector('[data-testid="research-funding-chart"]');

  // Act
  await page.selectOption('[data-testid="department-filter"]', '컴퓨터공학과');
  await page.waitForTimeout(300);  // Debounce
  await page.waitForResponse(response =>
    response.url().includes('/api/dashboard/research-funding/') &&
    response.status() === 200
  );

  // Assert
  const chartTitle = await page.textContent('[data-testid="chart-title"]');
  expect(chartTitle).toContain('컴퓨터공학과');

  // Screenshot
  await page.screenshot({ path: 'screenshots/filter-by-department.png' });
});

// Scenario 2: 다중 필터 조합
test('User applies multiple filters (department + year)', async ({ page }) => {
  // Arrange
  await page.goto('http://localhost:3000/dashboard');
  await page.waitForSelector('[data-testid="department-filter"]');

  // Act
  await page.selectOption('[data-testid="department-filter"]', '컴퓨터공학과');
  await page.selectOption('[data-testid="year-filter"]', '2024');
  await page.waitForTimeout(300);
  await page.waitForResponse(response =>
    response.url().includes('department=컴퓨터공학과') &&
    response.url().includes('year=2024')
  );

  // Assert
  const url = page.url();
  expect(url).toContain('department=컴퓨터공학과');
  expect(url).toContain('year=2024');

  // Screenshot
  await page.screenshot({ path: 'screenshots/multiple-filters.png' });
});

// Scenario 3: 필터 초기화
test('User resets filters to default', async ({ page }) => {
  // Arrange
  await page.goto('http://localhost:3000/dashboard');
  await page.selectOption('[data-testid="department-filter"]', '컴퓨터공학과');
  await page.waitForTimeout(300);

  // Act
  await page.click('[data-testid="reset-filters-button"]');
  await page.waitForResponse(response =>
    response.url().includes('/api/dashboard/research-funding/') &&
    response.status() === 200
  );

  // Assert
  const dropdownValue = await page.inputValue('[data-testid="department-filter"]');
  expect(dropdownValue).toBe('all');

  const resetButton = await page.locator('[data-testid="reset-filters-button"]');
  await expect(resetButton).toBeDisabled();
});

// Scenario 4: 에러 핸들링 - API 실패
test('User sees error when filter API fails', async ({ page }) => {
  // Arrange
  await page.goto('http://localhost:3000/dashboard');

  // Mock API failure
  await page.route('**/api/dashboard/research-funding/*', route =>
    route.fulfill({
      status: 400,
      contentType: 'application/json',
      body: JSON.stringify({
        error: 'invalid_parameter',
        message: '유효하지 않은 파라미터입니다',
        details: { field: 'department' },
        timestamp: new Date().toISOString(),
        request_id: 'test123'
      })
    })
  );

  // Act
  await page.selectOption('[data-testid="department-filter"]', '컴퓨터공학과');
  await page.waitForTimeout(300);

  // Assert
  const errorToast = await page.textContent('[data-testid="error-toast"]');
  expect(errorToast).toContain('유효하지 않은 파라미터입니다');

  const chartErrorCard = await page.textContent('[data-testid="chart-error-card"]');
  expect(chartErrorCard).toContain('재시도');

  // Screenshot
  await page.screenshot({ path: 'screenshots/error-state.png' });
});

// Scenario 5: 에러 재시도
test('User retries after error and succeeds', async ({ page }) => {
  // Arrange
  await page.goto('http://localhost:3000/dashboard');

  let callCount = 0;
  await page.route('**/api/dashboard/research-funding/*', route => {
    callCount++;
    if (callCount === 1) {
      // First call fails
      route.fulfill({ status: 500, body: JSON.stringify({ error: 'server_error' }) });
    } else {
      // Second call succeeds
      route.continue();
    }
  });

  await page.selectOption('[data-testid="department-filter"]', '컴퓨터공학과');
  await page.waitForTimeout(300);

  // Act: Click retry button
  await page.click('[data-testid="chart-error-retry-button"]');
  await page.waitForResponse(response =>
    response.url().includes('/api/dashboard/research-funding/') &&
    response.status() === 200
  );

  // Assert
  const chart = await page.locator('[data-testid="research-funding-chart"]');
  await expect(chart).toBeVisible();

  const errorCard = await page.locator('[data-testid="chart-error-card"]');
  await expect(errorCard).not.toBeVisible();
});

// Scenario 6: 빈 결과 상태
test('User sees empty state when no data matches filter', async ({ page }) => {
  // Arrange
  await page.goto('http://localhost:3000/dashboard');

  await page.route('**/api/dashboard/research-funding/*', route =>
    route.fulfill({
      status: 200,
      contentType: 'application/json',
      body: JSON.stringify({
        current_balance: 0,
        trend: []
      })
    })
  );

  // Act
  await page.selectOption('[data-testid="department-filter"]', '존재하지않는학과');
  await page.waitForTimeout(300);

  // Assert
  const emptyState = await page.textContent('[data-testid="empty-state"]');
  expect(emptyState).toContain('선택한 조건에 해당하는 데이터가 없습니다');

  const resetButton = await page.locator('[data-testid="empty-state-reset-button"]');
  await expect(resetButton).toBeVisible();
});

// Performance Benchmark
test('Filter application completes within 500ms', async ({ page }) => {
  // Arrange
  await page.goto('http://localhost:3000/dashboard');
  await page.waitForSelector('[data-testid="department-filter"]');

  // Act
  const startTime = Date.now();
  await page.selectOption('[data-testid="department-filter"]', '컴퓨터공학과');
  await page.waitForResponse(response =>
    response.url().includes('/api/dashboard/research-funding/')
  );
  const endTime = Date.now();

  // Assert
  const duration = endTime - startTime;
  expect(duration).toBeLessThan(500);  // 500ms SLA

  console.log(`Filter application took ${duration}ms`);
});

// Cross-browser Test (Safari)
test('Filter works correctly on Safari', async ({ page, browserName }) => {
  test.skip(browserName !== 'webkit', 'Safari-specific test');

  await page.goto('http://localhost:3000/dashboard');
  await page.selectOption('[data-testid="department-filter"]', '컴퓨터공학과');
  await page.waitForTimeout(300);

  const chart = await page.locator('[data-testid="research-funding-chart"]');
  await expect(chart).toBeVisible();
});
```

**Playwright Configuration:**

```javascript
// playwright.config.js

import { defineConfig, devices } from '@playwright/test';

export default defineConfig({
  testDir: './tests/e2e',
  timeout: 30000,
  expect: {
    timeout: 5000,
  },
  fullyParallel: false,  // Run tests sequentially for consistent state
  forbidOnly: !!process.env.CI,
  retries: process.env.CI ? 2 : 0,
  workers: process.env.CI ? 1 : undefined,
  reporter: [
    ['html', { outputFolder: 'playwright-report' }],
    ['json', { outputFile: 'test-results.json' }],
  ],
  use: {
    baseURL: 'http://localhost:3000',
    trace: 'on-first-retry',
    screenshot: 'only-on-failure',
    video: 'retain-on-failure',
  },
  projects: [
    {
      name: 'chromium',
      use: { ...devices['Desktop Chrome'] },
    },
    {
      name: 'webkit',
      use: { ...devices['Desktop Safari'] },
    },
  ],
  webServer: {
    command: 'npm run dev',
    url: 'http://localhost:3000',
    reuseExistingServer: !process.env.CI,
  },
});
```

**Implementation Order:**
1. Playwright 설치 및 설정
2. Scenario 1-3 작성 및 실행 (Happy Path)
3. Scenario 4-5 작성 (Error Handling)
4. Scenario 6 작성 (Empty State)
5. Performance Benchmark 추가
6. Cross-browser Tests 추가

**Dependencies:**
- `@playwright/test`
- Node.js 16+

---

### 3.11 Helper Utilities

**Location:**
- `backend/data_ingestion/utils/filter_helpers.py` (신규 생성)
- `frontend/src/utils/filterHelpers.js` (신규 생성)

**Responsibility:**
- 재사용 가능한 유틸리티 함수
- 날짜 파싱, 필터 직렬화, 디바운싱

**Test Strategy:** Unit Tests

#### 3.11.1 Backend Utilities

**Location:** `backend/data_ingestion/utils/filter_helpers.py`

```python
# utils/filter_helpers.py

from datetime import datetime, timedelta
from typing import Dict, Any
from urllib.parse import urlencode


def parse_year_filter(year_param: str) -> Dict[str, Any]:
    """
    연도 필터를 Django ORM 쿼리 조건으로 변환.

    Args:
        year_param: 'latest' | 'YYYY' 형식

    Returns:
        Django ORM filter 조건 딕셔너리

    Examples:
        parse_year_filter('latest') -> {'execution_date__gte': datetime(2024, 1, 1)}
        parse_year_filter('2024') -> {'execution_date__year': 2024}

    Raises:
        ValueError: 잘못된 연도 형식
    """
    if year_param == 'latest':
        one_year_ago = datetime.now() - timedelta(days=365)
        return {'execution_date__gte': one_year_ago}

    try:
        year = int(year_param)
        if year < 2000 or year > 2100:
            raise ValueError(f"Invalid year range: {year}")
        return {'execution_date__year': year}
    except ValueError:
        raise ValueError(f"Invalid year format: {year_param}")


def serialize_filter_params(filters: Dict[str, Any]) -> str:
    """
    필터 딕셔너리를 URL 쿼리 스트링으로 변환.
    'all' 값은 제외함.

    Args:
        filters: 필터 딕셔너리

    Returns:
        URL 쿼리 스트링

    Examples:
        serialize_filter_params({'department': 'all', 'year': '2024'})
        -> 'year=2024'
    """
    filtered_params = {
        k: v for k, v in filters.items()
        if v and v != 'all'
    }
    return urlencode(filtered_params)


def calculate_date_range(period: str) -> tuple[datetime, datetime]:
    """
    기간 키워드를 날짜 범위로 변환.

    Args:
        period: 'latest' | 'this_year' | 'last_year'

    Returns:
        (start_date, end_date) 튜플

    Examples:
        calculate_date_range('this_year') -> (2025-01-01, 2025-12-31)
    """
    now = datetime.now()

    if period == 'latest':
        return (now - timedelta(days=365), now)
    elif period == 'this_year':
        return (datetime(now.year, 1, 1), datetime(now.year, 12, 31))
    elif period == 'last_year':
        return (datetime(now.year - 1, 1, 1), datetime(now.year - 1, 12, 31))
    else:
        raise ValueError(f"Unknown period: {period}")
```

**Test Scenarios:**

```python
# Test 1: 'latest' 키워드 파싱
def test_parse_year_filter_with_latest():
    # Act
    result = parse_year_filter('latest')

    # Assert
    assert 'execution_date__gte' in result
    # 약 1년 전 날짜인지 검증
    one_year_ago = datetime.now() - timedelta(days=365)
    assert (result['execution_date__gte'] - one_year_ago).days < 1

# Test 2: YYYY 형식 파싱
def test_parse_year_filter_with_year():
    # Act
    result = parse_year_filter('2024')

    # Assert
    assert result == {'execution_date__year': 2024}

# Test 3: 잘못된 연도 형식 거부
def test_parse_year_filter_with_invalid_format():
    # Act & Assert
    with pytest.raises(ValueError) as exc_info:
        parse_year_filter('24')
    assert 'Invalid year format' in str(exc_info.value)

# Test 4: 필터 직렬화 - 'all' 제외
def test_serialize_filter_params_exclude_all():
    # Arrange
    filters = {'department': 'all', 'year': '2024', 'status': '재학'}

    # Act
    result = serialize_filter_params(filters)

    # Assert
    assert 'department' not in result
    assert 'year=2024' in result
    assert 'status' in result

# Test 5: 빈 필터 직렬화
def test_serialize_filter_params_empty():
    # Arrange
    filters = {'department': 'all', 'year': 'all'}

    # Act
    result = serialize_filter_params(filters)

    # Assert
    assert result == ''

# Test 6: 날짜 범위 계산 - this_year
def test_calculate_date_range_this_year():
    # Act
    start, end = calculate_date_range('this_year')

    # Assert
    now = datetime.now()
    assert start.year == now.year
    assert start.month == 1
    assert start.day == 1
    assert end.year == now.year
    assert end.month == 12
    assert end.day == 31
```

---

#### 3.11.2 Frontend Utilities

**Location:** `frontend/src/utils/filterHelpers.js`

```javascript
// utils/filterHelpers.js

import { useState, useEffect } from 'react';

/**
 * 디바운스 커스텀 Hook.
 * useDashboardFilter에서 추출하여 재사용 가능하게 함.
 *
 * @param {any} value - 디바운스할 값
 * @param {number} delay - 지연 시간 (ms)
 * @returns {any} 디바운스된 값
 *
 * @example
 * const debouncedSearchTerm = useDebounce(searchTerm, 300);
 */
export function useDebounce(value, delay = 300) {
  const [debouncedValue, setDebouncedValue] = useState(value);

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);

  return debouncedValue;
}


/**
 * 필터 파라미터를 API 요청용으로 포맷.
 * 'all' 값과 빈 문자열을 제거.
 *
 * @param {Object} filters - 필터 객체
 * @returns {Object} 정제된 필터 객체
 *
 * @example
 * formatFilterParams({ department: 'all', year: '2024', status: '' })
 * // Returns: { year: '2024' }
 */
export function formatFilterParams(filters) {
  return Object.entries(filters)
    .filter(([_, value]) => value && value !== 'all')
    .reduce((acc, [key, value]) => ({ ...acc, [key]: value }), {});
}


/**
 * 에러 응답에서 사용자 친화적 메시지 추출.
 *
 * @param {Object} errorResponse - 백엔드 에러 응답
 * @returns {string} 표시할 에러 메시지
 *
 * @example
 * extractErrorMessage({ message: '유효하지 않은 파라미터입니다' })
 * // Returns: '유효하지 않은 파라미터입니다'
 */
export function extractErrorMessage(errorResponse) {
  if (!errorResponse) {
    return '알 수 없는 오류가 발생했습니다';
  }

  // 백엔드 표준 에러 응답 포맷
  if (errorResponse.message) {
    return errorResponse.message;
  }

  // Axios 에러 fallback
  if (errorResponse.response?.data?.message) {
    return errorResponse.response.data.message;
  }

  return '데이터를 불러오는 중 오류가 발생했습니다';
}


/**
 * 필터 적용 여부 확인.
 * 모든 필터가 기본값('all', 'latest')인지 검사.
 *
 * @param {Object} filters - 필터 객체
 * @returns {boolean} 필터 적용 여부
 *
 * @example
 * isFilterApplied({ department: 'all', year: 'latest' })  // false
 * isFilterApplied({ department: '컴퓨터공학과', year: 'latest' })  // true
 */
export function isFilterApplied(filters) {
  const defaultValues = ['all', 'latest', ''];
  return Object.values(filters).some(value => !defaultValues.includes(value));
}
```

**Test Scenarios:**

```javascript
// Test 1: useDebounce - 값 지연 업데이트
test('useDebounce should delay value update', () => {
  // Arrange
  jest.useFakeTimers();
  const { result, rerender } = renderHook(
    ({ value }) => useDebounce(value, 300),
    { initialProps: { value: 'initial' } }
  );

  // Act
  rerender({ value: 'updated' });
  jest.advanceTimersByTime(299);

  // Assert
  expect(result.current).toBe('initial');

  // Act
  jest.advanceTimersByTime(1);

  // Assert
  expect(result.current).toBe('updated');

  // Cleanup
  jest.useRealTimers();
});

// Test 2: formatFilterParams - 'all' 및 빈 값 제거
test('formatFilterParams should remove all and empty values', () => {
  // Arrange
  const input = { department: 'all', year: '2024', status: '' };

  // Act
  const result = formatFilterParams(input);

  // Assert
  expect(result).toEqual({ year: '2024' });
  expect(result).not.toHaveProperty('department');
  expect(result).not.toHaveProperty('status');
});

// Test 3: formatFilterParams - 모든 값이 유효한 경우
test('formatFilterParams should keep all valid values', () => {
  // Arrange
  const input = { department: '컴퓨터공학과', year: '2024', status: '재학' };

  // Act
  const result = formatFilterParams(input);

  // Assert
  expect(result).toEqual(input);
});

// Test 4: extractErrorMessage - 표준 에러 응답
test('extractErrorMessage should extract message from standard error response', () => {
  // Arrange
  const errorResponse = {
    error: 'invalid_parameter',
    message: '유효하지 않은 파라미터입니다',
    details: {},
  };

  // Act
  const result = extractErrorMessage(errorResponse);

  // Assert
  expect(result).toBe('유효하지 않은 파라미터입니다');
});

// Test 5: extractErrorMessage - null 처리
test('extractErrorMessage should return default message for null', () => {
  // Act
  const result = extractErrorMessage(null);

  // Assert
  expect(result).toBe('알 수 없는 오류가 발생했습니다');
});

// Test 6: isFilterApplied - 기본값만 있을 때 false
test('isFilterApplied should return false when all values are default', () => {
  // Arrange
  const filters = { department: 'all', year: 'latest' };

  // Act
  const result = isFilterApplied(filters);

  // Assert
  expect(result).toBe(false);
});

// Test 7: isFilterApplied - 하나라도 적용되면 true
test('isFilterApplied should return true when any filter is applied', () => {
  // Arrange
  const filters = { department: '컴퓨터공학과', year: 'latest' };

  // Act
  const result = isFilterApplied(filters);

  // Assert
  expect(result).toBe(true);
});
```

**Implementation Order (TDD Cycle):**
1. Backend: Test 1-3 작성 → parse_year_filter 구현
2. Backend: Test 4-5 작성 → serialize_filter_params 구현
3. Backend: Test 6 작성 → calculate_date_range 구현
4. Frontend: Test 1 작성 → useDebounce 구현
5. Frontend: Test 2-3 작성 → formatFilterParams 구현
6. Frontend: Test 4-5 작성 → extractErrorMessage 구현
7. Frontend: Test 6-7 작성 → isFilterApplied 구현
8. Refactor: useDashboardFilter에서 useDebounce 사용하도록 변경

**Dependencies:**
- Backend: Python `datetime`, `urllib.parse`
- Frontend: React (useState, useEffect)

---

## 4. TDD Workflow

### 4.1 구현 순서 (Outside-In 전략)

**Phase 1: Backend Core Logic (Inside-Out)**
1. `validators.py` - 필터 검증 로직 (Unit Tests)
2. **`validators.py` - Security Validation** (Unit Tests) - CSRF, Input Sanitization, Rate Limiting
3. `filtering_service.py` - 필터링 비즈니스 로직 (Unit Tests)
4. **`error_codes.py` - Error Response Specification** (Unit Tests) - FilterErrorCode, format_error_response
5. **`utils/filter_helpers.py` - Backend Utilities** (Unit Tests) - parse_year_filter, serialize_filter_params
6. `repositories.py` - 쿼리 확장 (Unit Tests)
7. `views.py` - API 엔드포인트 (Integration Tests)

**Phase 2: Frontend State Management**
8. **`utils/filterHelpers.js` - Frontend Utilities** (Unit Tests) - useDebounce, formatFilterParams, extractErrorMessage
9. `useDashboardFilter.js` - 필터 상태 및 디바운싱 (Unit Tests)
10. `useFilterOptions.js` - 메타데이터 로딩 (Unit Tests)
11. `useDashboardData.js` - 필터 기반 데이터 조회 (Integration Tests)

**Phase 3: Frontend UI**
12. `FilterPanel.jsx` - 필터 UI (Unit Tests + QA Sheet)
13. `EmptyState.jsx` - 빈 상태 UI (Unit Tests + QA Sheet)
14. **`ErrorToast.jsx` - Error Toast Component** (Unit Tests + QA Sheet)
15. **`ChartErrorCard.jsx` - Chart Error Card Component** (Unit Tests + QA Sheet)

**Phase 4: End-to-End Integration**
16. **E2E Tests (Playwright)** - 전체 사용자 플로우 (Acceptance Tests)
    - Happy Path 시나리오 (필터 적용, 다중 필터, 초기화)
    - Error Handling 시나리오 (API 실패, 재시도)
    - Empty State 시나리오
    - Performance Benchmark (<500ms)
    - Cross-browser Tests (Chrome, Safari)

**Phase 5: Self-Verification**
17. Phase Completion Checklist 점검
18. Final Implementation Report 작성

### 4.2 각 모듈별 TDD 사이클 예시

**예시: validators.py 구현**

**Red Phase:**
```python
# tests/test_validators.py
def test_validate_department_filter_with_valid_department():
    params = {'department': '컴퓨터공학과'}
    validate_filter_params(params)  # Should not raise

# 실행 → FAIL (함수가 아직 없음)
```

**Green Phase:**
```python
# api/validators.py
VALID_DEPARTMENTS = ['컴퓨터공학과', '전자공학과']

def validate_filter_params(params):
    department = params.get('department')
    if department and department not in VALID_DEPARTMENTS:
        raise ValidationError({'department': '유효하지 않은 학과입니다.'})

# 실행 → PASS
```

**Refactor Phase:**
```python
# api/validators.py
VALID_DEPARTMENTS = ['컴퓨터공학과', '전자공학과']
VALID_STATUSES = ['재학', '졸업', '휴학']

def _validate_enum_field(value, valid_values, field_name):
    if value and value not in valid_values:
        raise ValidationError({field_name: f'유효하지 않은 {field_name}입니다.'})

def validate_filter_params(params):
    _validate_enum_field(params.get('department'), VALID_DEPARTMENTS, 'department')
    _validate_enum_field(params.get('studentStatus'), VALID_STATUSES, 'studentStatus')

# 실행 → PASS (테스트는 여전히 통과)
```

### 4.3 Commit 포인트

각 모듈별 Green Phase 완료 시점에 커밋:

```
feat: add filter parameter validation logic

- Implement validate_filter_params function
- Add whitelist validation for department, year, status
- Handle SQL injection and XSS attempts
- All unit tests passing (10/10)

Related: #006-dashboard-filtering
```

### 4.4 완료 조건

**Definition of Done:**
- [ ] 모든 Unit Tests 통과 (70% 커버리지 이상)
- [ ] 모든 Integration Tests 통과
- [ ] 모든 E2E Tests 통과
- [ ] Refactoring 완료 (중복 코드 제거)
- [ ] 에러 핸들링 구현
- [ ] 로깅 추가 (API 호출 로그)
- [ ] 코드 리뷰 통과
- [ ] QA Sheet 항목 수동 테스트 완료

---

### 4.5 Self-Verification Protocol

구현 완료 전, 모든 항목을 점검하여 누락 없이 구현되었는지 확인합니다.

#### 4.5.1 Phase Completion Checklist (Per Module)

**Backend Module (validators.py, filtering_service.py, error_codes.py, views.py):**

- [ ] 모든 Unit Tests 통과 (pytest -v)
- [ ] Test Coverage ≥ 70% (pytest --cov)
- [ ] **보안 검증 테스트 통과 (CRITICAL)**
  - [ ] CSRF 보호 테스트 통과
  - [ ] SQL Injection 방어 테스트 통과
  - [ ] XSS 방어 테스트 통과
  - [ ] Rate Limiting 테스트 통과
  - [ ] Input Sanitization 테스트 통과
- [ ] **에러 코드 구현 완료 (CRITICAL)**
  - [ ] FilterErrorCode 클래스 정의됨
  - [ ] format_error_response 함수 구현됨
  - [ ] 모든 API 엔드포인트에서 표준 에러 응답 사용
  - [ ] validation_error, invalid_parameter, server_error, rate_limit_exceeded, no_data_found 모두 테스트됨
- [ ] Logging 추가됨 (API 호출, 에러, 성능)
- [ ] TODO/FIXME 코멘트 없음
- [ ] 코드 리뷰 완료 (Peer or Self)

**Frontend Module (Hooks, Components, Utilities):**

- [ ] 모든 Unit Tests 통과 (npm test)
- [ ] Test Coverage ≥ 70% (npm test -- --coverage)
- [ ] Debouncing 정상 작동 (300ms 검증)
- [ ] **에러 표시 UI 구현 완료 (CRITICAL)**
  - [ ] ErrorToast 컴포넌트 구현됨
  - [ ] ChartErrorCard 컴포넌트 구현됨
  - [ ] 에러 발생 시 토스트 표시 확인
  - [ ] 재시도 버튼 작동 확인
  - [ ] request_id 표시 확인
- [ ] **Helper Utilities 구현 완료**
  - [ ] useDebounce hook 구현됨
  - [ ] formatFilterParams 함수 구현됨
  - [ ] extractErrorMessage 함수 구현됨
  - [ ] isFilterApplied 함수 구현됨
- [ ] QA Sheet 항목 수동 테스트 완료 (스크린샷 첨부)
- [ ] Browser Console 에러 없음
- [ ] PropTypes Warnings 없음

**Integration:**

- [ ] 모든 Integration Tests 통과
- [ ] API 엔드포인트가 올바른 에러 코드 반환
- [ ] Frontend가 모든 Backend 에러 코드 처리
- [ ] Performance Benchmark 달성 (<500ms 필터 적용)
- [ ] API 응답 시간 < 200ms (평균)

**E2E (Acceptance Tests):**

- [ ] **모든 E2E Tests 통과 (HIGH PRIORITY)**
  - [ ] Happy Path 시나리오 통과 (필터 적용, 다중 필터, 초기화)
  - [ ] Error Handling 시나리오 통과 (API 실패, 재시도)
  - [ ] Empty State 시나리오 통과
  - [ ] Performance Benchmark 시나리오 통과 (<500ms)
  - [ ] Cross-browser Tests 통과 (Chrome, Safari)
- [ ] 스크린샷/비디오 캡처 완료 (주요 플로우)
- [ ] Playwright Report 생성됨

---

#### 4.5.2 Final Implementation Report Template

구현 완료 후, 아래 템플릿을 작성하여 최종 보고합니다.

```markdown
# Dashboard Filtering Implementation - Final Report

**Implementation Date:** YYYY-MM-DD
**Developer:** [Name]
**Branch:** feature/006-dashboard-filtering
**Commit:** [hash]

---

## Summary

대시보드 필터링 기능을 TDD 원칙에 따라 구현 완료.
모든 Critical/High Priority 요구사항 충족.

---

## Implementation Statistics

**Backend:**
- Files Created:
  - `api/validators.py`
  - `api/error_codes.py`
  - `services/filtering_service.py`
  - `utils/filter_helpers.py`
- Files Modified:
  - `api/views.py`
  - `infrastructure/repositories.py`
  - `settings.py` (CSRF, Rate Limiting)
- Unit Tests: XX passing
- Integration Tests: XX passing
- Test Coverage: XX%

**Frontend:**
- Files Created:
  - `hooks/useDashboardFilter.js`
  - `hooks/useFilterOptions.js`
  - `components/dashboard/FilterPanel.jsx`
  - `components/dashboard/EmptyState.jsx`
  - `components/ui/ErrorToast.jsx`
  - `components/dashboard/ChartErrorCard.jsx`
  - `utils/filterHelpers.js`
- Files Modified:
  - `hooks/useDashboardData.js`
  - `pages/Dashboard.jsx`
- Unit Tests: XX passing
- Integration Tests: XX passing
- Test Coverage: XX%

**E2E:**
- Playwright Tests: XX passing
- Performance Benchmark: XXXms average (target: <500ms)
- Cross-browser Tests: Chrome ✅ Safari ✅

---

## Verification Results

### Security (CRITICAL)

- [x] CSRF protection enabled
  - Test: `test_filter_api_requires_csrf_token` PASSED
- [x] SQL injection tests passing
  - Test: `test_validate_filter_params_reject_sql_injection` PASSED
- [x] XSS prevention tests passing
  - Test: `test_sanitize_filter_input_removes_xss` PASSED
- [x] Rate limiting configured (10 req/min)
  - Test: `test_filter_api_rate_limit` PASSED
- [x] Input sanitization implemented
  - Function: `sanitize_filter_input()` implemented and tested

### Error Handling (CRITICAL)

- [x] All error codes implemented (6 codes)
  - `validation_error`, `invalid_parameter`, `server_error`, `rate_limit_exceeded`, `no_data_found`, `csrf_error`
- [x] Error responses follow standard format
  - Format: `{ error, message, details, timestamp, request_id }`
- [x] Frontend displays all error types
  - ErrorToast: ✅ Implemented
  - ChartErrorCard: ✅ Implemented
- [x] Retry mechanism working
  - Test: `test('User retries after error and succeeds')` PASSED

### E2E Tests (HIGH)

- [x] Happy path scenario passing
  - Test: `test('User filters dashboard by department')` PASSED
  - Test: `test('User applies multiple filters')` PASSED
  - Test: `test('User resets filters to default')` PASSED
- [x] Error handling scenario passing
  - Test: `test('User sees error when filter API fails')` PASSED
  - Test: `test('User retries after error and succeeds')` PASSED
- [x] Empty state scenario passing
  - Test: `test('User sees empty state when no data matches filter')` PASSED
- [x] Performance benchmark met
  - Test: `test('Filter application completes within 500ms')` PASSED (XXXms)

### Helper Utilities (MEDIUM)

**Backend:**
- [x] `parse_year_filter()` implemented
  - Tests: 3/3 passing
- [x] `serialize_filter_params()` implemented
  - Tests: 2/2 passing
- [x] `calculate_date_range()` implemented
  - Tests: 1/1 passing

**Frontend:**
- [x] `useDebounce()` hook extracted
  - Test: `test('useDebounce should delay value update')` PASSED
- [x] `formatFilterParams()` implemented
  - Tests: 2/2 passing
- [x] `extractErrorMessage()` implemented
  - Tests: 2/2 passing
- [x] `isFilterApplied()` implemented
  - Tests: 2/2 passing

### QA Sheet (MEDIUM)

**FilterPanel Component:**
- [x] 드롭다운 클릭 시 옵션 목록 표시됨
- [x] 옵션 선택 시 드롭다운에 반영됨
- [x] 필터 초기화 버튼 작동함
- [x] 필터 적용 시 "전체 보기" 버튼 활성화됨
- [x] 키보드 네비게이션 정상 작동 (Tab, Enter)
- [x] 모바일 화면에서 정상 표시됨

**ErrorToast Component:**
- [x] 에러 발생 시 우측 하단에 토스트 표시됨
- [x] 5초 후 자동으로 사라짐
- [x] 닫기 버튼(X) 클릭 시 즉시 사라짐
- [x] 에러 메시지 한글로 명확히 표시됨
- [x] 다중 에러 발생 시 스택 형태로 쌓임

**ChartErrorCard Component:**
- [x] 차트 영역에 에러 카드 표시됨
- [x] "재시도" 버튼 클릭 시 API 재호출됨
- [x] 재시도 성공 시 에러 카드 사라지고 차트 표시됨
- [x] request_id 하단에 표시됨
- [x] Rate Limit 에러 시 적절한 메시지 표시됨

---

## Known Issues

[이슈가 있으면 여기에 명시, 없으면 "None"]

---

## Performance Metrics

**Filter Application Time:**
- Average: XXXms
- P95: XXXms
- Target: <500ms
- Status: ✅ PASSED

**API Response Time:**
- Average: XXXms
- P95: XXXms
- Target: <200ms
- Status: ✅ PASSED

**Test Execution Time:**
- Backend Unit Tests: XXs
- Frontend Unit Tests: XXs
- Integration Tests: XXs
- E2E Tests: XXs
- Total: XXs

---

## Next Steps

1. Deploy to staging environment
2. Request QA team review
3. Conduct user acceptance testing (UAT)
4. Merge to main after approval
5. Monitor performance metrics in production

---

## Screenshots

### Happy Path
![Filter by Department](./screenshots/filter-by-department.png)
![Multiple Filters](./screenshots/multiple-filters.png)

### Error Handling
![Error State](./screenshots/error-state.png)

### Mobile View
[Attach mobile screenshots here]

---

**Verified By:** [Name]
**Verification Date:** YYYY-MM-DD
**Approval Status:** [APPROVED / NEEDS REVISION]
```

---

#### 4.5.3 자주 누락되는 항목 체크리스트

CLAUDE.md에서 "Frequently Omitted (Extra Attention Required)"로 명시된 항목들:

**Security Validation (CRITICAL):**
- [ ] CSRF 보호 구현 확인
- [ ] Input Sanitization 함수 구현 확인
- [ ] Rate Limiting 설정 확인
- [ ] SQL Injection/XSS 방어 테스트 확인

**Error Codes (CRITICAL):**
- [ ] 모든 에러 코드 enum 정의됨
- [ ] 표준 에러 응답 포맷 적용됨
- [ ] Frontend가 모든 에러 타입 처리함

**Frontend Error Display (CRITICAL):**
- [ ] ErrorToast 컴포넌트 구현됨
- [ ] ChartErrorCard 컴포넌트 구현됨
- [ ] 재시도 버튼 작동함

**E2E Tests (HIGH):**
- [ ] Playwright 설정 완료
- [ ] Happy Path 시나리오 구현됨
- [ ] Error Handling 시나리오 구현됨
- [ ] Performance Benchmark 시나리오 구현됨

**Helper/Utility Functions (MEDIUM):**
- [ ] Backend utilities 구현됨 (filter_helpers.py)
- [ ] Frontend utilities 구현됨 (filterHelpers.js)
- [ ] useDebounce hook 추출됨

---

## 5. 핵심 원칙 및 주의사항

### 5.1 Test First
- **절대 규칙:** 테스트 없이 코드를 작성하지 않음
- 테스트를 먼저 작성하고 실패하는 것을 확인
- 최소 코드로 테스트를 통과시킴

### 5.2 Small Steps
- 한 번에 하나의 시나리오만 구현
- 큰 기능을 작은 테스트 케이스로 분해
- 각 단계마다 커밋

### 5.3 FIRST Principles
- **Fast:** 디바운싱 테스트에서 fake timers 사용
- **Independent:** Mock을 활용하여 외부 의존성 제거
- **Repeatable:** Fixture를 활용하여 일관된 테스트 데이터
- **Self-validating:** Assert 문으로 명확한 검증
- **Timely:** 코드 작성 직전에 테스트 작성

### 5.4 Test Pyramid
- Unit Tests 70%: 빠르고 많이 작성
- Integration Tests 20%: 모듈 경계 테스트
- Acceptance Tests 10%: 핵심 사용자 시나리오만

### 5.5 MVP 원칙 준수
- 오버엔지니어링 회피: 복잡한 다중 선택 제외
- 가장 쉬운 방법: Promise.all 병렬 호출 (단일 API 엔드포인트 제외)
- 당장 필요한 것만: URL 쿼리 파라미터 공유는 POST-MVP

---

## 6. 예상 구현 시간

**Backend (TDD 포함):**
- validators.py (기본 검증): 2시간
- **validators.py (보안 검증 - CSRF, Rate Limiting, Sanitization): 3시간**
- **error_codes.py (에러 코드 및 포맷): 2시간**
- filtering_service.py: 4시간
- **utils/filter_helpers.py (유틸리티 함수): 2시간**
- views.py 확장: 3시간
- Integration Tests: 2시간
- **소계:** 18시간

**Frontend (TDD 포함):**
- **utils/filterHelpers.js (유틸리티 함수): 2시간**
- useDashboardFilter.js: 3시간
- useFilterOptions.js: 2시간
- useDashboardData.js 확장: 2시간
- FilterPanel.jsx: 3시간
- EmptyState.jsx: 1시간
- **ErrorToast.jsx (에러 토스트): 2시간**
- **ChartErrorCard.jsx (에러 카드): 2시간**
- **E2E Tests (Playwright 설정 + 시나리오): 4시간**
- **소계:** 21시간

**Self-Verification & Reporting:**
- Phase Completion Checklist 점검: 1시간
- Final Implementation Report 작성: 1시간
- **소계:** 2시간

**총 예상 시간:** 41시간 (약 5일, 하루 8시간 기준)

**리스크 버퍼:** +20% (8시간) → **최종: 49시간 (약 6-7일)**

---

## 7. 의존성 및 선행 작업

**필수 선행 작업:**
- [ ] 데이터베이스 테이블 생성 완료 (research_projects, students, publications, department_kpis)
- [ ] 기본 대시보드 API 엔드포인트 구현 완료
- [ ] React 프로젝트 구조 설정 완료
- [ ] 테스트 프레임워크 설정 (Jest, React Testing Library, pytest)

**외부 의존성:**
- Django ORM
- DRF Serializers
- React Hooks
- dataApiClient (Axios)

---

## 8. 성공 지표

**기능 성공:**
- [ ] 사용자가 학과 필터 선택 시 300ms 후 차트 업데이트
- [ ] 다중 필터 적용 시 AND 조건으로 데이터 필터링
- [ ] 필터 결과 없음 시 빈 상태 UI 표시
- [ ] 필터 초기화 시 전체 데이터로 복원

**성능 성공:**
- [ ] 필터링 API 응답 시간 < 200ms (평균)
- [ ] 디바운싱으로 불필요한 API 호출 방지 (10회 → 1회)
- [ ] 병렬 API 호출로 전체 로딩 시간 최소화

**품질 성공:**
- [ ] 테스트 커버리지 70% 이상
- [ ] 모든 에러 케이스 핸들링
- [ ] 보안 검증 (SQL Injection, XSS 방어)

---

**문서 끝**
</file>

<file path="006-dashboard-filtering/spec.md">
# 대시보드 필터링 기능 상세 유스케이스

**기능명:** 대시보드 필터링 (Dashboard Filtering)
**우선순위:** P0-MVP
**작성일:** 2025-11-02
**수정자:** Claude Code
**버전:** 2.0 (speccheck.md 개선사항 반영 완료)

**✅ 개선 완료**: speccheck.md 검토 보고서의 권장사항을 반영하여 다음 내용이 추가/개선되었습니다:
- 레이어 아키텍처 준수 명확화 (View/Service/Repository 분리)
- 보안 요구사항 구체화 (입력 검증, XSS/CSRF 방어, 로깅)
- 에러 코드 표준화 및 전체 목록
- 필터 옵션 동적 로딩 API 명세
- 프런트엔드 아키텍처 정합성 (Hook 역할 분리)
- 디바운싱 구현 세부사항 (useRef + cleanup)
- 차트 데이터 동기화 전략
- 테스트 데이터 준비 전략

---

## 1. 기능 개요

대시보드에서 사용자가 학과, 기간, 학적상태, 저널등급 등의 조건을 선택하여 특정 데이터만 조회할 수 있는 필터링 기능입니다. 프런트엔드에서 React State로 필터 상태를 관리하고, API 쿼리 파라미터로 백엔드에 전달하여 Django ORM WHERE 절을 적용합니다.

**핵심 가치:**
- 사용자가 관심 있는 데이터만 빠르게 조회
- 직관적이고 간단한 단일 선택 방식 (MVP 제약)
- 불필요한 API 호출 방지 (디바운싱)

**MVP 제약:**
- 단순 단일 선택만 지원 (복잡한 다중 선택 제외)
- 커스텀 날짜 범위 선택 제외 (프리셋만 제공)
- URL 쿼리 파라미터 공유 기능은 POST-MVP

---

## 2. 사용자 스토리 (GIVEN-WHEN-THEN)

### 스토리 1: 학과 필터 적용
```
GIVEN 내부 직원이 메인 대시보드에 접속한 상태에서
WHEN 학과 필터 드롭다운에서 "컴퓨터공학과"를 선택하면
THEN 모든 차트가 컴퓨터공학과 데이터만으로 업데이트되고
AND 필터 초기화 버튼이 활성화된다
```

### 스토리 2: 기간 필터 적용
```
GIVEN 학과 필터가 이미 적용된 상태에서
WHEN 기간 필터에서 "2024년"을 선택하면
THEN 2024년 + 컴퓨터공학과 데이터만 차트에 표시되고
AND 두 필터가 AND 조건으로 결합된다
```

### 스토리 3: 필터 결과 없음
```
GIVEN 사용자가 학과와 기간 필터를 적용한 상태에서
WHEN 해당 조건에 맞는 데이터가 없으면
THEN 차트 영역에 "선택한 조건에 해당하는 데이터가 없습니다" 메시지가 표시되고
AND 필터 초기화 버튼이 강조 표시된다
```

### 스토리 4: 필터 초기화
```
GIVEN 여러 필터가 적용된 상태에서
WHEN "전체 보기" 버튼을 클릭하면
THEN 모든 필터가 기본값으로 리셋되고
AND 전체 데이터로 차트가 복원된다
```

---

## 3. Primary Actor

**내부 직원 (Internal Staff / Viewer)**
- 대학교 전 직원에게 대시보드 조회 권한 부여
- 의사결정을 위해 특정 조건의 데이터 조회 필요
- 기술적 숙련도: 초급~중급 (드롭다운 사용 가능)

---

## 4. Precondition (사용자 관점)

1. 사용자가 메인 대시보드 페이지에 접속한 상태
2. 최소 1개 이상의 데이터 파일이 업로드되어 차트가 표시 중
3. 브라우저가 JavaScript를 지원하며 정상 작동 중

---

## 5. Trigger

- 사용자가 필터 드롭다운 또는 라디오 버튼/체크박스를 클릭
- 필터 값 선택 후 디바운싱(300ms) 타이머 만료
- 필터 초기화 버튼 클릭

---

## 6. Main Scenario

### 6.1 필터 조건 선택 및 적용

**Step 1: 사용자가 필터 UI 접근**
- 대시보드 상단 또는 우측에 필터 패널 표시
- 4가지 필터 옵션 제공:
  - 학과 필터 (드롭다운, 공통)
  - 기간 필터 (드롭다운, 공통)
  - 학적상태 필터 (라디오 버튼, 학생 차트 전용)
  - 저널등급 필터 (체크박스, 논문 차트 전용)

**Step 2: 필터 값 선택**
- 학과 드롭다운 옵션:
  - "전체 학과" (기본값)
  - "컴퓨터공학과", "전자공학과", ... (DB에서 동적 로드)
- 기간 드롭다운 옵션:
  - "최근 1년" (기본값)
  - "최근 3년"
  - "2024년", "2023년", "2022년", ...
- 학적상태 라디오 버튼:
  - "전체" (기본값)
  - "재학"
  - "졸업"
- 저널등급 체크박스:
  - "SCIE"
  - "KCI"
  - "전체" 선택 시 모든 체크 해제

**Step 3: React State 업데이트**
- 선택된 값을 React State에 저장
- 디바운싱 타이머 시작 (300ms)
- 선택된 필터 UI에 시각적 피드백 (하이라이트)

**Step 4: 디바운싱 후 API 호출**
- 300ms 동안 추가 변경이 없으면 API 호출 실행
- 필터 조건을 쿼리 파라미터로 변환
- 예시:
  ```
  GET /api/dashboard/research-funding/?department=컴퓨터공학과&year=2024
  GET /api/dashboard/students/?department=컴퓨터공학과&status=재학
  GET /api/dashboard/publications/?department=컴퓨터공학과&year=2024&tier=SCIE
  GET /api/dashboard/department-kpi/?year=2024
  ```

**Step 5: 백엔드 필터링 쿼리 실행**
- DRF View에서 쿼리 파라미터 파싱
- Django ORM WHERE 절 동적 구성:
  ```python
  queryset = ResearchProject.objects.all()
  if department != 'all':
      queryset = queryset.filter(department=department)
  if year != 'latest':
      queryset = queryset.filter(execution_date__year=year)
  ```
- 필터링된 데이터 집계 및 JSON 응답 반환

**Step 6: 차트 리렌더링**
- 프런트엔드에서 새 데이터 수신
- Recharts 컴포넌트 데이터 바인딩 업데이트
- 부드러운 애니메이션과 함께 차트 전환 (1초 미만)
- 로딩 스피너는 짧게 표시

**Step 7: 사용자 피드백**
- 필터링된 차트 표시
- 필터 드롭다운에 선택된 값 표시
- "전체 보기" 버튼 활성화

### 6.2 필터 초기화

**Step 1: 사용자가 "전체 보기" 버튼 클릭**
- 버튼 위치: 필터 패널 하단 또는 우측 상단

**Step 2: React State 리셋**
- 모든 필터 값을 기본값으로 변경:
  - 학과: "전체 학과"
  - 기간: "최근 1년"
  - 학적상태: "전체"
  - 저널등급: 전체 체크 해제

**Step 3: 기본 필터로 API 재호출**
- 기본 조건으로 데이터 요청
- 예시: `GET /api/dashboard/research-funding/?department=all&year=latest`

**Step 4: 차트 전체 데이터로 복원**
- 필터 드롭다운 기본값으로 리셋
- "전체 보기" 버튼 비활성화

---

## 7. Edge Cases

### Case 1: 필터 결과 데이터 없음
**발생 조건:** 선택한 필터 조건에 해당하는 레코드가 DB에 없음

**처리:**
- 차트 영역에 빈 상태 일러스트레이션 표시
- 메시지: "선택한 조건에 해당하는 데이터가 없습니다."
- 추천: "다른 필터 조건을 선택하거나 '전체 보기'를 클릭하세요."
- 필터 초기화 버튼 강조 (파란색 테두리)

### Case 2: 잘못된 필터 값 (URL 직접 수정)
**발생 조건:** 사용자가 URL을 직접 편집하여 유효하지 않은 필터 값 전달

**처리:**
- 백엔드에서 400 Bad Request 반환
- 프런트엔드에서 에러 토스트 표시: "유효하지 않은 필터 값입니다."
- 자동으로 필터 초기화 수행
- 전체 데이터로 차트 복원

### Case 3: 필터 빠른 연속 변경
**발생 조건:** 사용자가 드롭다운에서 여러 옵션을 빠르게 클릭

**처리:**
- 디바운싱으로 마지막 선택만 적용
- 중간 선택 값들은 무시
- 불필요한 API 호출 방지
- 예시: 300ms 내에 "컴퓨터공학과" → "전자공학과" 선택 시, "전자공학과"만 적용

### Case 4: API 호출 실패
**발생 조건:** 네트워크 오류 또는 서버 에러로 필터링 API 호출 실패

**처리:**
- 기존 차트 데이터 유지 (마지막 성공 데이터)
- 에러 토스트 알림: "필터 적용 중 오류가 발생했습니다. 다시 시도하세요."
- "재시도" 버튼 표시
- 필터 값은 UI에 유지 (사용자가 다시 선택하지 않아도 됨)

### Case 5: 다중 필터 조합으로 결과 과도하게 좁음
**발생 조건:** 학과 + 기간 + 학적상태 등 여러 필터 동시 적용 시 데이터 1~2건만 존재

**처리:**
- 정상적으로 필터링된 데이터 표시
- 하단에 인포 메시지: "필터 조건이 매우 구체적입니다. 더 많은 데이터를 보려면 필터를 완화하세요."
- 차트는 표시하되, 데이터 포인트가 매우 적다는 것을 시각적으로 표현

### Case 6: 필터 적용 중 페이지 새로고침
**발생 조건:** 사용자가 필터 적용 중 브라우저 새로고침 (F5)

**처리 (MVP):**
- 필터 상태 손실 (세션 내에서만 유지)
- 페이지 로드 시 기본 필터 값으로 초기화
- (POST-MVP: URL 쿼리 파라미터로 필터 상태 복원)

---

## 8. Business Rules

### BR1: 필터 조합 AND 조건
- 여러 필터가 선택되면 AND 조건으로 결합
- 예시: 학과="컴퓨터공학과" AND 기간="2024년"

### BR2: 기본 필터 값
- 학과: "전체 학과" (WHERE 절 미적용)
- 기간: "최근 1년" (현재 날짜 기준 -365일)

### BR3: 차트별 필터 독립성
- 공통 필터(학과, 기간)는 모든 차트에 적용
- 전용 필터(학적상태, 저널등급)는 특정 차트에만 적용
- 예시: 학적상태 필터는 학생 차트에만 영향

### BR4: 디바운싱 시간
- 필터 선택 후 300ms 대기
- 빠른 연속 선택 시 마지막 값만 API 호출

### BR5: 필터 UI 활성화 조건
- 데이터가 존재하는 필터 옵션만 활성화
- 예시: DB에 2024년 데이터만 있으면 "2023년" 옵션 비활성화 (또는 회색 표시)

---

## 9. API 명세

### 9.1 연구비 집행 필터링 API

**Endpoint:** `GET /api/dashboard/research-funding/`

**Query Parameters:**
| 파라미터 | 타입 | 필수 | 기본값 | 설명 |
|---------|------|------|--------|------|
| department | String | N | "all" | 학과명 또는 "all" |
| year | String | N | "latest" | YYYY 형식 또는 "latest" (최근 1년) |
| period | String | N | "1y" | "1y", "3y" (년수) |

**Response (200 OK):**
```json
{
  "current_balance": 1530000000,
  "trend": [
    {
      "month": "2024-01",
      "execution_amount": 120000000,
      "balance": 1530000000
    },
    {
      "month": "2024-02",
      "execution_amount": 98000000,
      "balance": 1432000000
    }
  ]
}
```

**Error Response (400 Bad Request):**
```json
{
  "error": "invalid_parameter",
  "message": "유효하지 않은 필터 값입니다.",
  "details": {
    "year": "올바른 연도 형식이 아닙니다. (YYYY)"
  }
}
```

### 9.2 학생 현황 필터링 API

**Endpoint:** `GET /api/dashboard/students/`

**Query Parameters:**
| 파라미터 | 타입 | 필수 | 기본값 | 설명 |
|---------|------|------|--------|------|
| department | String | N | "all" | 학과명 또는 "all" |
| status | String | N | "all" | "재학", "졸업", "all" |
| program_type | String | N | "all" | "학사", "석사", "박사", "all" |

**Response (200 OK):**
```json
{
  "total_students": 1234,
  "by_department": [
    {
      "department": "컴퓨터공학과",
      "program_breakdown": {
        "학사": 120,
        "석사": 35,
        "박사": 12
      }
    }
  ]
}
```

### 9.3 논문 실적 필터링 API

**Endpoint:** `GET /api/dashboard/publications/`

**Query Parameters:**
| 파라미터 | 타입 | 필수 | 기본값 | 설명 |
|---------|------|------|--------|------|
| department | String | N | "all" | 학과명 또는 "all" |
| year | String | N | "latest" | YYYY 형식 또는 "latest" |
| tier | String | N | "all" | "SCIE", "KCI", "all" |

**Response (200 OK):**
```json
{
  "total_papers": 156,
  "avg_impact_factor": 2.3,
  "by_tier": [
    {
      "tier": "SCIE",
      "count": 89,
      "percentage": 57.1,
      "avg_if": 3.2
    },
    {
      "tier": "KCI",
      "count": 67,
      "percentage": 42.9,
      "avg_if": null
    }
  ]
}
```

### 9.4 학과 KPI 필터링 API

**Endpoint:** `GET /api/dashboard/department-kpi/`

**Query Parameters:**
| 파라미터 | 타입 | 필수 | 기본값 | 설명 |
|---------|------|------|--------|------|
| year | String | N | "latest" | YYYY 형식 또는 "latest" |
| department | String | N | "all" | 학과명 또는 "all" |

**Response (200 OK):**
```json
{
  "trend": [
    {
      "year": 2023,
      "avg_employment_rate": 78.5,
      "total_tech_income": 123000000
    },
    {
      "year": 2024,
      "avg_employment_rate": 80.2,
      "total_tech_income": 145000000
    }
  ]
}
```

### 9.5 필터 옵션 메타데이터 API

**Endpoint:** `GET /api/dashboard/filter-options/`

**Query Parameters:** 없음

**Response (200 OK):**
```json
{
  "departments": [
    "전체 학과",
    "컴퓨터공학과",
    "전자공학과",
    "기계공학과",
    "화학공학과",
    "산업공학과"
  ],
  "years": [
    "최근 1년",
    "최근 3년",
    "2024년",
    "2023년",
    "2022년",
    "2021년"
  ],
  "student_statuses": [
    "전체",
    "재학",
    "졸업",
    "휴학"
  ],
  "journal_tiers": [
    "SCIE",
    "KCI"
  ]
}
```

**프런트엔드 처리:**
- 대시보드 마운트 시 1회 호출
- React Context 또는 전역 상태에 캐싱
- 실패 시 하드코딩된 기본값 사용 (Fallback)

```javascript
// hooks/useFilterOptions.js
import { useState, useEffect } from 'react';
import { dataApiClient } from '../api/dataApiClient';

const DEFAULT_OPTIONS = {
  departments: ['전체 학과', '컴퓨터공학과', '전자공학과'],
  years: ['최근 1년', '2024년', '2023년'],
  student_statuses: ['전체', '재학', '졸업'],
  journal_tiers: ['SCIE', 'KCI']
};

export const useFilterOptions = () => {
  const [options, setOptions] = useState(DEFAULT_OPTIONS);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    const fetchOptions = async () => {
      try {
        const response = await dataApiClient.get('/api/dashboard/filter-options/');
        setOptions(response.data);
      } catch (error) {
        console.warn('Failed to load filter options, using defaults', error);
        // 실패 시 기본값 유지
      } finally {
        setIsLoading(false);
      }
    };

    fetchOptions();
  }, []);

  return { options, isLoading };
};
```

**Error Response (500 Internal Server Error):**
```json
{
  "error": "server_error",
  "message": "필터 옵션을 불러오는 중 오류가 발생했습니다.",
  "timestamp": "2025-11-02T10:30:00Z"
}
```

---

## 10. 프런트엔드 아키텍처 정합성

### 10.1 레이어별 책임 분리

**CLAUDE.md 프런트엔드 구조 준수:**

**hooks/useDashboardFilter.js** (필터 상태 관리 전담)
- 필터 상태 관리 (React State)
- 디바운싱 로직
- 필터 변경 핸들러
- 필터 초기화 핸들러

**hooks/useDashboardData.js** (데이터 관리)
- API 호출 오케스트레이션
- 차트 데이터 변환 (UI 라이브러리 독립적)
- 로딩/에러 상태 관리

**api/dataApiClient.js** (API Contract Layer)
- HTTP 요청 전송 (Axios/Fetch)
- 쿼리 파라미터 직렬화
- 에러 응답 파싱
- 인증 헤더 관리 (필요 시)

**components/dashboard/FilterPanel.jsx** (Presentation Layer)
- 필터 UI 렌더링
- 사용자 입력 이벤트 핸들링
- useDashboardFilter Hook 사용

### 10.2 필터 상태 관리 (hooks/useDashboardFilter.js)

```javascript
// hooks/useDashboardFilter.js
import { useState, useRef, useEffect, useCallback } from 'react';

export const useDashboardFilter = () => {
  const [filters, setFilters] = useState({
    department: 'all',
    year: 'latest',
    period: '1y',
    studentStatus: 'all',
    journalTier: 'all'
  });

  const [isFilterApplied, setIsFilterApplied] = useState(false);
  const debounceTimerRef = useRef(null);

  // 필터 변경 핸들러 (디바운싱 포함)
  const handleFilterChange = useCallback((filterKey, value) => {
    // State 업데이트
    setFilters(prev => ({
      ...prev,
      [filterKey]: value
    }));

    // 디바운싱
    if (debounceTimerRef.current) {
      clearTimeout(debounceTimerRef.current);
    }

    debounceTimerRef.current = setTimeout(() => {
      // 필터 적용 상태 업데이트
      setIsFilterApplied(true);
    }, 300);
  }, []);

  // 필터 초기화
  const handleResetFilters = useCallback(() => {
    const defaultFilters = {
      department: 'all',
      year: 'latest',
      period: '1y',
      studentStatus: 'all',
      journalTier: 'all'
    };

    setFilters(defaultFilters);
    setIsFilterApplied(false);
  }, []);

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      if (debounceTimerRef.current) {
        clearTimeout(debounceTimerRef.current);
      }
    };
  }, []);

  return {
    filters,
    isFilterApplied,
    handleFilterChange,
    handleResetFilters
  };
};
```

### 10.3 데이터 관리 (hooks/useDashboardData.js)

```javascript
// hooks/useDashboardData.js
import { useState, useEffect } from 'react';
import { dataApiClient } from '../api/dataApiClient';

export const useDashboardData = (filters) => {
  const [data, setData] = useState({
    researchFunding: null,
    students: null,
    publications: null,
    departmentKpi: null
  });
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState(null);

  useEffect(() => {
    const fetchAllDashboardData = async () => {
      setIsLoading(true);
      setError(null);

      try {
        // 병렬 API 호출 (Promise.all)
        const [researchFunding, students, publications, departmentKpi] = await Promise.all([
          dataApiClient.get('/api/dashboard/research-funding/', { params: filters }),
          dataApiClient.get('/api/dashboard/students/', { params: filters }),
          dataApiClient.get('/api/dashboard/publications/', { params: filters }),
          dataApiClient.get('/api/dashboard/department-kpi/', { params: filters })
        ]);

        setData({
          researchFunding: researchFunding.data,
          students: students.data,
          publications: publications.data,
          departmentKpi: departmentKpi.data
        });
      } catch (err) {
        setError(err);
        console.error('Failed to fetch dashboard data', err);
      } finally {
        setIsLoading(false);
      }
    };

    fetchAllDashboardData();
  }, [filters]); // filters 변경 시 재호출

  return { data, isLoading, error };
};
```

### 10.4 차트 데이터 동기화 전략

**MVP 권장 방식: 병렬 API 호출 (Promise.all)**

**장점:**
- 기존 API 구조 유지 (각 대시보드 엔드포인트 독립적)
- 병렬 처리로 성능 확보 (최대 응답 시간 = 가장 느린 API)
- 모든 차트 데이터가 동시에 업데이트되어 일관성 유지

**구현:**
```javascript
// 모든 차트 데이터를 한 번에 가져옴
const fetchAllDashboardData = async (filters) => {
  const [researchFunding, students, publications, departmentKpi] = await Promise.all([
    dataApiClient.get('/api/dashboard/research-funding/', { params: filters }),
    dataApiClient.get('/api/dashboard/students/', { params: filters }),
    dataApiClient.get('/api/dashboard/publications/', { params: filters }),
    dataApiClient.get('/api/dashboard/department-kpi/', { params: filters })
  ]);

  return { researchFunding, students, publications, departmentKpi };
};
```

**대안 (POST-MVP): 단일 API 호출**
```javascript
// 모든 차트 데이터를 한 번의 API로 가져옴
const fetchAllDashboardData = async (filters) => {
  const response = await dataApiClient.get('/api/dashboard/all/', { params: filters });
  return {
    researchFunding: response.data.research_funding,
    students: response.data.students,
    publications: response.data.publications,
    departmentKpi: response.data.department_kpi
  };
};
```

### 10.5 컴포넌트 통합 예시

```javascript
// pages/Dashboard.jsx
import { useDashboardFilter } from '../hooks/useDashboardFilter';
import { useDashboardData } from '../hooks/useDashboardData';
import { FilterPanel } from '../components/dashboard/FilterPanel';
import { ResearchFundingChart } from '../components/dashboard/ResearchFundingChart';

export const Dashboard = () => {
  const { filters, isFilterApplied, handleFilterChange, handleResetFilters } = useDashboardFilter();
  const { data, isLoading, error } = useDashboardData(filters);

  if (isLoading) return <LoadingSpinner />;
  if (error) return <ErrorMessage error={error} />;

  return (
    <div className="dashboard">
      <FilterPanel
        filters={filters}
        onFilterChange={handleFilterChange}
        onReset={handleResetFilters}
        isApplied={isFilterApplied}
      />
      <ResearchFundingChart data={data.researchFunding} />
      <StudentChart data={data.students} />
      <PublicationChart data={data.publications} />
      <DepartmentKpiChart data={data.departmentKpi} />
    </div>
  );
};
```

---

## 11. 백엔드 레이어 아키텍처 준수

### 11.1 레이어별 책임 분리

**Simple Layered Architecture 준수:**
- **api/views.py** (Presentation Layer): Thin Controller - 파라미터 파싱 및 Service 위임
- **services/filtering_service.py** (Service Layer): 비즈니스 로직 - 필터 조건 구성, 집계 로직
- **infrastructure/repositories.py** (Persistence Layer): 데이터 접근 - Django ORM 쿼리

### 11.2 Thin Controller (api/views.py)

```python
# api/views.py
from rest_framework.decorators import api_view
from rest_framework.response import Response
from rest_framework.exceptions import ValidationError
from services.filtering_service import FilteringService

@api_view(['GET'])
def research_funding_view(request):
    """연구비 집행 필터링 API - Thin Controller"""
    # 1. 쿼리 파라미터 파싱
    department = request.query_params.get('department', 'all')
    year = request.query_params.get('year', 'latest')

    try:
        # 2. Service Layer로 위임
        result = FilteringService.get_research_funding(department, year)
        return Response(result)
    except ValidationError as e:
        return Response({
            'error': 'invalid_parameter',
            'message': str(e),
            'details': e.detail
        }, status=400)
```

### 11.3 Service Layer (services/filtering_service.py)

```python
# services/filtering_service.py
from datetime import datetime, timedelta
from infrastructure.repositories import ResearchProjectRepository
from api.validators import validate_filter_params

class FilteringService:
    """필터링 비즈니스 로직 담당"""

    @staticmethod
    def get_research_funding(department: str, year: str) -> dict:
        """연구비 집행 데이터 필터링 및 집계"""
        # 1. 필터 파라미터 검증
        validate_filter_params({'department': department, 'year': year})

        # 2. 필터 조건 구성
        filters = FilteringService._build_date_filter(year)
        if department != 'all':
            filters['department'] = department

        # 3. Repository Layer로 데이터 조회
        queryset = ResearchProjectRepository.find_by_filters(filters)

        # 4. 집계 로직
        current_balance = FilteringService._calculate_balance(queryset)
        trend_data = FilteringService._calculate_monthly_trend(queryset)

        return {
            'current_balance': current_balance,
            'trend': trend_data
        }

    @staticmethod
    def _build_date_filter(year: str) -> dict:
        """날짜 필터 조건 구성"""
        if year == 'latest':
            one_year_ago = datetime.now() - timedelta(days=365)
            return {'execution_date__gte': one_year_ago}
        elif year.isdigit():
            return {'execution_date__year': int(year)}
        else:
            raise ValidationError({'year': '올바른 연도 형식이 아닙니다. (YYYY)'})

    @staticmethod
    def _calculate_balance(queryset) -> int:
        """현재 잔액 계산"""
        from django.db.models import Sum
        result = queryset.aggregate(
            total_budget=Sum('total_budget'),
            total_execution=Sum('execution_amount')
        )
        return (result['total_budget'] or 0) - (result['total_execution'] or 0)

    @staticmethod
    def _calculate_monthly_trend(queryset) -> list:
        """월별 집행 추이 계산"""
        from django.db.models import Sum
        trend = queryset.values('execution_date__month').annotate(
            execution_amount=Sum('execution_amount')
        ).order_by('execution_date__month')
        return list(trend)
```

### 11.4 Repository Layer (infrastructure/repositories.py)

```python
# infrastructure/repositories.py
from infrastructure.models import ResearchProject
from django.db.models import QuerySet

class ResearchProjectRepository:
    """연구비 프로젝트 데이터 접근 전담"""

    @staticmethod
    def find_by_filters(filters: dict) -> QuerySet:
        """필터 조건에 맞는 연구비 프로젝트 조회"""
        queryset = ResearchProject.objects.select_related('department').all()

        # 동적 필터링
        if filters:
            queryset = queryset.filter(**filters)

        return queryset

    @staticmethod
    def find_all() -> QuerySet:
        """전체 연구비 프로젝트 조회"""
        return ResearchProject.objects.select_related('department').all()
```

### 11.5 필터 검증 로직 (api/validators.py)

```python
# api/validators.py
from rest_framework.exceptions import ValidationError

VALID_DEPARTMENTS = ['컴퓨터공학과', '전자공학과', '기계공학과', ...]
VALID_ENROLLMENT_STATUS = ['재학', '졸업', '휴학', 'all']
VALID_JOURNAL_TIERS = ['SCIE', 'KCI', 'all']

def validate_filter_params(params: dict):
    """필터 파라미터 Whitelist 검증"""
    errors = {}

    department = params.get('department')
    if department and department != 'all' and department not in VALID_DEPARTMENTS:
        errors['department'] = '유효하지 않은 학과입니다.'

    year = params.get('year')
    if year and year != 'latest' and not (year.isdigit() and len(year) == 4):
        errors['year'] = '올바른 연도 형식이 아닙니다. (YYYY)'

    if errors:
        raise ValidationError(errors)
```

---

## 12. 보안 요구사항 (Security Requirements)

### 12.1 입력 검증 계층

**클라이언트 검증 (UX 개선 목적):**
- 드롭다운 UI로 유효한 옵션만 선택 가능
- URL 쿼리 파라미터 직접 조작 시도 감지 (POST-MVP)

```javascript
// URL에서 필터 읽기 (POST-MVP 기능)
const urlParams = new URLSearchParams(window.location.search);
const department = urlParams.get('department');

// Whitelist 검증
const VALID_DEPARTMENTS = ['컴퓨터공학과', '전자공학과', ...];
if (department && !VALID_DEPARTMENTS.includes(department)) {
  console.warn('Invalid department in URL');
  resetFilters();
}
```

**서버 검증 (보안 필수):**
- 모든 쿼리 파라미터 Whitelist 검증 (validators.py)
- Django ORM Parameterized Query 사용 (SQL Injection 방어)
- Serializer 레벨 타입 검증

### 12.2 XSS 방어

**React 기본 방어 메커니즘:**
- JSX는 기본적으로 값을 이스케이프 처리
- `dangerouslySetInnerHTML` 사용 금지

**차트 라벨 sanitization:**
```javascript
// Recharts에 사용자 입력 렌더링 시
import DOMPurify from 'dompurify';

const sanitizedLabel = DOMPurify.sanitize(userInputLabel);
<LineChart data={data}>
  <XAxis label={sanitizedLabel} />
</LineChart>
```

### 12.3 CSRF 방어

**MVP:**
- GET 요청만 사용하므로 CSRF 위험 없음 (조회 전용)
- State-changing operation이 없으므로 CSRF 토큰 불필요

**POST-MVP (필터 프리셋 저장 기능 추가 시):**
- DRF CSRF middleware 활성화
- POST/PUT/DELETE 요청에 CSRF 토큰 필수

### 12.4 로깅 및 감사 (Audit)

**로깅 대상:**
- 필터 API 호출 빈도 (IP, User Agent, 필터 조건)
- 400/500 에러 발생 시 상세 컨텍스트
- 비정상적으로 많은 API 호출 (Potential DoS)

**로깅 레벨:**
- INFO: 정상 필터 요청
- WARNING: 잘못된 필터 값 (400)
- ERROR: 서버 에러 (500)

**구현 예시:**
```python
import logging
logger = logging.getLogger(__name__)

@api_view(['GET'])
def research_funding_view(request):
    logger.info(f"Filter request: {request.query_params}", extra={
        'ip': request.META.get('REMOTE_ADDR'),
        'user_agent': request.META.get('HTTP_USER_AGENT')
    })
    # ... 필터링 로직
```

### 12.5 SQL Injection 방어

**Django ORM Parameterized Query 사용:**
```python
# ✅ 안전 (Parameterized Query)
queryset = ResearchProject.objects.filter(department=department)

# ❌ 위험 (Raw SQL)
queryset = ResearchProject.objects.raw(
    f"SELECT * FROM research_project WHERE department='{department}'"
)
```

**Raw SQL 사용 시 (불가피한 경우):**
```python
from django.db import connection

with connection.cursor() as cursor:
    # Parameterized query 사용
    cursor.execute(
        "SELECT * FROM research_project WHERE department=%s",
        [department]  # 파라미터 바인딩
    )
```

---

## 13. 에러 코드 명세 (Error Codes)

### 13.1 표준 에러 응답 구조

**모든 API 엔드포인트 공통 형식:**
```json
{
  "error": "error_code",
  "message": "사용자 친화적 메시지 (한글)",
  "details": {
    "field_name": "구체적인 에러 설명"
  },
  "timestamp": "2025-11-02T10:30:00Z",
  "path": "/api/dashboard/research-funding/"
}
```

### 13.2 에러 코드 전체 목록

| 에러 코드 | HTTP Status | 메시지 | 프런트엔드 처리 |
|----------|-------------|--------|----------------|
| `invalid_parameter` | 400 | 유효하지 않은 필터 값입니다. | 에러 토스트 + 필터 초기화 |
| `invalid_year_format` | 400 | 올바른 연도 형식이 아닙니다. (YYYY) | 에러 토스트 + 연도 필터 리셋 |
| `invalid_department` | 400 | 유효하지 않은 학과입니다. | 에러 토스트 + 학과 필터 리셋 |
| `invalid_status` | 400 | 유효하지 않은 학적상태입니다. | 에러 토스트 + 상태 필터 리셋 |
| `invalid_journal_tier` | 400 | 유효하지 않은 저널등급입니다. | 에러 토스트 + 저널 필터 리셋 |
| `server_error` | 500 | 서버 오류가 발생했습니다. | 에러 토스트 + 재시도 버튼 |
| `timeout` | 504 | 요청 시간이 초과되었습니다. | 에러 토스트 + 재시도 버튼 |

### 13.3 프런트엔드 에러 핸들링 매핑

```javascript
// api/dataApiClient.js
const handleApiError = (error) => {
  const errorCode = error.response?.data?.error;
  const message = error.response?.data?.message;

  switch (errorCode) {
    case 'invalid_parameter':
    case 'invalid_year_format':
    case 'invalid_department':
      toast.error(message);
      resetFilters();
      break;
    case 'server_error':
    case 'timeout':
      toast.error(message, {
        action: {
          label: '재시도',
          onClick: () => retryRequest()
        }
      });
      break;
    default:
      toast.error('알 수 없는 오류가 발생했습니다.');
  }
};
```

---

## 14. 테스트 요구사항 (TDD)

### 14.1 Unit Tests (70%)

**프런트엔드 (React/Jest):**
```javascript
describe('Dashboard Filter Logic', () => {
  it('필터 선택 시 state가 올바르게 업데이트되어야 함', () => {
    const { result } = renderHook(() => useDashboardData());
    act(() => {
      result.current.handleFilterChange('department', '컴퓨터공학과');
    });
    expect(result.current.filters.department).toBe('컴퓨터공학과');
  });

  it('디바운싱이 300ms 후에 API 호출해야 함', async () => {
    jest.useFakeTimers();
    const mockFetch = jest.fn();
    const { result } = renderHook(() => useDashboardData());

    act(() => {
      result.current.handleFilterChange('department', '컴퓨터공학과');
      jest.advanceTimersByTime(299);
    });
    expect(mockFetch).not.toHaveBeenCalled();

    act(() => {
      jest.advanceTimersByTime(1);
    });
    expect(mockFetch).toHaveBeenCalledTimes(1);
  });

  it('필터 초기화 시 모든 필터가 기본값으로 리셋되어야 함', () => {
    const { result } = renderHook(() => useDashboardData());
    act(() => {
      result.current.handleFilterChange('department', '컴퓨터공학과');
      result.current.handleResetFilters();
    });
    expect(result.current.filters.department).toBe('all');
  });
});
```

**백엔드 (Django/pytest):**
```python
def test_filter_by_department(client, research_projects_data):
    """학과 필터 적용 시 해당 학과 데이터만 반환"""
    response = client.get('/api/dashboard/research-funding/?department=컴퓨터공학과')
    assert response.status_code == 200
    data = response.json()
    # 모든 데이터가 컴퓨터공학과인지 검증
    for item in data['trend']:
        assert item['department'] == '컴퓨터공학과'

def test_filter_by_year(client, research_projects_data):
    """연도 필터 적용 시 해당 연도 데이터만 반환"""
    response = client.get('/api/dashboard/research-funding/?year=2024')
    assert response.status_code == 200
    data = response.json()
    for item in data['trend']:
        assert item['month'].startswith('2024')

def test_invalid_filter_value_returns_400(client):
    """잘못된 필터 값 전달 시 400 에러 반환"""
    response = client.get('/api/dashboard/research-funding/?year=invalid')
    assert response.status_code == 400
    assert 'error' in response.json()

def test_multiple_filters_combined_with_and(client, research_projects_data):
    """다중 필터 적용 시 AND 조건으로 결합"""
    response = client.get('/api/dashboard/research-funding/?department=컴퓨터공학과&year=2024')
    assert response.status_code == 200
    data = response.json()
    # 컴퓨터공학과 AND 2024년 데이터만 존재
    assert all(
        item['department'] == '컴퓨터공학과' and item['month'].startswith('2024')
        for item in data['trend']
    )
```

### 14.2 Integration Tests (20%)

```python
def test_filter_workflow_end_to_end(client, uploaded_data):
    """필터 선택 → API 호출 → 차트 업데이트 전체 플로우"""
    # 1. 초기 데이터 로드
    response = client.get('/api/dashboard/research-funding/')
    assert response.status_code == 200
    initial_count = len(response.json()['trend'])

    # 2. 필터 적용
    response = client.get('/api/dashboard/research-funding/?department=컴퓨터공학과')
    assert response.status_code == 200
    filtered_count = len(response.json()['trend'])
    assert filtered_count < initial_count  # 필터링으로 데이터 감소

    # 3. 필터 초기화 (기본값으로 재요청)
    response = client.get('/api/dashboard/research-funding/?department=all&year=latest')
    assert response.status_code == 200
    reset_count = len(response.json()['trend'])
    assert reset_count == initial_count  # 전체 데이터로 복원
```

### 14.3 E2E Tests (10%)

```javascript
// Playwright 또는 Cypress
describe('Dashboard Filtering E2E', () => {
  it('사용자가 학과 필터를 선택하고 차트가 업데이트됨', async () => {
    await page.goto('/dashboard');

    // 초기 차트 데이터 포인트 수 확인
    const initialPoints = await page.$$('.recharts-line-dot');

    // 학과 필터 드롭다운 클릭 및 선택
    await page.click('[data-testid="department-filter"]');
    await page.click('[data-value="컴퓨터공학과"]');

    // 300ms 디바운싱 대기
    await page.waitForTimeout(350);

    // API 응답 대기
    await page.waitForResponse(res =>
      res.url().includes('/api/dashboard/') && res.status() === 200
    );

    // 차트 리렌더링 확인
    const filteredPoints = await page.$$('.recharts-line-dot');
    expect(filteredPoints.length).toBeLessThan(initialPoints.length);

    // 필터 드롭다운에 선택된 값 표시 확인
    const selectedValue = await page.$eval(
      '[data-testid="department-filter"]',
      el => el.textContent
    );
    expect(selectedValue).toContain('컴퓨터공학과');
  });

  it('필터 결과 없을 시 빈 상태 메시지 표시', async () => {
    await page.goto('/dashboard');

    // 존재하지 않는 데이터 조합 필터 선택
    await page.click('[data-testid="department-filter"]');
    await page.click('[data-value="특수학과"]');
    await page.waitForTimeout(350);

    // 빈 상태 메시지 표시 확인
    const emptyMessage = await page.textContent('[data-testid="empty-state"]');
    expect(emptyMessage).toContain('선택한 조건에 해당하는 데이터가 없습니다');
  });
});
```

### 14.4 테스트 데이터 준비 (Test Fixtures)

**Django Fixtures:**
```python
# tests/fixtures/research_projects.py
import pytest
from django.utils import timezone
from datetime import timedelta
from data_ingestion.infrastructure.models import ResearchProject

@pytest.fixture
def research_projects_data(db):
    """필터링 테스트용 연구비 데이터"""
    projects = [
        ResearchProject(
            execution_id='R2024001',
            department='컴퓨터공학과',
            total_budget=10000000,
            execution_date=timezone.now(),
            execution_amount=1000000
        ),
        ResearchProject(
            execution_id='R2024002',
            department='전자공학과',
            total_budget=8000000,
            execution_date=timezone.now() - timedelta(days=30),
            execution_amount=800000
        ),
        ResearchProject(
            execution_id='R2023001',
            department='컴퓨터공학과',
            total_budget=5000000,
            execution_date=timezone.now() - timedelta(days=200),
            execution_amount=500000
        ),
        # 최소 10개 이상의 다양한 데이터 생성
        # (다양한 학과, 연도, 금액)
    ]
    ResearchProject.objects.bulk_create(projects)
    return projects
```

**React Testing Library Mocks:**
```javascript
// tests/mocks/dashboardData.js
export const mockResearchFundingData = {
  current_balance: 1530000000,
  trend: [
    { month: '2024-01', execution_amount: 120000000, balance: 1530000000 },
    { month: '2024-02', execution_amount: 98000000, balance: 1432000000 },
    { month: '2024-03', execution_amount: 105000000, balance: 1327000000 },
  ]
};

export const mockStudentData = {
  total_students: 1234,
  by_department: [
    {
      department: '컴퓨터공학과',
      program_breakdown: {
        '학사': 120,
        '석사': 35,
        '박사': 12
      }
    },
    {
      department: '전자공학과',
      program_breakdown: {
        '학사': 150,
        '석사': 40,
        '박사': 10
      }
    }
  ]
};

export const mockPublicationData = {
  total_papers: 156,
  avg_impact_factor: 2.3,
  by_tier: [
    { tier: 'SCIE', count: 89, percentage: 57.1, avg_if: 3.2 },
    { tier: 'KCI', count: 67, percentage: 42.9, avg_if: null }
  ]
};

export const mockDepartmentKpiData = {
  trend: [
    { year: 2023, avg_employment_rate: 78.5, total_tech_income: 123000000 },
    { year: 2024, avg_employment_rate: 80.2, total_tech_income: 145000000 }
  ]
};
```

**MSW (Mock Service Worker) 설정:**
```javascript
// tests/mocks/handlers.js
import { rest } from 'msw';
import { mockResearchFundingData, mockStudentData } from './dashboardData';

export const handlers = [
  rest.get('/api/dashboard/research-funding/', (req, res, ctx) => {
    const department = req.url.searchParams.get('department');
    const year = req.url.searchParams.get('year');

    // 필터에 따라 다른 응답 반환 (테스트 시나리오별)
    if (department === '컴퓨터공학과') {
      return res(ctx.json({
        ...mockResearchFundingData,
        trend: mockResearchFundingData.trend.slice(0, 2) // 필터링된 결과
      }));
    }

    return res(ctx.json(mockResearchFundingData));
  }),

  rest.get('/api/dashboard/filter-options/', (req, res, ctx) => {
    return res(ctx.json({
      departments: ['전체 학과', '컴퓨터공학과', '전자공학과'],
      years: ['최근 1년', '2024년', '2023년'],
      student_statuses: ['전체', '재학', '졸업'],
      journal_tiers: ['SCIE', 'KCI']
    }));
  })
];
```

---

## 15. 성능 요구사항

### 15.1 디바운싱
- 필터 선택 후 300ms 대기
- 빠른 연속 선택 시 불필요한 API 호출 방지
- 최대 절감: 10회 선택 → 1회 API 호출

### 15.2 API 응답 시간
- 필터링 쿼리 실행: 평균 200ms 이하
- 복잡한 집계 포함 시: 500ms 이하
- 타임아웃: 5초

### 15.3 차트 리렌더링
- Recharts 애니메이션 시간: 500ms~1초
- 로딩 스피너 표시: 500ms 이상 소요 시

### 15.4 데이터베이스 인덱스 전략

**필수 인덱스:**
```python
# infrastructure/models.py
class ResearchProject(models.Model):
    # ... 필드 정의
    class Meta:
        indexes = [
            models.Index(fields=['department', 'execution_date']),  # Composite index
            models.Index(fields=['execution_date']),  # 날짜 범위 쿼리용
        ]

class Student(models.Model):
    # ... 필드 정의
    class Meta:
        indexes = [
            models.Index(fields=['department', 'enrollment_status']),
        ]

class Publication(models.Model):
    # ... 필드 정의
    class Meta:
        indexes = [
            models.Index(fields=['department', 'journal_tier']),
        ]
```

**성능 목표:**
- 1만 건 데이터: < 50ms
- 10만 건 데이터: < 200ms
- 100만 건 데이터: < 500ms (MVP 범위 외)

---

## 16. UX 고려사항

### 16.1 필터 UI 배치
- 위치: 대시보드 상단 또는 우측 사이드바
- 공통 필터(학과, 기간)는 항상 표시
- 차트별 전용 필터는 해당 차트 근처에 표시

### 16.2 시각적 피드백
- 필터 선택 시 하이라이트 효과
- 적용 중 로딩 스피너 (300ms 이상 소요 시)
- 필터 초기화 버튼 색상 변경 (활성/비활성)

### 16.3 접근성 (Accessibility)
- 키보드 네비게이션 지원 (Tab, Enter)
- 스크린 리더 지원 (ARIA 라벨)
- 색상 대비 WCAG AA 준수

### 16.4 모바일 대응 (POST-MVP)
- MVP: 데스크톱 우선
- POST-MVP: 모바일 필터 패널 슬라이드 방식

---

## 17. Out of Scope (POST-MVP)

### 17.1 URL 기반 필터 공유
- 현재: 필터 상태는 세션 내에서만 유지
- POST-MVP: 쿼리 파라미터로 URL 생성 및 공유
  - 예시: `dashboard?dept=컴퓨터공학과&year=2024`

### 17.2 복잡한 다중 선택
- 현재: 단순 단일 선택만 지원
- POST-MVP: 여러 학과 동시 선택, 날짜 범위 슬라이더 등

### 17.3 커스텀 날짜 범위
- 현재: 프리셋만 제공 ("최근 1년", "2024년" 등)
- POST-MVP: Date Picker로 임의의 시작/종료일 선택

### 17.4 필터 프리셋 저장
- 현재: 매번 새로 선택
- POST-MVP: 자주 사용하는 필터 조합을 "즐겨찾기"로 저장

### 17.5 필터 조합 추천
- 현재: 사용자가 수동으로 선택
- POST-MVP: AI 기반으로 자주 조회되는 조합 추천

---

## 18. Sequence Diagram (PlantUML)

```plantuml
@startuml
actor User
participant FE as "Frontend\n(React)"
participant BE as "Backend\n(DRF)"
database DB as "Database\n(Supabase)"

User -> FE: 학과 필터 드롭다운 클릭
activate FE
FE -> FE: 드롭다운 옵션 표시\n(전체, 컴공, 전자, ...)

User -> FE: "컴퓨터공학과" 선택
FE -> FE: React State 업데이트\nfilters.department = "컴퓨터공학과"
FE -> FE: 디바운싱 타이머 시작 (300ms)
FE -> User: 선택 값 UI 반영\n(드롭다운에 "컴퓨터공학과" 표시)

FE -> FE: 300ms 대기 완료
FE -> BE: GET /api/dashboard/research-funding/\n?department=컴퓨터공학과&year=latest
activate BE

BE -> BE: 쿼리 파라미터 파싱 및 검증
BE -> DB: SELECT * FROM research_projects\nWHERE department='컴퓨터공학과'\nAND execution_date >= (NOW() - INTERVAL '1 year')
activate DB
DB --> BE: 필터링된 레코드 반환
deactivate DB

BE -> BE: 데이터 집계\n(월별 집행 추이, 현재 잔액)
BE --> FE: JSON 응답\n{current_balance: ..., trend: [...]}
deactivate BE

FE -> FE: 차트 데이터 바인딩 업데이트
FE -> User: 차트 리렌더링\n(Recharts 애니메이션)
FE -> User: "전체 보기" 버튼 활성화
deactivate FE

== 필터 초기화 시나리오 ==

User -> FE: "전체 보기" 버튼 클릭
activate FE
FE -> FE: React State 리셋\nfilters = {department: 'all', year: 'latest'}
FE -> BE: GET /api/dashboard/research-funding/\n?department=all&year=latest
activate BE

BE -> DB: SELECT * FROM research_projects\nWHERE execution_date >= (NOW() - INTERVAL '1 year')
activate DB
DB --> BE: 전체 레코드 반환
deactivate DB

BE -> BE: 전체 데이터 집계
BE --> FE: JSON 응답 (전체 데이터)
deactivate BE

FE -> FE: 차트 데이터 업데이트
FE -> User: 차트 전체 데이터로 복원
FE -> User: 필터 드롭다운 기본값 표시
FE -> User: "전체 보기" 버튼 비활성화
deactivate FE

== 필터 결과 없음 에러 케이스 ==

User -> FE: 존재하지 않는 조합 선택\n(예: 학과="특수학과", 연도="2020")
activate FE
FE -> FE: 300ms 디바운싱
FE -> BE: GET /api/dashboard/research-funding/\n?department=특수학과&year=2020
activate BE

BE -> DB: SELECT * FROM research_projects\nWHERE department='특수학과'\nAND execution_date__year=2020
activate DB
DB --> BE: 빈 결과 []
deactivate DB

BE -> BE: 빈 데이터 집계\n{current_balance: 0, trend: []}
BE --> FE: JSON 응답 (빈 배열)
deactivate BE

FE -> FE: 빈 결과 감지
FE -> User: 차트 영역에 빈 상태 표시\n"선택한 조건에 해당하는 데이터가 없습니다"
FE -> User: 필터 초기화 버튼 강조 (파란색 테두리)
deactivate FE

@enduml
```

---

## 19. 구현 체크리스트

### 19.1 프런트엔드 (React)
- [ ] 필터 UI 컴포넌트 작성 (드롭다운, 라디오, 체크박스)
- [ ] `useDashboardData` Hook에 필터 상태 관리 추가
- [ ] 디바운싱 로직 구현 (300ms)
- [ ] 필터 변경 핸들러 작성
- [ ] 필터 초기화 핸들러 작성
- [ ] API 호출 시 쿼리 파라미터 동적 생성
- [ ] 차트 리렌더링 로직 (Recharts 데이터 바인딩)
- [ ] 빈 상태 UI 컴포넌트 (필터 결과 없음)
- [ ] 에러 토스트 알림 (API 실패)
- [ ] 필터 UI 시각적 피드백 (하이라이트, 로딩)

### 19.2 백엔드 (DRF)
- [ ] 각 대시보드 API 엔드포인트에 필터 파라미터 추가
- [ ] 쿼리 파라미터 파싱 로직
- [ ] 필터 검증 로직 (유효하지 않은 값 400 반환)
- [ ] Django ORM WHERE 절 동적 구성
- [ ] 필터링된 데이터 집계 쿼리 최적화
- [ ] 에러 응답 표준화 (400, 500)
- [ ] 인덱스 추가 (department, execution_date 등)

### 19.3 테스트
- [ ] 프런트엔드 Unit Tests (필터 상태, 디바운싱)
- [ ] 백엔드 Unit Tests (각 필터별 쿼리 결과)
- [ ] Integration Tests (전체 플로우)
- [ ] E2E Tests (사용자 시나리오)
- [ ] 에러 케이스 테스트 (결과 없음, 잘못된 값)

---

## 20. 승인 및 검토

**작성자:** Spec Writer Agent
**검토자:** Claude Code (Specification Reviewer)
**수정일:** 2025-11-02
**버전:** 2.0

본 유스케이스 문서는 **MVP 범위**에 맞춘 대시보드 필터링 기능의 상세 명세입니다. speccheck.md 검토 보고서의 권장사항을 반영하여 다음 내용이 개선되었습니다:

**주요 개선 사항:**
- ✅ 레이어 아키텍처 준수 (View/Service/Repository 분리)
- ✅ 보안 요구사항 구체화 (입력 검증, XSS/CSRF 방어, 로깅)
- ✅ 에러 코드 표준화 및 전체 목록
- ✅ 필터 옵션 동적 로딩 API 명세
- ✅ 프런트엔드 아키텍처 정합성 (Hook 역할 분리)
- ✅ 디바운싱 구현 세부사항 (useRef + cleanup)
- ✅ 차트 데이터 동기화 전략 (병렬 API 호출)
- ✅ 테스트 데이터 준비 전략 (Django Fixtures, MSW)

**구현 준비도:** 95% - TDD 원칙에 따라 테스트를 먼저 작성하고, Red-Green-Refactor 사이클로 구현합니다.

---

**문서 끝**
</file>

<file path="db/department_kpi.csv">
평가년도,단과대학,학과,졸업생 취업률 (%),전임교원 수 (명),초빙교원 수 (명),연간 기술이전 수입액 (억원),국제학술대회 개최 횟수
2023,공과대학,컴퓨터공학과,85.5,15,4,8.5,2
2023,공과대학,전자공학과,88.2,18,3,12.1,3
2023,인문대학,국어국문학과,65.7,12,2,0.5,1
2023,인문대학,철학과,62.1,8,1,0.1,0
2024,공과대학,컴퓨터공학과,87.1,16,5,10.2,3
2024,공과대학,전자공학과,89.0,18,4,15.8,2
2024,인문대학,국어국문학과,68.2,12,2,0.8,1
2024,인문대학,철학과,63.5,8,2,0.2,1
2025,공과대학,컴퓨터공학과,88.0,17,5,13.5,4
2025,공과대학,전자공학과,90.5,19,5,22.0,3
2025,인문대학,국어국문학과,70.1,11,3,1.1,2
2025,인문대학,철학과,64.0,9,2,0.3,1
</file>

<file path="db/publication_list.csv">
논문ID,게재일,단과대학,학과,논문제목,주저자,참여저자,학술지명,저널등급,Impact Factor,과제연계여부
PUB-23-001,2023-02-18,공과대학,전자공학과,A Study on Low-Power Semiconductor Design,김민준,박지훈;최민서,IEEE Transactions on Circuits and Systems,SCIE,3.9,Y
PUB-23-002,2023-05-22,인문대학,철학과,현대 분석철학의 언어적 전회에 관한 고찰,윤지원,강예원,철학연구,KCI,,N
PUB-24-001,2024-01-30,공과대학,컴퓨터공학과,Deep Learning based Anomaly Detection in Real-Time Traffic,이서연,정현우;김유진;한지민,Expert Systems with Applications,SCIE,8.5,Y
PUB-24-002,2024-04-11,공과대학,전자공학과,Next-Generation Display Material Analysis,김민준,윤태영,Journal of Materials Chemistry C,SCIE,6.4,Y
PUB-24-003,2024-07-29,인문대학,국어국문학과,1920년대 시문학에 나타난 모더니즘 수용 양상,박서정,이수빈,한국현대문학연구,KCI,,N
PUB-25-001,2025-06-15,공과대학,컴퓨터공학과,Federated Learning for Privacy-Preserving AI,이서연,정현우,IEEE Internet of Things Journal,SCIE,10.6,Y
</file>

<file path="db/research_project_data.csv">
집행ID,과제번호,과제명,연구책임자,소속학과,지원기관,총연구비,집행일자,집행항목,집행금액,상태,비고
T2301001,NRF-2023-015,차세대 AI 반도체 설계,김민준,전자공학과,한국연구재단,500000000,2023-03-15,연구장비 도입,120000000,집행완료,A-1급 스펙트로미터
T2301002,IITP-A-23-101,자율주행 시뮬레이션 고도화,이서연,컴퓨터공학과,정보통신기획평가원,800000000,2023-04-20,외부전문가 활용비,8000000,집행완료,
T2301003,NRF-2023-015,차세대 AI 반도체 설계,김민준,전자공학과,한국연구재단,500000000,2023-05-10,시약 및 재료비,25500000,집행완료,
T2402001,SME-2024-TECH-01,중소기업 맞춤형 ERP 개발,박서준,산업공학과,중소벤처기업부,300000000,2024-02-28,인건비,50000000,집행완료,참여연구원 3개월 급여
T2402002,IITP-A-23-101,자율주행 시뮬레이션 고도화,이서연,컴퓨터공학과,정보통신기획평가원,800000000,2024-03-05,고성능 서버 임대,45000000,처리중,견적서 검토 단계
T2503001,NRF-2025-002,고대 철학 텍스트의 디지털 아카이빙,최은경,철학과,한국연구재단,80000000,2025-04-10,국외여비,4500000,집행완료,그리스 학회 참가
T2503002,SME-2024-TECH-01,중소기업 맞춤형 ERP 개발,박서준,산업공학과,중소벤처기업부,300000000,2025-05-20,기술이전료,15000000,집행완료,
T2503003,IITP-A-23-101,자율주행 시뮬레이션 고도화,이서연,컴퓨터공학과,정보통신기획평가원,800000000,2025-06-01,인건비,120000000,집행완료,
</file>

<file path="db/student_roster.csv">
학번,이름,단과대학,학과,학년,과정구분,학적상태,성별,입학년도,지도교수,이메일
20201101,김유진,공과대학,컴퓨터공학과,4,학사,재학,여,2020,이서연,yjkim@university.ac.kr
20211205,박지훈,공과대학,전자공학과,3,학사,재학,남,2021,김민준,jhpark@university.ac.kr
20221302,이수빈,인문대학,국어국문학과,2,학사,재학,여,2022,박서정,sblee@university.ac.kr
20192101,정현우,공과대학,컴퓨터공학과,0,석사,재학,남,2024,이서연,hwjung@university.ac.kr
20201215,최민서,공과대학,전자공학과,4,학사,휴학,여,2020,김민준,mschoi@university.ac.kr
20231308,강예원,인문대학,철학과,1,학사,재학,여,2023,,ywkang@university.ac.kr
20222203,윤태영,공과대학,전자공학과,0,석사,재학,남,2025,김민준,tyyoon@university.ac.kr
20211120,한지민,공과대학,컴퓨터공학과,3,학사,재학,여,2021,이서연,jmhan@university.ac.kr
20181401,서준호,사범대학,교육학과,4,학사,졸업,남,2018,최은경,jhseo@university.ac.kr
</file>

<file path="code_structure.md">
## 최종 코드베이스 구조 (Final Codebase Structure)

CTO의 핵심 가치(신속성, 간결함, 오버엔지니어링 회피)와 아키텍처 원칙(레이어 분리, SRP)을 준수하여 최종 확정된 코드베이스 구조는 다음과 같습니다. 이 구조는 **Simple Layered Architecture**를 기반으로 MVP의 성공적인 완수를 위한 **최소한의 확장성**을 보장합니다.

---

### 1. 백엔드 (DRF, Pandas, Supabase) 구조

핵심은 **`data_ingestion`** 앱 내부에 Presentation, Service, Infrastructure, Domain 계층을 명확히 분리하여, MVP의 핵심 컴포넌트인 `excel_parser.py`의 안정성을 극대화하는 것입니다.

```
my_mvp_project/
├── backend/
│   ├── config/             # Django Project 설정 및 환경 구성 (settings, urls 등)
│   ├── data_ingestion/     # 💡 핵심 비즈니스 로직 앱 (단일 책임: 데이터 수집/파싱/저장)
│   │   ├── api/            # 1. Presentation Layer (HTTP/Serialization/Contract)
│   │   │   ├── views.py      # DRF ViewSets: 요청 처리 및 Service 위임 (Thin Controller)
│   │   │   └── serializers.py  # 요청/응답 데이터 구조 정의 (External Contract)
│   │   │
│   │   ├── services/       # 2. Service/Use Case Layer (Business Logic)
│   │   │   ├── ingestion_service.py # **Use Case**: 데이터 흐름 조정 및 트랜잭션 관리 (Flow/Transaction SRP)
│   │   │   └── excel_parser.py    # **Pure Business Logic**: Pandas를 사용한 데이터 정제/검증 (Pandas Logic SRP)
│   │   │
│   │   ├── domain/         # 4. Domain Layer (Pure Concepts)
│   │   │   └── entities.py   # 순수 Python 기반 비즈니스 엔티티 (DB/API 독립적)
│   │   │
│   │   └── infrastructure/ # 3. Infrastructure/Persistence Layer (Streamlined DAO)
│   │       ├── models.py     # Django Models (Supabase 스키마 매핑)
│   │       └── repositories.py # Data Access Object (DAO): Django ORM 직접 사용 (MVP 간소화 전략)
│   │
│   └── users/              # 사용자 인증/권한 관리 앱
│       └── ...
│
├── frontend/               # React Codebase
└── infra/                  # Railway/Supabase 최소 설정 및 배포 스크립트
```

#### 핵심 모듈별 책임 (SRP 준수)

| 파일/모듈 | 레이어 | 책임 (SRP) | 간결함/확장성 전략 반영 |
| :--- | :--- | :--- | :--- |
| `api/views.py` | Presentation | HTTP 요청 처리 및 Service 호출 위임. | **Thin Controller** 원칙 준수. |
| `services/excel_parser.py` | Service | **Pandas 기반 데이터 정제 및 유효성 검증.** | 인프라 무관 **높은 테스트 용이성** 확보. |
| `services/ingestion_service.py` | Service | 데이터 파싱 $\rightarrow$ 저장 Use Case 흐름 조정 및 트랜잭션. | **단일 Use Case** 책임. |
| `infrastructure/repositories.py`| Persistence | DB (ORM)와의 데이터 입출력 (CRUD) 전담. | **추상 인터페이스 생략**으로 MVP 신속성 확보. |

---

### 2. 프런트엔드 (React) 구조

Presentation Logic과 Data Handling Logic을 분리하여, UI/라이브러리 전환에 유연한 구조를 유지합니다.

```
frontend/
└── src/
    ├── components/       # 1. Presentation/UI Components (UI 라이브러리 교체 유연성 확보)
    │   ├── ui/             # 공통 UI 요소 (Button, Input 등)
    │   └── dashboard/      # Recharts/Tremor 등 특정 라이브러리에 의존하는 Chart/Widget
    │
    ├── pages/            # View/Screen 정의 (Components 및 Hooks 조합)
    │
    ├── hooks/            # 2. State & Data Handling Logic (Business/State Logic)
    │   └── useDashboardData.js # API 호출, 데이터 필터링/변환 로직 (UI 라이브러리 독립적)
    │
    └── api/              # 3. API Contract Layer
        └── dataApiClient.js # 백엔드와의 통신(Axios 등) 전담 (Contract 변경 대응)
```
</file>

<file path="database.md">
# 데이터베이스 설계 문서 (MVP)

**프로젝트:** 대학교 사내 데이터 시각화 대시보드 MVP
**데이터베이스:** PostgreSQL (Supabase)
**작성일:** 2025년 11월 2일
**버전:** 2.0 (MVP 최적화)

---

## 문서 개요

본 문서는 대학교 사내 데이터 시각화 대시보드의 **최소 스펙(MVP)** 데이터베이스 스키마를 정의합니다. 첫 베타테스트에 필요한 핵심 기능만 포함하며, 오버엔지니어링을 철저히 배제합니다.

**핵심 설계 원칙:**
- 유저플로우에 명시된 데이터만 포함 (YAGNI 원칙)
- 정규화는 필요한 수준까지만 (MVP 성능 우선)
- 간단한 데이터 타입 사용 (복잡한 제약 조건 최소화)
- 확장 가능하지만 간결한 구조

---

## 목차

1. [데이터플로우 개요](#1-데이터플로우-개요)
2. [데이터베이스 스키마](#2-데이터베이스-스키마)
3. [테이블 상세 명세](#3-테이블-상세-명세)
4. [인덱스 전략](#4-인덱스-전략)
5. [데이터 제약 조건](#5-데이터-제약-조건)
6. [데이터 마이그레이션 전략](#6-데이터-마이그레이션-전략)

---

## 1. 데이터플로우 개요

### 1.1 전체 데이터 흐름

```
관리자 업로드
    ↓
CSV/Excel 파일 (4가지 타입)
    ↓
DRF API 엔드포인트 (POST /upload)
    ↓
Pandas 파싱 및 정제 (excel_parser.py)
    ↓
PostgreSQL (Supabase) - 4개 핵심 테이블
    ↓
DRF API 조회 (GET /dashboard/*)
    ↓
React 대시보드 시각화 (Recharts)
```

### 1.2 데이터 타입별 처리 플로우

#### 1.2.1 연구비 집행 데이터
```
research_project_data.csv
    → Pandas 파싱 (필수 컬럼 검증)
    → 날짜/금액 타입 변환
    → 중복 제거 (집행ID 기준)
    → research_projects 테이블 INSERT
    → 집계: 월별 집행 추이, 현재 잔액
```

#### 1.2.2 학생 명단 데이터
```
student_roster.csv
    → Pandas 파싱 (필수 컬럼 검증)
    → 학년/과정구분 정규화
    → 중복 제거 (학번 기준)
    → students 테이블 INSERT
    → 집계: 학과별/과정별/학년별 학생 수
```

#### 1.2.3 논문 목록 데이터
```
publication_list.csv
    → Pandas 파싱 (필수 컬럼 검증)
    → Impact Factor NULL 허용 처리
    → 중복 제거 (논문ID 기준)
    → publications 테이블 INSERT
    → 집계: 저널 등급별 논문 수, 평균 IF
```

#### 1.2.4 학과 KPI 데이터
```
department_kpi.csv
    → Pandas 파싱 (필수 컬럼 검증)
    → 취업률/수입액 타입 변환
    → 중복 제거 (평가년도+학과 복합키)
    → department_kpis 테이블 INSERT
    → 집계: 년도별 KPI 추이
```

### 1.3 데이터 갱신 전략

**MVP에서는 전체 교체 모드(Replace All) 사용:**
1. 관리자가 파일 재업로드 시
2. 해당 타입의 기존 데이터 전체 삭제 (`DELETE FROM table`)
3. 신규 데이터 Bulk Insert (`bulk_create`)
4. Django ORM 트랜잭션으로 원자성 보장

**추후 고려 사항 (MVP 이후):**
- 증분 업데이트 (UPSERT)
- 데이터 변경 이력 추적 (Audit Log)
- Soft Delete (삭제 플래그)

---

## 2. 데이터베이스 스키마

### 2.1 ERD (Entity Relationship Diagram)

```
┌─────────────────────────┐
│  research_projects      │
├─────────────────────────┤
│ PK execution_id         │ (집행ID)
│    department           │ (소속학과)
│    total_budget         │ (총연구비)
│    execution_date       │ (집행일자)
│    execution_amount     │ (집행금액)
│    created_at           │
│    updated_at           │
└─────────────────────────┘

┌─────────────────────────┐
│  students               │
├─────────────────────────┤
│ PK student_id           │ (학번)
│    department           │ (학과)
│    grade                │ (학년)
│    program_type         │ (과정구분)
│    enrollment_status    │ (학적상태)
│    created_at           │
│    updated_at           │
└─────────────────────────┘

┌─────────────────────────┐
│  publications           │
├─────────────────────────┤
│ PK paper_id             │ (논문ID)
│    department           │ (학과)
│    journal_tier         │ (저널등급)
│    impact_factor        │ (Impact Factor, nullable)
│    created_at           │
│    updated_at           │
└─────────────────────────┘

┌─────────────────────────┐
│  department_kpis        │
├─────────────────────────┤
│ PK id (auto)            │
│    evaluation_year      │ (평가년도)
│    department           │ (학과)
│    employment_rate      │ (졸업생 취업률)
│    tech_transfer_income │ (기술이전 수입액)
│    created_at           │
│    updated_at           │
└─────────────────────────┘
│ UNIQUE(evaluation_year, department) │
```

**테이블 간 관계:**
- MVP에서는 명시적 외래키 없음 (복잡도 회피)
- 학과(department) 컬럼으로 암묵적 연결
- 추후 필요 시 `departments` 마스터 테이블 추가 고려

---

## 3. 테이블 상세 명세

### 3.1 research_projects (연구비 집행 데이터)

**용도:** 연구비 집행 추이 시각화 (Line Chart + Metric Card)

| 컬럼명 | 데이터 타입 | Null | 기본값 | 설명 |
|--------|------------|------|--------|------|
| execution_id | VARCHAR(100) | NOT NULL | - | 집행ID (Primary Key) |
| department | VARCHAR(100) | NOT NULL | - | 소속학과 (필터링 기준) |
| total_budget | BIGINT | NOT NULL | - | 총연구비 (원 단위) |
| execution_date | DATE | NOT NULL | - | 집행일자 (시계열 분석) |
| execution_amount | BIGINT | NOT NULL | - | 집행금액 (원 단위) |
| created_at | TIMESTAMP | NOT NULL | CURRENT_TIMESTAMP | 레코드 생성 시각 |
| updated_at | TIMESTAMP | NOT NULL | CURRENT_TIMESTAMP | 레코드 수정 시각 |

**비즈니스 로직 검증 (Pandas 레이어):**
- `execution_amount <= total_budget` (집행금액은 총연구비 이하)
- `execution_date <= CURRENT_DATE` (미래 날짜 불허)
- `execution_amount >= 0` (음수 불허)
- `total_budget >= 0` (음수 불허)

**집계 쿼리 예시:**
```sql
-- 현재 연구비 잔액 계산
SELECT
    SUM(total_budget) - SUM(execution_amount) AS current_balance
FROM research_projects;

-- 월별 집행 추이
SELECT
    DATE_TRUNC('month', execution_date) AS month,
    SUM(execution_amount) AS monthly_execution
FROM research_projects
GROUP BY month
ORDER BY month;

-- 학과별 연구비 현황
SELECT
    department,
    SUM(total_budget) AS total,
    SUM(execution_amount) AS executed,
    SUM(total_budget) - SUM(execution_amount) AS balance
FROM research_projects
GROUP BY department;
```

---

### 3.2 students (학생 명단)

**용도:** 학과별 학생 현황 시각화 (Stacked Bar Chart)

| 컬럼명 | 데이터 타입 | Null | 기본값 | 설명 |
|--------|------------|------|--------|------|
| student_id | VARCHAR(50) | NOT NULL | - | 학번 (Primary Key) |
| department | VARCHAR(100) | NOT NULL | - | 학과 (필터링 기준) |
| grade | INTEGER | NOT NULL | - | 학년 (1~4) |
| program_type | VARCHAR(20) | NOT NULL | - | 과정구분 (학사/석사/박사) |
| enrollment_status | VARCHAR(20) | NOT NULL | - | 학적상태 (재학/휴학/졸업) |
| created_at | TIMESTAMP | NOT NULL | CURRENT_TIMESTAMP | 레코드 생성 시각 |
| updated_at | TIMESTAMP | NOT NULL | CURRENT_TIMESTAMP | 레코드 수정 시각 |

**비즈니스 로직 검증 (Pandas 레이어):**
- `grade BETWEEN 1 AND 4` (학년 범위 검증)
- `program_type IN ('학사', '석사', '박사')` (허용된 값만)
- `enrollment_status IN ('재학', '휴학', '졸업')` (허용된 값만)

**집계 쿼리 예시:**
```sql
-- 학과별/과정별 학생 수
SELECT
    department,
    program_type,
    COUNT(*) AS student_count
FROM students
WHERE enrollment_status = '재학'
GROUP BY department, program_type;

-- 학과별 학년 분포
SELECT
    department,
    grade,
    COUNT(*) AS count
FROM students
WHERE enrollment_status = '재학'
GROUP BY department, grade
ORDER BY department, grade;

-- 전체 재학생 수
SELECT COUNT(*) FROM students WHERE enrollment_status = '재학';
```

---

### 3.3 publications (논문 목록)

**용도:** 논문 실적 시각화 (Doughnut Chart + Metric Card)

| 컬럼명 | 데이터 타입 | Null | 기본값 | 설명 |
|--------|------------|------|--------|------|
| paper_id | VARCHAR(100) | NOT NULL | - | 논문ID (Primary Key) |
| department | VARCHAR(100) | NOT NULL | - | 학과 (필터링 기준) |
| journal_tier | VARCHAR(50) | NOT NULL | - | 저널등급 (SCIE/KCI/기타) |
| impact_factor | NUMERIC(5,2) | NULL | NULL | Impact Factor (소수점 2자리) |
| created_at | TIMESTAMP | NOT NULL | CURRENT_TIMESTAMP | 레코드 생성 시각 |
| updated_at | TIMESTAMP | NOT NULL | CURRENT_TIMESTAMP | 레코드 수정 시각 |

**비즈니스 로직 검증 (Pandas 레이어):**
- `impact_factor >= 0 OR impact_factor IS NULL` (음수 불허)
- `journal_tier IN ('SCIE', 'KCI', ...)` (정의된 등급만 허용)

**집계 쿼리 예시:**
```sql
-- 저널 등급별 논문 수
SELECT
    journal_tier,
    COUNT(*) AS paper_count,
    ROUND(COUNT(*) * 100.0 / SUM(COUNT(*)) OVER (), 1) AS percentage
FROM publications
GROUP BY journal_tier;

-- 평균 Impact Factor (NULL 제외)
SELECT
    AVG(impact_factor) AS avg_impact_factor,
    COUNT(*) FILTER (WHERE impact_factor IS NOT NULL) AS papers_with_if
FROM publications;

-- 학과별 논문 성과
SELECT
    department,
    COUNT(*) AS total_papers,
    COUNT(*) FILTER (WHERE journal_tier = 'SCIE') AS scie_count,
    AVG(impact_factor) AS avg_if
FROM publications
GROUP BY department;
```

---

### 3.4 department_kpis (학과 KPI)

**용도:** 학과 KPI 추이 시각화 (Dual-axis Line Chart)

| 컬럼명 | 데이터 타입 | Null | 기본값 | 설명 |
|--------|------------|------|--------|------|
| id | SERIAL | NOT NULL | AUTO | 자동 증가 ID (Primary Key) |
| evaluation_year | INTEGER | NOT NULL | - | 평가년도 (YYYY) |
| department | VARCHAR(100) | NOT NULL | - | 학과 |
| employment_rate | NUMERIC(5,2) | NOT NULL | - | 졸업생 취업률 (%) |
| tech_transfer_income | NUMERIC(10,2) | NOT NULL | - | 기술이전 수입액 (억원) |
| created_at | TIMESTAMP | NOT NULL | CURRENT_TIMESTAMP | 레코드 생성 시각 |
| updated_at | TIMESTAMP | NOT NULL | CURRENT_TIMESTAMP | 레코드 수정 시각 |

**제약 조건:**
- UNIQUE(evaluation_year, department): 동일 년도+학과 중복 방지

**비즈니스 로직 검증 (Pandas 레이어):**
- `employment_rate BETWEEN 0 AND 100` (취업률 범위)
- `tech_transfer_income >= 0` (음수 불허)
- `evaluation_year >= 2000 AND evaluation_year <= EXTRACT(YEAR FROM CURRENT_DATE)` (유효 년도)

**집계 쿼리 예시:**
```sql
-- 년도별 평균 취업률 및 기술이전 수입액
SELECT
    evaluation_year,
    AVG(employment_rate) AS avg_employment_rate,
    SUM(tech_transfer_income) AS total_tech_income
FROM department_kpis
GROUP BY evaluation_year
ORDER BY evaluation_year;

-- 학과별 KPI 추이
SELECT
    evaluation_year,
    department,
    employment_rate,
    tech_transfer_income
FROM department_kpis
WHERE department = '컴퓨터공학과'
ORDER BY evaluation_year;

-- 최신 년도 평균 KPI
SELECT
    AVG(employment_rate) AS latest_avg_employment_rate,
    SUM(tech_transfer_income) AS latest_total_income
FROM department_kpis
WHERE evaluation_year = (SELECT MAX(evaluation_year) FROM department_kpis);
```

---

## 4. 인덱스 전략 (MVP)

**MVP 인덱스 (필수만):**

| 테이블 | 인덱스 컬럼 | 목적 |
|--------|------------|------|
| research_projects | department | 학과별 필터링 |
| research_projects | execution_date | 시계열 정렬 및 범위 조회 |
| students | department | 학과별 필터링 |
| students | enrollment_status | 학적상태 필터링 (재학생 조회) |
| publications | department | 학과별 필터링 |
| publications | journal_tier | 저널 등급별 집계 |
| department_kpis | evaluation_year | 년도별 정렬 및 필터 |
| department_kpis | (evaluation_year, department) | UNIQUE 제약 (중복 방지) |

**성능 문제 발생 시 추가 고려:**
- 복합 인덱스 (department + 다른 컬럼)
- Partial 인덱스
- 쿼리 최적화

---

## 5. 데이터 제약 조건

### 5.1 NULL 처리 정책

**NOT NULL 필수 컬럼:**
- 모든 PK 컬럼
- 필터링 및 집계에 사용되는 핵심 컬럼 (department, 날짜, 금액 등)

**NULL 허용 컬럼:**
- `publications.impact_factor`: 모든 논문에 IF가 있는 것은 아님
- 추후 추가되는 선택적 메타데이터

### 5.2 데이터 무결성 제약

**애플리케이션 레벨 (Pandas + DRF):**
- 범위 검증 (학년, 취업률, 금액 등)
- 날짜 유효성 (미래 날짜 불허)
- Enum 값 검증 (학적상태, 과정구분 등)
- 비즈니스 로직 (집행금액 <= 총연구비)

**데이터베이스 레벨 (최소):**
- NOT NULL 제약
- UNIQUE 제약 (PK, department_kpis 복합키)
- CHECK 제약 (MVP에서는 사용 안 함 - 애플리케이션에서 처리)

**이유:** MVP에서는 Pandas에서 정제 완료된 데이터만 DB에 삽입하므로, 복잡한 DB 제약은 오버엔지니어링

---

## 6. 데이터 마이그레이션 전략

### 6.1 초기 마이그레이션

**파일:** `/supabase/migrations/20251102000001_create_initial_schema.sql`

**내용:**
1. 4개 핵심 테이블 생성
2. Primary Key 설정
3. 필수 인덱스 생성 (department)
4. UNIQUE 제약 (department_kpis)
5. created_at/updated_at 자동 업데이트 트리거 설정

### 6.2 업데이트 트리거 설정

PostgreSQL에서 `updated_at` 컬럼 자동 업데이트:

```sql
-- 트리거 함수 생성 (공통)
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- 각 테이블에 트리거 적용
CREATE TRIGGER update_research_projects_updated_at
    BEFORE UPDATE ON research_projects
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();
```

### 6.3 데이터 롤백 전략

**전체 교체 모드의 위험성 완화:**
1. 업로드 전 자동 백업 (선택적)
2. Django ORM 트랜잭션 사용 (ROLLBACK 가능)
3. Supabase 자동 백업 활용

**복구 절차 (추후 구현):**
```sql
-- 테이블 스냅샷 저장 (업로드 전)
CREATE TABLE research_projects_backup_20251102 AS
SELECT * FROM research_projects;

-- 롤백 (필요 시)
TRUNCATE research_projects;
INSERT INTO research_projects SELECT * FROM research_projects_backup_20251102;
```

---

## 7. 확장 고려 사항 (MVP 이후)

### 7.1 추가 테이블 후보

**데이터 변경 이력 추적:**
```sql
CREATE TABLE data_upload_logs (
    id SERIAL PRIMARY KEY,
    job_id UUID NOT NULL,
    data_type VARCHAR(50) NOT NULL,
    file_name VARCHAR(255),
    rows_processed INTEGER,
    rows_inserted INTEGER,
    status VARCHAR(20),
    error_message TEXT,
    uploaded_by VARCHAR(100),
    uploaded_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

**학과 마스터 테이블:**
```sql
CREATE TABLE departments (
    code VARCHAR(50) PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

**사용자 인증 (DB 기반으로 전환 시):**
```sql
CREATE TABLE admin_users (
    id SERIAL PRIMARY KEY,
    username VARCHAR(50) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    role VARCHAR(20) DEFAULT 'admin',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

### 7.2 파티셔닝 전략 (대용량 데이터)

시계열 데이터 파티셔닝 (년도별):

```sql
CREATE TABLE research_projects (
    -- 기존 컬럼들...
) PARTITION BY RANGE (execution_date);

CREATE TABLE research_projects_2024
    PARTITION OF research_projects
    FOR VALUES FROM ('2024-01-01') TO ('2025-01-01');

CREATE TABLE research_projects_2025
    PARTITION OF research_projects
    FOR VALUES FROM ('2025-01-01') TO ('2026-01-01');
```

---

## 문서 변경 이력

| 버전 | 날짜 | 변경 사항 | 작성자 |
|------|------|-----------|--------|
| 1.0 | 2025-11-02 | 초기 데이터베이스 스키마 문서 작성 | Database Writer Agent |
| 2.0 | 2025-11-02 | MVP 최적화 (불필요한 인덱스/섹션 제거) | Claude Code |

---

## 승인 및 검토

**작성자:** Database Writer Agent / Claude Code
**검토자:** CTO
**승인일:** 2025-11-02

본 데이터베이스 스키마는 **MVP 범위**에 맞춘 최소 데이터 모델입니다. 첫 베타테스트에 필요한 핵심 테이블과 인덱스만 포함하며, 성능 문제 발견 시 추가 최적화를 진행합니다.

---

**문서 끝**
</file>

<file path="persona.md">
## 당신의 역할 ## 
- YC배치에 선정된 스타트업의 CTO

## 당신의 목표 ##
- mvp 프로젝트를 오류없이 완성하여 첫번째 프로토타입을 내부 베타테스트한다.

## 당신의 핵심가치 ##
- 신속한 개발 iteration을 위해 간결하면서도 확장성 있는 구조를 추구한다.
- 오버엔지니어링을 피해 당장 해야만 하는 작업만 수행한다.
- 가장 쉬운 인프라를 지향한다.

## 당신이 추구하지 않는 가치 ##
- 매우 높은 트래픽에서도 작동하도록 최적화한다.
- 모든 보안 취약점을 제거한다.
</file>

<file path="prd.md">
## 최종 PRD (Product Requirements Document) - CTO 승인 버전

**문서 작성자:** CTO
**작성일:** 2025년 11월 1일
**대상:** 개발팀 (AI Agent)

---

### 1. 제품 개요 (Product Overview)

| 항목 | 내용 |
| :--- | :--- |
| **프로젝트명** | 대학교 사내 핵심 지표 시각화 대시보드 MVP |
| **제품 목표** | Ecount 추출 데이터(연구비 집행, 논문 실적, 학생 현황, 학과 KPI)를 기반으로 대학 내부 핵심 지표를 **직관적인 웹 차트**로 제공하여 의사결정 속도 및 데이터 활용도를 높인다. **(핵심 가치: 신속성, 간결함)** |
| **핵심 기능** | **4가지 핵심 데이터 파일** (연구비, 학생, 논문, KPI) 업로드 (관리자) $\rightarrow$ **Pandas를 활용한 데이터 파싱/정제** (DRF 백엔드) $\rightarrow$ Supabase 저장 $\rightarrow$ React/Recharts 기반 시각화 대시보드 제공. |
| **성공 기준** | **제공된 4가지 데이터셋**을 기반으로 주요 지표를 오류 없이 시각적으로 정확하게 표현한 첫 번째 프로토타입 완성. |
| **기술 스택** | DRF, Pandas, React, Recharts, Supabase, Railway (확정) |

### 2. Stakeholders

| 역할 | 책임 및 관심사 |
| :--- | :--- |
| **CTO** (발신자) | 신속한 개발 iteration, 간결하고 확장성 있는 구조, MVP 완성 및 배포. **(오버엔지니어링 금지)** |
| **경영진** (수신) | 데이터 기반의 신속하고 정확한 의사결정 지원. |
| **개발 팀 리드** (수신) | 오류 없는 핵심 로직(`DRF-Pandas` 연동) 개발 및 일정 준수. |
| **내부 직원** (최종 사용자) | 편리하고 시인성 높은 웹 기반 데이터 확인. |

### 3. 포함 페이지 (Included Pages - MVP Scope & 명확화)

| 페이지명 | 대상 사용자 | 핵심 기능 및 요구사항 (**구체화**) |
| :--- | :--- | :--- |
| **데이터 업로드 페이지** | 관리자 | 4가지 CSV/엑셀 파일 업로드 및 처리 상태 확인 인터페이스. **(MVP 관리자 접근 통제 방식: 하드코딩 API Key 사용)** |
| **메인 대시보드 페이지** | 전 사용자 | **4대 핵심 지표 시각화 제공.** 기간/학과별 필터링 기능. **(필터링 Scope 제한: 드롭다운 기반의 단일/단순 선택만 허용. 복잡한 다중 선택 또는 커스텀 기간 설정은 MVP 제외)** |

#### 3.1. 4대 핵심 지표 최소 시각화 요구사항 (신속성 확보)

| 지표명 | 필수 차트 종류 (Recharts) |
| :--- | :--- |
| **연구비 집행 추이** | **라인 차트** (Line Chart, 시간에 따른 잔액 추이) 및 **지표 카드** (Metric Card, 현재 잔액) |
| **학과별 학생 현황** | **누적 막대 그래프** (Stacked Bar Chart, 학과별/학년/과정별 학생 수 비교) |
| **논문 실적 (Impact Factor)** | **도넛 차트** (Doughnut Chart, 저널 등급별 논문 비율) 및 **단순 지표 카드** (Aggregated Value) |
| **학과 KPI 추이** | **라인 차트** (Line Chart, 취업률 및 기술이전 수입액 추이) |

### 4. 사용자 여정 (User Journey) 및 시스템 로직 (비동기화 지침 추가)

#### 4.1. 관리자 여정 (Admin / Data Ingestion) - **비동기 처리 지침**

| Target User Segment | 페이지 | 액션 / 시스템 로직 (DRF/Pandas) |
| :--- | :--- | :--- |
| **관리자** | 데이터 업로드 페이지 | 1. 4가지 CSV/엑셀 파일 선택 후 업로드 요청. **(최대 파일 크기: $10MB$ 이하로 제한)**<br>2. **[System Logic: DRF View 호출]** 파일 수신 후 즉시 **백그라운드 처리** 요청 응답. **(Non-Blocking UI를 위해 비동기(Async) 처리 필수. Python `threading` 또는 간단한 백그라운드 태스크 구현 지시)**<br>3. **[System Logic: Pandas/excel\_parser.py]** 백그라운드에서 각 파일을 파싱, 정제, 유효성 검증 수행. **(역할 명확화: 오직 Pandas T/F 로직만 담당)**<br>4. **[System Logic: Supabase/repositories.py]** 정제된 데이터를 DB에 Bulk Insert. **(역할 명확화: DB 접근 로직만 담당)** |
| **관리자** | 메인 대시보드 | 최신 데이터가 반영되었는지 시각적으로 검증. |

#### 4.2. 내부 직원 여정 (End User / Viewer)

| Target User Segment | 페이지 | 액션 / 목적 |
| :--- | :--- | :--- |
| **내부 직원** | 메인 대시보드 | 핵심 지표를 확인하여 의사결정에 활용. |

### 5. IA: 정보 구조 시각화 (Information Architecture)

```mermaid
graph TD
    A[Start: 웹 접근] --> C(메인 대시보드 페이지);
    
    subgraph Core Product
    C
    D(데이터 업로드 페이지)
    end
    
    C -->|데이터 확인/필터| C;
    C -->|관리자 기능 접근| D;
    D -->|파일 업로드/처리| C;
    
    style D fill:#f9f,stroke:#333,stroke-width:2px,color:#333
    
    note for D: 관리자 전용 (하드코딩 API Key 사용)
    note for C: 핵심 지표 차트 시각화
```

### 6. Data Ingestion Specification (명확성 및 구체화)

#### 6.1. 데이터 소스 최소 칼럼 명세 (Pandas 로직 개발 선행 조건)

`excel_parser.py` 개발을 위해 아래 **필수 칼럼**을 기준으로 데이터 파싱/정제 로직을 설계해야 합니다. (제시된 CSV 파일 기반)

| 파일명 | 필수 칼럼 (Pandas Column Name) | 데이터 타입 (DRF/Pandas Type) | 용도 |
| :--- | :--- | :--- | :--- |
| `research_project_data.csv` | `집행ID` | String | PK/고유 식별자 |
| | `소속학과` | String | 학과별 필터링/집계 |
| | `총연구비` | Integer/Float | 잔액 계산을 위한 기준 금액 |
| | `집행일자` | Date/DateTime | 시계열 추이 분석 |
| | `집행금액` | Integer/Float | 잔액 계산 |
| `student_roster.csv` | `학번` | String | PK/고유 식별자 |
| | `학과` | String | 학과별 필터링/집계 |
| | `학년` | Integer | 학년별 학생 수 집계 |
| | `과정구분` | String (학사/석사/박사) | 과정별 학생 수 집계 |
| | `학적상태` | String (재학/휴학/졸업) | 현재 학생 현황 집계 |
| `publication_list.csv` | `논문ID` | String | PK/고유 식별자 |
| | `학과` | String | 학과별 필터링/집계 |
| | `저널등급` | String (SCIE, KCI 등) | 논문 성과 비율 분석 |
| | `Impact Factor` | Float (Nullable) | 핵심 성과 지표 계산 |
| `department_kpi.csv` | `평가년도` | Integer | 시계열 추이 분석 |
| | `학과` | String | 학과별 필터링/집계 |
| | `졸업생 취업률 (%)` | Float | KPI 추이 시각화 |
| | `연간 기술이전 수입액 (억원)` | Float | KPI 추이 시각화 |

#### 6.2. 관리자 접근 통제 (오버엔지니어링 회피)

로그인 기능은 MVP에서 제외되었으므로, **'관리자 전용'** 페이지 및 API 접근은 다음과 같이 **간단하게 구현**합니다.

1.  **백엔드 (DRF):** `POST /upload` API에 **하드코딩된 API Key** (`X-Admin-Key`)를 환경 변수로 설정하고, 이 키가 요청 헤더에 포함되었는지 검증하는 **가벼운 인증 미들웨어**를 사용합니다.
2.  **프런트엔드 (React):** `데이터 업로드 페이지`로의 UI 접근은 `if (process.env.ADMIN_MODE === 'true')`와 같이 간단한 환경 변수나, 상기 **하드코딩된 API Key**를 기반으로 한 단순 문자열 인증 (URL 숨김) 방식으로 제한합니다.

**$\rightarrow$ 별도의 DB 기반 User/Auth 시스템 구현은 MVP에서 절대 금지.**
</file>

<file path="requirements.md">
[프로젝트 개요]
- 대학교 사내 데이터 시각화 대시보드 개발

[프로젝트 배경 및 목표]
- 대학교 내부에서 사용하는 실적, 논문 게재 수, 학생 수, 예산 등 데이터를 보다 직관적으로 파악하고 공유하기 위한 웹 기반 시각화 대시보드 구축을 목표로 합니다.
- 현재 데이터는 이카운트 시스템을 통해 관리되고 있으나, 기본 제공되는 그래프의 시인성이 낮고 활용도가 떨어져 의사결정에 어려움이 있습니다.
- 본 프로젝트는 Ecount에서 추출한 데이터(엑셀)를 기반으로, 사용자가 각 항목의 성과와 추이를 한눈에 파악할 수 있는 맞춤형 그래프 및 차트를 제공하는 페이지를 개발하는 것입니다.
- 개발 방식은 내부 직원들이 웹 페이지에 로그인하여 편리하게 이용할 수 있도록 하는 것을 기본 목표로 하고 있으나, 다양한 개발 방식에 대한 제안을 환영합니다.
- 최종 목표는 데이터를 기반으로 한 정보를 시각적으로 쉽고 편리하게 확인할 수 있도록 하는 것입니다.

[과업 범위]
1. 수행 범위
- 프런트엔드/Client 개발
- 백엔드 개발

2. 상세 기능 요구 사항
- 관리자가 이카운트에서 다운로드한 엑셀 파일을 시스템에 업로드할 수 있는 기능을 제공해야 합니다.
- 업로드된 엑셀 데이터를 시스템이 인식하고, 각 항목에 맞게 파싱하여 데이터베이스에 저장하는 기능을 구현합니다.
- 또는 다운로드된 엑셀 자료를 지정된 파일에 저장 시 프로그램 또는 웹에 자동으로 연동되어 시각화되는 구조를 희망합니다. (협의 및 제안 가능)
- 데이터를 기반으로 주요 성과 지표(실적, 논문, 학생 수, 예산 등)를 시각화하여 보여주는 메인 대시보드 페이지 개발되어야 합니다.
- 각 지표는 사용자가 쉽게 이해할 수 있도록 막대그래프, 라인 차트, 파이 차트 등 형태의 그래프로 표현되어야 합니다.
</file>

<file path="state-management.md">
# React 상태관리 설계 문서 (MVP)

**프로젝트:** 대학교 데이터 시각화 대시보드 MVP
**버전:** 2.0 (간결화 및 수정)
**작성일:** 2025-11-02

---

## 핵심 원칙

- **YAGNI**: 당장 필요하지 않은 상태 제외
- **Separation of Concerns**: 상태 관리와 UI 로직 분리
- **Testability**: 순수 함수 기반 reducer
- **KISS**: Context API + useReducer만 사용 (Redux 배제)

---

## 1. State 구조

### 1.1 Domain State (서버 데이터)

#### 연구비 집행 데이터
```typescript
researchFundingData: {
  current_balance: number
  year_over_year_change: number
  year_over_year_percentage: number
  trend: Array<{
    month: string        // 'YYYY-MM'
    balance: number
    execution: number
  }>
  last_updated: string   // ISO 8601
}
```

#### 학생 현황 데이터
```typescript
studentData: {
  total_students: number
  by_department: Array<{
    department: string
    학사: number
    석사: number
    박사: number
    total: number
  }>
  updated_at: string
}
```

#### 논문 실적 데이터
```typescript
publicationData: {
  total_papers: number
  avg_impact_factor: number | null
  papers_with_if: number
  distribution: Array<{
    journal_tier: 'SCIE' | 'KCI' | '기타'
    count: number
    percentage: number
    avg_if: number | null
  }>
  last_updated: string
}
```

#### 학과 KPI 데이터
```typescript
// NOTE: 필터링된 학과들의 집계 데이터
departmentKpiData: {
  trend: Array<{
    evaluation_year: number
    avg_employment_rate: number     // 필터링된 학과들의 평균 취업률
    total_tech_income: number       // 필터링된 학과들의 기술이전 수입 합계
  }>
  overall_avg_employment_rate: number | null  // 전체 기간 평균 취업률
  overall_total_tech_income: number | null    // 전체 기간 기술이전 수입 합계
  total_count: number                         // 집계에 포함된 데이터 포인트 수
}
```

**중요**: 백엔드는 CSV 컬럼명을 반드시 정규화해야 함 (공백 제거, 특수문자 통일)

---

### 1.2 UI State

#### Loading State
```typescript
loadingState: {
  researchFunding: 'idle' | 'loading' | 'success' | 'error'
  students: 'idle' | 'loading' | 'success' | 'error'
  publications: 'idle' | 'loading' | 'success' | 'error'
  departmentKpi: 'idle' | 'loading' | 'success' | 'error'
  filterOptions: 'idle' | 'loading' | 'success' | 'error'
}
```

#### Error State
```typescript
errorState: {
  researchFunding: Error | null
  students: Error | null
  publications: Error | null
  departmentKpi: Error | null
  filterOptions: Error | null
}
```

---

### 1.3 Filter State

#### 필터 선택 상태
```typescript
filters: {
  department: string      // 기본: 'all'
  year: string            // 기본: 'latest'
  period: string          // 기본: '1y' (옵션: '1y' | '3y')
  studentStatus: string   // 기본: 'all' (옵션: 'all' | '재학' | '졸업' | '휴학')
  journalTier: string     // 기본: 'all' (옵션: 'all' | 'SCIE' | 'KCI')
}
```

#### 필터 옵션 (API에서 동적 로드)
```typescript
filterOptions: {
  departments: string[]   // API에서 로드 (예: ['전체', '컴퓨터공학과', ...])
  years: string[]         // API에서 로드 (예: ['최근 1년', '2024년', ...])
  periods: string[]       // API에서 로드 (예: ['1y', '3y'])
}
```

**고정 상수** (프론트엔드에서 관리):
```typescript
// constants/filters.ts
export const STUDENT_STATUSES = ['all', '재학', '졸업', '휴학'] as const;
export const JOURNAL_TIERS = ['all', 'SCIE', 'KCI'] as const;
```

---

### 1.4 필터 적용 규칙

| 필터 | 연구비 | 학생 | 논문 | KPI |
|------|--------|------|------|-----|
| department | ✓ | ✓ | ✓ | ✓ |
| year | ✓ | ✓ | ✓ | ✓ |
| period | ✓ | ✗ | ✗ | ✓ |
| studentStatus | ✗ | ✓ | ✗ | ✗ |
| journalTier | ✗ | ✗ | ✓ | ✗ |

---

### 1.5 Derived State (계산, Context에 저장 안 함)

```typescript
// 예시: 필터링된 학생 데이터
const filteredStudentData = useMemo(() => {
  if (filters.department === 'all') return studentData.by_department;
  return studentData.by_department.filter(d => d.department === filters.department);
}, [studentData, filters.department]);
```

---

## 2. State Transitions (핵심만)

### 데이터 로딩
| Current | Action | Next | UI |
|---------|--------|------|-----|
| `idle` | `FETCH_REQUEST` | `loading` | 스켈레톤 UI |
| `loading` | `FETCH_SUCCESS` | `success` + data | 차트 표시 |
| `loading` | `FETCH_FAILURE` | `error` + error | 에러 카드 |

### 필터링
| Current | Action | Next | UI |
|---------|--------|------|-----|
| `{department: 'all'}` | `FILTER_UPDATE` | `{department: '컴퓨터공학과'}` | 디바운싱(300ms) 후 API 재호출 |
| `{...}` | `FILTER_RESET` | 기본값 | 전체 데이터 재로드 |

---

## 3. Context 구조

### MVP 범위
- **DashboardContext** (필수): 대시보드 전체 상태 관리
- **UploadContext** (선택): 관리자 업로드 상태 (별도 구현)
- **AuthContext, ThemeContext** (POST-MVP): 제외

### Provider 위치
```
<App>
  <DashboardProvider>
    <DashboardPage />
  </DashboardProvider>
</App>
```

---

## 4. TypeScript 타입 정의

### 4.1 Domain Types
```typescript
// types/domain.ts

export interface ResearchFundingData {
  current_balance: number;
  year_over_year_change: number;
  year_over_year_percentage: number;
  trend: ResearchFundingTrendItem[];
  last_updated: string;
}

export interface ResearchFundingTrendItem {
  month: string;
  balance: number;
  execution: number;
}

export interface StudentData {
  total_students: number;
  by_department: StudentDepartmentItem[];
  updated_at: string;
}

export interface StudentDepartmentItem {
  department: string;
  학사: number;
  석사: number;
  박사: number;
  total: number;
}

export interface PublicationData {
  total_papers: number;
  avg_impact_factor: number | null;
  papers_with_if: number;
  distribution: PublicationDistributionItem[];
  last_updated: string;
}

export interface PublicationDistributionItem {
  journal_tier: 'SCIE' | 'KCI' | '기타';
  count: number;
  percentage: number;
  avg_if: number | null;
}

export interface DepartmentKpiData {
  trend: DepartmentKpiTrendItem[];
  overall_avg_employment_rate: number | null;
  overall_total_tech_income: number | null;
  total_count: number;
}

export interface DepartmentKpiTrendItem {
  evaluation_year: number;
  avg_employment_rate: number;
  total_tech_income: number;
}
```

---

### 4.2 State Types
```typescript
// types/state.ts

export type LoadingStatus = 'idle' | 'loading' | 'success' | 'error';

export interface DashboardState {
  // Domain State
  researchFundingData: ResearchFundingData | null;
  studentData: StudentData | null;
  publicationData: PublicationData | null;
  departmentKpiData: DepartmentKpiData | null;

  // UI State
  loadingState: {
    researchFunding: LoadingStatus;
    students: LoadingStatus;
    publications: LoadingStatus;
    departmentKpi: LoadingStatus;
    filterOptions: LoadingStatus;
  };

  errorState: {
    researchFunding: Error | null;
    students: Error | null;
    publications: Error | null;
    departmentKpi: Error | null;
    filterOptions: Error | null;
  };

  // Filter State
  filters: {
    department: string;
    year: string;
    period: string;
    studentStatus: string;
    journalTier: string;
  };

  filterOptions: {
    departments: string[];
    years: string[];
    periods: string[];
  };
}
```

---

### 4.3 Action Types
```typescript
// types/actions.ts

export type DashboardAction =
  // Data Fetch Actions (각 도메인별 REQUEST/SUCCESS/FAILURE)
  | { type: 'RESEARCH_FUNDING_FETCH_REQUEST' }
  | { type: 'RESEARCH_FUNDING_FETCH_SUCCESS'; payload: ResearchFundingData }
  | { type: 'RESEARCH_FUNDING_FETCH_FAILURE'; payload: Error }

  | { type: 'STUDENT_FETCH_REQUEST' }
  | { type: 'STUDENT_FETCH_SUCCESS'; payload: StudentData }
  | { type: 'STUDENT_FETCH_FAILURE'; payload: Error }

  | { type: 'PUBLICATION_FETCH_REQUEST' }
  | { type: 'PUBLICATION_FETCH_SUCCESS'; payload: PublicationData }
  | { type: 'PUBLICATION_FETCH_FAILURE'; payload: Error }

  | { type: 'DEPARTMENT_KPI_FETCH_REQUEST' }
  | { type: 'DEPARTMENT_KPI_FETCH_SUCCESS'; payload: DepartmentKpiData }
  | { type: 'DEPARTMENT_KPI_FETCH_FAILURE'; payload: Error }

  | { type: 'FILTER_OPTIONS_FETCH_REQUEST' }
  | { type: 'FILTER_OPTIONS_FETCH_SUCCESS'; payload: FilterOptions }
  | { type: 'FILTER_OPTIONS_FETCH_FAILURE'; payload: Error }

  // Filter Actions
  | { type: 'FILTER_UPDATE'; payload: { key: keyof DashboardState['filters']; value: string } }
  | { type: 'FILTER_RESET' }

  // Error Actions
  | { type: 'CLEAR_ERROR'; payload: { key: keyof DashboardState['errorState'] } };

export interface FilterOptions {
  departments: string[];
  years: string[];
  periods: string[];
}
```

---

### 4.4 Context Value Type
```typescript
// types/context.ts

export interface DashboardContextValue {
  state: DashboardState;

  // Data Fetch Actions
  fetchResearchFunding: (filters: DashboardState['filters']) => Promise<void>;
  fetchStudents: (filters: DashboardState['filters']) => Promise<void>;
  fetchPublications: (filters: DashboardState['filters']) => Promise<void>;
  fetchDepartmentKpi: (filters: DashboardState['filters']) => Promise<void>;
  fetchFilterOptions: () => Promise<void>;

  // Filter Actions
  updateFilter: (key: keyof DashboardState['filters'], value: string) => void;
  resetFilters: () => void;

  // Error Actions
  clearError: (key: keyof DashboardState['errorState']) => void;
}
```

---

## 5. Initial State

```typescript
// contexts/DashboardContext.tsx

const initialState: DashboardState = {
  // Domain State
  researchFundingData: null,
  studentData: null,
  publicationData: null,
  departmentKpiData: null,

  // Loading State
  loadingState: {
    researchFunding: 'idle',
    students: 'idle',
    publications: 'idle',
    departmentKpi: 'idle',
    filterOptions: 'idle',
  },

  // Error State
  errorState: {
    researchFunding: null,
    students: null,
    publications: null,
    departmentKpi: null,
    filterOptions: null,
  },

  // Filters
  filters: {
    department: 'all',
    year: 'latest',
    period: '1y',
    studentStatus: 'all',
    journalTier: 'all',
  },

  // Filter Options (빈 배열로 초기화, API에서 로드)
  filterOptions: {
    departments: [],
    years: [],
    periods: [],
  },
};
```

---

## 6. 파일 구조

```
frontend/src/
├── contexts/
│   └── DashboardContext.tsx       # Context + Provider + useDashboard
├── reducers/
│   └── dashboardReducer.ts        # 순수 함수 Reducer
├── types/
│   ├── domain.ts
│   ├── state.ts
│   ├── actions.ts
│   └── context.ts
├── hooks/
│   └── useDashboardData.ts        # API 호출 로직
├── api/
│   └── dataApiClient.ts           # Axios 인스턴스
├── constants/
│   └── filters.ts                 # STUDENT_STATUSES, JOURNAL_TIERS
├── pages/
│   └── Dashboard.tsx
└── components/dashboard/
    ├── FilterPanel.tsx
    ├── ResearchFundingChart.tsx
    ├── StudentChart.tsx
    ├── PublicationChart.tsx
    └── DepartmentKpiChart.tsx
```

---

## 7. Reducer 함수 시그니처

```typescript
// reducers/dashboardReducer.ts

export function dashboardReducer(
  state: DashboardState,
  action: DashboardAction
): DashboardState {
  switch (action.type) {
    case 'RESEARCH_FUNDING_FETCH_REQUEST':
      return {
        ...state,
        loadingState: { ...state.loadingState, researchFunding: 'loading' },
        errorState: { ...state.errorState, researchFunding: null },
      };

    case 'RESEARCH_FUNDING_FETCH_SUCCESS':
      return {
        ...state,
        researchFundingData: action.payload,
        loadingState: { ...state.loadingState, researchFunding: 'success' },
      };

    case 'RESEARCH_FUNDING_FETCH_FAILURE':
      return {
        ...state,
        loadingState: { ...state.loadingState, researchFunding: 'error' },
        errorState: { ...state.errorState, researchFunding: action.payload },
      };

    case 'FILTER_UPDATE':
      return {
        ...state,
        filters: { ...state.filters, [action.payload.key]: action.payload.value },
      };

    case 'FILTER_RESET':
      return {
        ...state,
        filters: initialState.filters,
      };

    // ... 나머지 Action 처리

    default:
      return state;
  }
}
```

---

## 8. 테스트 전략 (TDD)

### Reducer 단위 테스트 (70%)
```typescript
describe('dashboardReducer', () => {
  it('FETCH_REQUEST sets loading', () => {
    const state = { ...initialState };
    const action = { type: 'RESEARCH_FUNDING_FETCH_REQUEST' };
    const newState = dashboardReducer(state, action);

    expect(newState.loadingState.researchFunding).toBe('loading');
    expect(newState.errorState.researchFunding).toBeNull();
  });

  it('FILTER_UPDATE updates specific filter only', () => {
    const state = { ...initialState };
    const action = {
      type: 'FILTER_UPDATE',
      payload: { key: 'department', value: '컴퓨터공학과' }
    };
    const newState = dashboardReducer(state, action);

    expect(newState.filters.department).toBe('컴퓨터공학과');
    expect(newState.filters.year).toBe('latest'); // 다른 필터 유지
  });
});
```

### Context Integration 테스트 (20%)
```typescript
it('provides context values', () => {
  const TestComponent = () => {
    const { state } = useDashboard();
    return <div>{state.loadingState.researchFunding}</div>;
  };

  const { getByText } = render(
    <DashboardProvider><TestComponent /></DashboardProvider>
  );

  expect(getByText('idle')).toBeInTheDocument();
});
```

### E2E 테스트 (10%)
Playwright로 전체 플로우 검증

---

## 9. 성능 최적화

### Context Value Memoization
```typescript
const contextValue = useMemo(
  () => ({ state, fetchResearchFunding, fetchStudents, /* ... */ }),
  [state]
);
```

### Derived State Memoization
```typescript
const filteredData = useMemo(
  () => data.filter(/* ... */),
  [data, filters]
);
```

### Chart Memoization
```typescript
export const ResearchFundingChart = React.memo(({ data, loading }) => {
  // ...
});
```

### Debouncing (300ms)
```typescript
const handleFilterChange = useCallback((key, value) => {
  dispatch({ type: 'FILTER_UPDATE', payload: { key, value } });

  clearTimeout(debounceTimerRef.current);
  debounceTimerRef.current = setTimeout(() => {
    fetchAllDashboardData(filters);
  }, 300);
}, [filters]);
```

---

## 10. 보안

- React 기본 XSS 이스케이프 활용
- `dangerouslySetInnerHTML` 사용 금지
- API Key는 환경 변수로 관리 (Context에 저장 금지)
- TypeScript strict mode 사용
- Redux DevTools는 개발 환경에서만 활성화

---

## 변경 이력

| 버전 | 날짜 | 변경 사항 |
|------|------|-----------|
| 1.0 | 2025-11-02 | 초기 문서 작성 |
| 2.0 | 2025-11-02 | P0/P1 수정사항 반영, 간결화 |

**주요 수정:**
- DepartmentKpiData 구조 명확화 (`overall_total_tech_income` 필드 추가)
- FilterOptions에서 고정값 분리 (STUDENT_STATUSES, JOURNAL_TIERS)
- Period 필터 옵션 명시
- 필터 적용 규칙 테이블 추가
- CSV 컬럼명 정규화 주석 추가
- 불필요한 설명 및 중복 제거

---

**문서 끝**
</file>

<file path="techstack.md">
# YC 스타트업 CTO 보고서

## MVP 프로젝트 최종 기술 스택 확정 및 구현 전략 보고서

**수신:** 경영진, 개발 팀 리드
**발신:** CTO
**날짜:** 2025년 11월 1일
**제목:** '대학교 사내 데이터 시각화 대시보드' MVP 기술 스택 (DRF, Pandas, React, Supabase, Railway) 최종 승인 및 구현 지침

---

### Executive Summary (최종 결정)

제안된 기술 스택 (**DRF, Pandas, React, Recharts, Supabase, Railway**)은 '대학교 사내 데이터 시각화 대시보드'라는 프로젝트 개요와 'Ecount 엑셀 데이터 파싱 및 시각화'라는 상세 요구사항을 **가장 빠르고 효율적으로 구현**할 수 있는 최적의 조합으로 최종 확정되었습니다.

**핵심 가치**인 '신속한 개발 iteration', '간결하고 확장성 있는 구조', '오버엔지니어링 회피', '가장 쉬운 인프라'를 완벽히 충족하며, 즉시 프로토타입 개발에 착수할 것을 지시합니다.

---

### 1. 최종 확정 기술 스택

| 분류 | 기술 | 역할 | 비고 |
| :--- | :--- | :--- | :--- |
| **백엔드 (API)** | **Django Rest Framework (DRF)** | API 서버 구축 및 데이터 검증/입력 로직 담당 | 신속한 개발(DX)과 안정성 확보 |
| **데이터 처리** | **Pandas** | 엑셀 데이터 파싱, 정제, 유효성 검사 | **MVP 성공의 핵심 컴포넌트** |
| **프런트엔드** | **React** | 사용자 인터페이스 구축 및 상태 관리 | 거대한 생태계를 통한 개발 속도 최적화 |
| **차트/시각화** | **Recharts** | 데이터 시각화 구현 | 선언적인 방식의 차트 구현 |
| **데이터베이스** | **Supabase (PostgreSQL)** | 관리 용이성을 갖춘 안정적인 데이터베이스 | |
| **배포/인프라** | **Railway** | 자동화된 CI/CD 및 PaaS | '가장 쉬운 인프라' 실현 |

---

### 2. 핵심 성공 요소: Pandas와 DRF 결합 재확인 (MVP 최적화)

**결론:** **DRF와 Pandas의 결합은 MVP 단계에서 오류 없는 구현을 위한 최적의 선택임을 확정합니다.**

Ecount에서 추출된 엑셀 파일은 비정형적이고 정제가 필요한 경우가 많습니다.

*   **Pandas의 역할 극대화:** Pandas는 복잡한 헤더 처리, 결측값(NaN) 제거, 데이터 타입 변환 등 비정형 데이터를 정형 데이터로 변환하는 데 필요한 모든 기능을 **단 몇 줄의 코드**로 제공하여 개발 시간을 획기적으로 단축시킵니다.
*   **간결한 백엔드 구조:** 엑셀 파일 업로드(DRF) $\rightarrow$ 메모리 내에서 Pandas 파싱/검증 $\rightarrow$ Supabase Bulk Insert 로직은 백엔드에 데이터 처리 로직을 집중시켜 **간결하고 확장성 있는 구조**를 유지합니다. 복잡한 외부 ETL 파이프라인 구축은 **오버엔지니어링**으로 판단하여 회피합니다.

### 3. 전략적 제언: 차트 컴포넌트 유연성 확보

Recharts는 훌륭한 라이브러리이나, **'신속한 개발 iteration'** 목표를 극대화하기 위해 프런트엔드 팀은 UI/UX 구축 단계에서 다음 대안을 전략적으로 검토해야 합니다.

*   **승인 기술:** **Recharts** (기본 승인)
*   **전략적 대안:** **Tremor.so** 또는 **Mantine Data Components**
*   **이유:** 이들 라이브러리는 **차트 컴포넌트뿐만 아니라 전체 대시보드 레이아웃, KPI 카드 등의 UI 컴포넌트까지 고수준(High-level)으로 제공**합니다. 만약 순수 차트 외의 UI 구축에 시간이 소요된다면, 이 대안으로 전환하여 **대시보드 UI 완성 시간을 획기적으로 단축**할 수 있습니다.

**지침:** 초기 개발은 Recharts로 시작하되, 프로토타입 1차 스프린트 종료 시 UI 개발 속도를 검토하여 CTO의 승인 하에 전환할 수 있는 유연성을 확보합니다.

---

### 4. CTO 지침 및 다음 단계

1.  **즉시 착수:** 확정된 스택을 기반으로 **프로토타입 개발에 즉시 착수**합니다.
2.  **집중 영역:** 백엔드 팀은 **DRF-Pandas 기반의 엑셀 데이터 파싱/저장 로직의 안정성 확보**에 최우선 순위를 둡니다.
3.  **인프라 최소화:** Railway와 Supabase 설정에 **1일 이상을 소요하지 않습니다.** 인프라는 '가장 쉬운' 방법으로 설정하고, 코어 비즈니스 로직에 집중해야 합니다.

**이 스택은 우리 핵심 가치에 완벽히 부합하며, MVP를 가장 빠르게 완성하여 시장에 검증받을 수 있는 기반이 될 것입니다. Good luck.**
</file>

<file path="userflow.md">
# 유저플로우 설계 문서 (MVP)

**프로젝트:** 대학교 사내 데이터 시각화 대시보드 MVP
**작성일:** 2025년 11월 2일
**버전:** 2.0 (MVP 최적화)
**작성자:** Userflow Writer Agent

---

## 문서 개요

본 문서는 **MVP 범위**에 맞춘 핵심 유저플로우만 정의합니다. 각 플로우는 **입력(사용자 액션) → 처리(시스템 로직) → 출력(피드백/결과)** 구조로 작성되었으며, 첫 베타테스트에 필요한 최소한의 기능에 집중합니다.

**MVP 핵심 원칙 (CTO Mandate):**
- 빠른 개발 iteration을 위한 간결한 구조
- 오버엔지니어링 배제 - 당장 필요한 기능만 구현
- 가장 단순한 인프라 접근 방식
- 비동기 백그라운드 처리로 Non-blocking UI 확보

**우선순위 태그:**
- `[P0-MVP]`: 첫 베타테스트 필수
- `[P1-MVP]`: 중요하지만 간소화 가능
- `[POST-MVP]`: 추후 고도화 단계에서 구현

---

## 목차

1. [사용자 역할 정의](#1-사용자-역할-정의) `[P0-MVP]`
2. [관리자 데이터 업로드 플로우](#2-관리자-데이터-업로드-플로우) `[P0-MVP]`
3. [메인 대시보드 조회 플로우](#3-메인-대시보드-조회-플로우) `[P0-MVP]`
4. [대시보드 필터링 플로우](#4-대시보드-필터링-플로우) `[P0-MVP]`
5. [차트 인터랙션 플로우](#5-차트-인터랙션-플로우) `[P1-MVP]` (기본 Tooltip만)
6. [데이터 갱신 플로우](#6-데이터-갱신-플로우) `[P1-MVP]` (수동만)
7. [에러 처리 플로우](#7-에러-처리-플로우) `[P0-MVP]` (핵심만)
8. [필수 엣지케이스](#8-필수-엣지케이스) `[P1-MVP]` (4개만)

---

## 1. 사용자 역할 정의

### 1.1 관리자 (Admin User)

**특성:**
- 데이터 업로드 페이지 접근 권한 보유 (하드코딩된 API Key 또는 환경 변수 기반)
- Ecount 시스템에서 추출한 4가지 CSV/Excel 파일 업로드 책임
- 업로드 후 데이터 정확성 검증 수행
- 기술적 숙련도: 중급 (파일 형식 이해 및 기본 트러블슈팅 가능)

**주요 목표:**
- 데이터 파일을 신속하고 효율적으로 업로드
- 데이터 수집(Ingestion) 성공 여부 확인
- 업데이트된 데이터가 대시보드에 정확히 반영되었는지 검증

### 1.2 내부 직원 (Internal Staff / Viewer)

**특성:**
- 모든 대학 직원에게 대시보드 조회 권한 부여
- 업로드 권한 없음 (읽기 전용)
- 주로 시각화된 데이터를 기반으로 의사결정 수행

**주요 목표:**
- 핵심 성과 지표를 한눈에 빠르게 파악
- 학과, 기간 등 다양한 기준으로 데이터 필터링
- 직관적인 차트를 통해 추세와 패턴 이해

---

## 2. 관리자 데이터 업로드 플로우

### 플로우 개요
관리자가 Ecount 시스템에서 추출한 최신 데이터를 시스템에 업로드하여 대시보드에 반영하는 전체 과정

### 진입점
- `/admin/upload` URL 직접 입력 (URL 난독화 전략)
- 메인 대시보드에서 "데이터 업로드" 버튼 클릭 (관리자 모드 활성화 시)

---

### 2.1 관리자 페이지 접근 및 인증

#### 입력 (User Input)
- 브라우저에서 데이터 업로드 페이지 URL 접근
- (선택적) UI에서 하드코딩된 API Key 입력 프롬프트 응답

#### 처리 (System Processing)

**단계 1: 프런트엔드 접근 제어**
- React 앱에서 `process.env.ADMIN_MODE === 'true'` 검증 또는 간단한 문자열 토큰 확인
- 권한 없음 감지 시 메인 대시보드로 자동 리디렉션

**단계 2: 페이지 렌더링**
- 권한 확인 성공 시 데이터 업로드 인터페이스 렌더링
- 4가지 파일 타입별 업로드 영역 표시:
  - 연구비 집행 데이터 (`research_project_data.csv`)
  - 학생 명단 (`student_roster.csv`)
  - 논문 목록 (`publication_list.csv`)
  - 학과 KPI (`department_kpi.csv`)
- 각 영역에 드래그앤드롭 기능 또는 파일 선택 버튼 제공

#### 출력 (User Feedback)
- **성공 시:**
  - 파일 업로드 UI 표시
  - 각 파일 타입별 업로드 상태 표시 영역
  - 지원 파일 형식 및 최대 크기 안내 메시지 표시

- **실패 시 (권한 없음):**
  - 메인 대시보드로 자동 리디렉션
  - 토스트 알림: "관리자 권한이 필요합니다. 접근이 거부되었습니다."
  - 브라우저 콘솔에 접근 거부 로그 기록

#### 엣지케이스
- **환경 변수 미설정:** 모든 사용자가 업로드 페이지 접근 불가 → 시스템 관리자에게 설정 요청 안내 표시
- **잘못된 URL 경로:** 404 페이지 표시 또는 메인 대시보드로 리디렉션
- **API Key 만료/변경:** "인증 정보가 유효하지 않습니다. 관리자에게 문의하세요." 에러 메시지 표시

---

### 2.2 파일 선택 및 클라이언트 검증

#### 입력 (User Input)
- 각 데이터 타입에 해당하는 CSV/Excel 파일 선택
- 파일 선택 방식:
  - 파일 선택 다이얼로그를 통한 선택
  - 드래그앤드롭으로 업로드 영역에 파일 투입

#### 처리 (System Processing)

**단계 1: 프런트엔드 파일 검증**
- 파일 확장자 검증: `.csv`, `.xlsx`, `.xls`만 허용
- 파일 크기 검증: 최대 10MB 제한
- 파일명 패턴 검증 (선택적): 예상되는 파일명과 매칭 여부 확인

**단계 2: UI 상태 업데이트**
- 선택된 파일 정보 표시:
  - 파일명
  - 파일 크기 (MB 단위)
  - 파일 타입 (CSV/Excel)
- 업로드 버튼 활성화 조건 확인:
  - 최소 1개 이상의 파일이 선택됨
  - 선택된 모든 파일이 검증 통과

**단계 3: `[POST-MVP]` 파일 프리뷰**
- MVP에서는 생략

#### 출력 (User Feedback)
- **성공 시:**
  - 선택된 파일 목록 카드 형식으로 표시
  - 각 파일 옆에 "준비됨" 상태 아이콘
  - "업로드 시작" 버튼 활성화 (파란색 강조)

- **실패 시:**
  - **확장자 불일치:** "지원되지 않는 파일 형식입니다. CSV 또는 Excel 파일(.csv, .xlsx, .xls)을 선택하세요." 경고 메시지
  - **크기 초과:** "파일 크기가 10MB를 초과합니다. (현재: XX.X MB) 파일을 분할하거나 데이터를 줄여주세요." 경고 메시지
  - **파일 읽기 오류:** "파일을 읽을 수 없습니다. 파일이 손상되었거나 접근 권한이 없을 수 있습니다." 경고 메시지

#### 엣지케이스
- **동일 파일 중복 선택:** 최신 선택 파일로 자동 교체, "기존 파일이 교체됩니다" 경고 표시
- **비표준 인코딩 파일 (EUC-KR, CP949 등):** UTF-8, EUC-KR, CP949 순서로 자동 감지 및 변환 시도
- **빈 파일 (0 byte):** 선택 시점에서 감지 → "빈 파일입니다. 데이터가 포함된 파일을 선택하세요." 경고
- **숨겨진 행/컬럼이 있는 Excel 파일:** Pandas에서 자동으로 숨겨진 데이터 포함하여 파싱

---

### 2.3 파일 업로드 요청 및 백그라운드 처리 시작

#### 입력 (User Input)
- "업로드 시작" 버튼 클릭
- 선택된 파일 1~4개 (각 데이터 타입별)

#### 처리 (System Processing)

**단계 1: 프런트엔드 요청 준비**
- FormData 객체 생성
- 각 파일 및 메타데이터 추가:
  - 파일 바이너리 데이터
  - 파일 타입 정보 (research_funding, students, publications, kpi)
  - 업로드 타임스탬프
- 요청 헤더에 하드코딩된 API Key 포함: `X-Admin-Key: <키값>`
- 업로드 진행 상태 UI 표시:
  - 각 파일별 프로그레스 바 (0% 상태)
  - "업로드 중..." 로딩 스피너
  - 업로드 버튼 비활성화

**단계 2: HTTP 요청 전송**
- `POST /api/upload/` 엔드포인트 호출
- Content-Type: `multipart/form-data`
- 타임아웃 설정: 60초 (대용량 파일 대응)

**단계 3: DRF View 요청 수신 및 검증**
- API Key 검증 (DRF 미들웨어 또는 View 레벨)
- Request Serializer를 통한 파일 형식 재검증
- 파일을 임시 저장 경로에 저장 (예: `/tmp/upload_{job_id}/`)

**단계 4: 비동기 백그라운드 작업 등록**
- Python `threading.Thread` 또는 간단한 백그라운드 태스크 큐에 파싱 작업 등록
- 고유한 작업 ID (`job_id`) 생성 (UUID 형식)
- 작업 상태 초기화: `{"status": "processing", "progress": 0}`
- 즉시 HTTP 202 Accepted 응답 반환 (Non-blocking)

#### 출력 (User Feedback)
- **성공 시 (즉시 응답):**
  - HTTP 202 Accepted
  - 응답 본문:
    ```json
    {
      "status": "processing",
      "job_id": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
      "message": "파일 업로드가 시작되었습니다. 처리가 완료되면 알려드리겠습니다.",
      "estimated_time": "약 30초 소요 예상"
    }
    ```
  - UI 변경:
    - "업로드 중... 데이터를 처리하고 있습니다." 메시지 표시
    - 각 파일별 프로그레스 바 애니메이션 시작
    - 작업 상태 폴링 시작 (3초 간격)

- **실패 시:**
  - **API Key 불일치 (HTTP 403 Forbidden):**
    - 에러 모달: "관리자 권한이 없습니다. 접근이 거부되었습니다."
    - 메인 대시보드로 리디렉션 옵션 제공

  - **파일 검증 실패 (HTTP 400 Bad Request):**
    - 응답 본문 예시:
      ```json
      {
        "error": "validation_error",
        "details": {
          "file": "publication_list.csv",
          "issue": "필수 컬럼 'Impact Factor'가 누락되었습니다.",
          "required_columns": ["논문ID", "학과", "저널등급", "Impact Factor"]
        }
      }
      ```
    - UI: 구체적인 에러 메시지 표시, 해당 파일 하이라이트

  - **서버 에러 (HTTP 500 Internal Server Error):**
    - 에러 토스트: "서버 오류가 발생했습니다. 잠시 후 다시 시도하세요."
    - "재시도" 버튼 표시

#### 엣지케이스
- **네트워크 단절:** 요청 타임아웃 → "네트워크 연결을 확인하세요" 메시지, 자동 재시도 (최대 3회)
- **동시 다중 업로드:** 여러 관리자가 동시에 업로드 시 작업 큐에서 순차 처리 또는 병렬 처리 (서버 리소스에 따라)
- **파일 전송 중 사용자 이탈:** 브라우저 새로고침 또는 페이지 이탈 시 업로드 취소 확인 모달 표시, 백그라운드 처리는 서버에서 계속 진행
- **세션 만료:** 업로드 중 세션 만료 시에도 백그라운드 처리는 계속, `job_id`로 나중에 상태 조회 가능

---

### 2.4 백그라운드 데이터 파싱 (Pandas 로직)

#### 시스템 자동 처리 (사용자 비가시 영역)

#### 처리 (System Processing)

**단계 1: 파일 타입별 파서 선택**
- `excel_parser.py` 모듈의 파일 타입별 전용 파싱 함수 호출:
  - `parse_research_project_data(file_path)` → 연구비 집행 데이터
  - `parse_student_roster(file_path)` → 학생 명단
  - `parse_publication_list(file_path)` → 논문 목록
  - `parse_department_kpi(file_path)` → 학과 KPI

**단계 2: Pandas DataFrame 로드 및 기본 파싱**
- CSV/Excel 파일을 Pandas DataFrame으로 로드:
  - `pd.read_csv()` 또는 `pd.read_excel()` 사용
  - 인코딩 자동 감지 (UTF-8 → EUC-KR → CP949 순서로 시도)
- 헤더 행 자동 감지 및 컬럼명 정규화 (공백 제거, 일관성 확보)

**단계 3: 필수 컬럼 존재 여부 검증**
- PRD 명세에 정의된 필수 컬럼 리스트와 비교
- 예시 (연구비 집행 데이터):
  - 필수: `['집행ID', '소속학과', '총연구비', '집행일자', '집행금액']`
- 누락된 컬럼 발견 시 즉시 예외 발생 → 작업 상태 "failed" 업데이트

**단계 4: 데이터 타입 변환 및 검증**
- 날짜 컬럼 → `datetime` 객체로 변환:
  - `pd.to_datetime(df['집행일자'], errors='coerce')`
  - 변환 실패 시 NaT(Not a Time) 발생 → 해당 행 에러 로그 기록
- 금액/숫자 컬럼 → `int` 또는 `float` 변환:
  - 쉼표 제거: `df['총연구비'].str.replace(',', '')`
  - `pd.to_numeric(df['총연구비'], errors='coerce')`
- 문자열 컬럼 → 양쪽 공백 제거:
  - `df['소속학과'] = df['소속학과'].str.strip()`

**단계 5: 데이터 정제 (Cleaning)**
- **결측값(NaN) 처리:**
  - 필수 컬럼에 NaN 존재 시 해당 행 제외 + 경고 로그 기록
  - 선택적 컬럼(예: Impact Factor)의 NaN은 허용 (NULL로 저장)

- **중복 데이터 감지 및 처리:**
  - PK 컬럼 기준 중복 검사 (예: 학번, 논문ID, 집행ID)
  - 중복 발견 시 전략:
    - MVP: 마지막 행 유지 (`df.drop_duplicates(subset=['PK컬럼'], keep='last')`)
    - 경고 로그 기록: "중복 데이터 X건 발견, 최신 데이터로 유지"

- **데이터 범위 검증:**
  - 학년: 1~4 (학사) 또는 1~2 (석사) 또는 1~4 (박사)
  - 날짜: 미래 날짜 불허 (현재 날짜 이전만 허용)
  - 금액: 음수 불허 (0 이상)
  - 비율 (취업률): 0~100% 범위
- 범위 위반 데이터 발견 시:
  - 해당 행 제외 + 상세 에러 로그 (행 번호, 컬럼, 값 포함)

**단계 6: 비즈니스 로직 검증**
- 연구비 집행 데이터: `집행금액 <= 총연구비` 검증
- 학생 명단: `학적상태`가 허용된 값 중 하나인지 검증 (재학/휴학/졸업)
- 논문 목록: `저널등급`이 정의된 등급 목록에 포함되는지 검증 (SCIE/KCI/...)

**단계 7: 최종 DataFrame 반환**
- 정제 완료된 DataFrame 반환
- 파싱 통계 정보 생성:
  - 총 행 수
  - 유효 행 수
  - 제외된 행 수
  - 경고/에러 로그

#### 출력 (Internal)
- **성공:** 정제된 DataFrame 객체 + 파싱 통계
- **실패:** 예외 발생 (`ValidationError`, `ParsingError` 등) + 상세 에러 메시지

#### 엣지케이스
- **파싱 중 메모리 부족:** 파일을 청크(chunk) 단위로 분할 처리 (예: 1000행씩)
- **인코딩 감지 실패:** 모든 인코딩 시도 실패 시 "파일 인코딩을 감지할 수 없습니다" 에러 반환
- **완전히 비어있는 DataFrame (헤더만 존재):** "데이터 행이 없습니다" 에러 반환
- **극단적으로 큰 파일 (10MB 이하지만 수십만 행):** 타임아웃 방지를 위해 청크 처리 또는 샘플링 (MVP 이후 고려)

---

### 2.5 데이터베이스 저장 (Repositories 레이어)

#### 처리 (System Processing)

**단계 1: Repository 함수 호출**
- `repositories.py`의 Bulk Insert 함수 호출
- 예시: `save_research_funding_data(dataframe, replace=True)`

**단계 2: 데이터 저장 전략 (MVP: 전체 교체만)**
- 기존 동일 타입 데이터 전체 삭제 (`DELETE FROM research_projects`)
- 신규 데이터 Bulk Insert
- `[POST-MVP]` 증분 업데이트 모드 (UPSERT)

**단계 3: 트랜잭션 처리**
- Django ORM 트랜잭션 시작:
  ```python
  from django.db import transaction

  with transaction.atomic():
      # 기존 데이터 삭제
      ResearchProject.objects.all().delete()
      # Bulk Insert
      ResearchProject.objects.bulk_create([
          ResearchProject(**row) for row in dataframe.to_dict('records')
      ])
  ```
- **원자성 보장:** 모든 삽입 성공 시 COMMIT, 하나라도 실패 시 ROLLBACK

**단계 4: 저장 결과 검증**
- 삽입된 행 수 확인
- 예상 행 수와 실제 삽입 행 수 비교
- 불일치 시 경고 로그 기록

**단계 5: 작업 상태 업데이트**
- 작업 ID에 대한 상태를 `"completed"` 또는 `"failed"`로 업데이트
- 성공 시 메타데이터 저장:
  - 처리된 행 수
  - 삽입된 행 수
  - 처리 소요 시간
- 실패 시 에러 정보 저장:
  - 에러 타입
  - 에러 메시지
  - 스택 트레이스 (관리자용)

#### 출력 (Internal)
- **성공:** 데이터베이스에 정제된 데이터 저장 완료, 작업 상태 `"completed"`
- **실패:** 트랜잭션 롤백, 작업 상태 `"failed"`, 에러 로그 저장

#### 엣지케이스
- **DB 연결 실패:** 재시도 로직 (지수 백오프, 최대 3회), 모두 실패 시 에러 상태로 표시
- **DB 저장 공간 부족:** "데이터베이스 용량이 부족합니다" 구체적 에러 메시지 반환
- **중복 PK 충돌 (전체 교체 모드 아닐 경우):** 기존 레코드 UPDATE 또는 건너뛰기 (로그 기록)
- **외래 키 제약 위반:** 관련 데이터 누락 시 에러 메시지와 함께 실패 처리
- **트랜잭션 타임아웃:** 대용량 데이터 삽입 시 타임아웃 발생 가능 → 배치 크기 조정 (1000건씩 분할 삽입)

---

### 2.6 업로드 상태 확인 및 사용자 피드백

#### 입력 (User Input)
- 자동 폴링: 프런트엔드에서 3초 간격으로 작업 상태 조회 API 호출
- 수동 확인: "상태 새로고침" 버튼 클릭 (선택적)

#### 처리 (System Processing)

**단계 1: 상태 조회 API 호출**
- `GET /api/upload/status/<job_id>/` 엔드포인트 호출
- 백엔드에서 작업 ID에 해당하는 현재 상태 조회

**단계 2: 상태 응답 구조**
```json
{
  "job_id": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
  "status": "completed",  // 또는 "processing", "failed"
  "progress": 100,  // 0~100
  "files": [
    {
      "file_type": "research_funding",
      "status": "completed",
      "rows_processed": 1523,
      "rows_inserted": 1498,
      "rows_skipped": 25,
      "errors": []
    },
    {
      "file_type": "students",
      "status": "failed",
      "error_message": "필수 컬럼 '학과'가 누락되었습니다.",
      "error_details": "3번째 행부터 '학과' 컬럼 값이 비어있습니다."
    }
  ],
  "completed_at": "2025-11-02T14:35:22Z"
}
```

**단계 3: 프런트엔드 상태 처리 분기**
- **`processing` 상태:** 폴링 계속, 프로그레스 바 업데이트
- **`completed` 상태:** 폴링 중단, 성공 UI 표시
- **`failed` 상태:** 폴링 중단, 에러 UI 표시

#### 출력 (User Feedback)
- **처리 중 (processing):**
  - UI 요소:
    - 각 파일별 프로그레스 바 (진행률 표시)
    - "데이터 처리 중... (약 XX초 소요)"
    - 진행 중인 파일명 하이라이트
  - 사용자는 다른 페이지로 이동 가능 (백그라운드 처리 계속)

- **완료 (completed):**
  - UI 요소:
    - 녹색 체크 아이콘
    - "업로드가 완료되었습니다!"
    - 세부 통계:
      - "총 X개 파일 중 Y개 성공"
      - "총 XXX건의 데이터가 등록되었습니다."
      - "처리 시간: X분 Y초"
  - 액션 버튼:
    - "대시보드 보기" → 메인 대시보드로 이동하여 업데이트된 데이터 확인
    - "추가 업로드" → 업로드 페이지 초기화

- **실패 (failed):**
  - UI 요소:
    - 빨간색 경고 아이콘
    - "업로드 중 오류가 발생했습니다."
    - 파일별 상세 에러 메시지:
      - "student_roster.csv 처리 실패"
      - "원인: 3번째 행에서 '학과' 컬럼이 비어있습니다."
      - "권장 조치: Excel에서 해당 행을 수정한 후 다시 업로드하세요."
  - 액션 버튼:
    - "다시 시도" → 파일 재선택 화면으로 이동
    - `[POST-MVP]` 에러 로그 다운로드
    - `[POST-MVP]` 부분 성공 처리

#### 엣지케이스
- **폴링 중 네트워크 단절:**
  - 3회 연속 실패 시 "네트워크 연결을 확인하세요" 경고
  - 재연결 시 자동으로 폴링 재개

- **장시간 처리 (3분 이상):**
  - 경고 메시지: "처리 시간이 예상보다 길어지고 있습니다. 파일 크기가 크거나 복잡한 데이터일 수 있습니다."
  - 추정 완료 시간 표시 (가능한 경우)

- **작업 ID 만료 또는 없음:**
  - "작업 정보를 찾을 수 없습니다." 메시지
  - "새로 업로드하기" 버튼

- **`[POST-MVP]` 부분 성공 처리:**
  - MVP에서는 전체 성공/실패만 처리

---

## 3. 메인 대시보드 조회 플로우

### 플로우 개요
내부 직원이 메인 대시보드에 접속하여 4가지 핵심 지표를 시각화된 차트로 조회하는 과정

### 진입점
- 루트 URL `/` 또는 `/dashboard` 직접 접속
- 데이터 업로드 완료 후 "대시보드 보기" 버튼 클릭
- 북마크 또는 공유된 링크

---

### 3.1 대시보드 초기 로드

#### 입력 (User Input)
- 브라우저에서 메인 대시보드 URL 접속
- HTTP GET 요청 자동 전송

#### 처리 (System Processing)

**단계 1: 프런트엔드 애플리케이션 초기화**
- React 앱 번들 로드
- 메인 대시보드 컴포넌트 렌더링 시작
- 초기 필터 상태 설정 (기본값: "전체 학과", "최근 1년")
- 스켈레톤 UI 표시 (로딩 중 임시 레이아웃)

**단계 2: 초기 데이터 요청 (병렬 처리)**
- `useDashboardData.js` Hook에서 4개의 API 요청 동시 전송:
  1. `GET /api/dashboard/research-funding/?department=all&year=latest`
  2. `GET /api/dashboard/students/?department=all&status=all`
  3. `GET /api/dashboard/publications/?department=all&year=latest`
  4. `GET /api/dashboard/department-kpi/?year=latest`
- 각 요청은 독립적으로 처리 (하나 실패해도 나머지 표시)

**단계 3: 백엔드 데이터 집계**
- DRF View에서 Django ORM을 통해 Supabase 쿼리
- 각 지표별 집계 로직:
  - **연구비:**
    - 최신 잔액: `총연구비 - SUM(집행금액)`
    - 월별 집행 추이: GROUP BY 집행일자 (월 단위)
  - **학생:**
    - 학과별 그룹화: GROUP BY 학과, 과정구분, 학년
    - 학적상태 필터링 (재학/휴학/졸업)
  - **논문:**
    - 저널 등급별 카운트: GROUP BY 저널등급
    - 평균 Impact Factor: AVG(Impact Factor WHERE NOT NULL)
  - **KPI:**
    - 년도별 추이: GROUP BY 평가년도
    - 취업률 및 기술이전 수입액
- JSON 형태로 응답 반환

**단계 4: 프런트엔드 데이터 처리 및 렌더링**
- API 응답 데이터를 Chart 컴포넌트에 맞는 형식으로 변환
- Recharts 라이브러리에 데이터 바인딩
- 4개의 차트 영역 순차 렌더링

#### 출력 (User Feedback)
- **성공 시:**
  - **페이지 레이아웃:**
    - 상단: 페이지 제목 "대학교 데이터 시각화 대시보드"
    - 우측 상단: 필터 드롭다운 (학과, 기간)
    - 최종 업데이트 시간 표시: "마지막 업데이트: 2025-11-02 14:35"

  - **4개 지표 카드 (상단 행):**
    - 연구비 잔액 카드: "총 연구비 잔액: 15억 3천만원"
    - 재학생 수 카드: "총 재학생: 1,234명"
    - 논문 수 카드: "총 논문: 156편 (평균 IF: 2.3)"
    - 평균 취업률 카드: "평균 취업률: 78.5%"
    - 각 카드에 전년 대비 증감 아이콘 (↑/↓) 및 백분율

  - **4개 핵심 차트 (그리드 레이아웃):**
    1. 연구비 집행 추이 (Line Chart)
    2. 학과별 학생 현황 (Stacked Bar Chart)
    3. 논문 실적 (Doughnut Chart)
    4. 학과 KPI 추이 (Dual-axis Line Chart)

- **실패 시:**
  - **데이터 없음 (DB에 데이터 미존재):**
    - 빈 상태 일러스트레이션 표시
    - 메시지: "아직 등록된 데이터가 없습니다."
    - 설명: "관리자가 데이터를 업로드하면 여기에 시각화가 표시됩니다."
    - 액션: (관리자 권한 있을 경우) "첫 데이터 업로드하기" 버튼

  - **API 에러 (서버 장애 등):**
    - 에러 상태 일러스트레이션
    - 메시지: "데이터를 불러오는 중 문제가 발생했습니다."
    - 액션: "새로고침" 버튼

#### 엣지케이스
- **네트워크 느림:**
  - 타임아웃: 30초
  - 스켈레톤 UI 유지
  - 30초 초과 시 "데이터 로딩이 지연되고 있습니다" 경고 표시

- **부분 데이터 로드 실패:**
  - 성공한 차트는 정상 표시
  - 실패한 차트 영역에 에러 카드 표시:
    - "이 데이터를 불러올 수 없습니다."
    - "재시도" 버튼 (해당 차트만 다시 로드)

- **브라우저 호환성:**
  - 구형 브라우저 감지 시 경고 배너 표시
  - "최신 Chrome, Firefox, Edge 브라우저 사용을 권장합니다."
  - 차트 렌더링 실패 시 대체 테이블 뷰 제공

- **첫 방문 사용자 (캐시 없음):**
  - 초기 로딩 시간 더 소요 가능
  - "초기 로딩 중..." 메시지 표시
  - 로딩 완료 후 캐싱하여 재방문 시 빠른 로드

---

### 3.2 차트별 데이터 표시 세부 사항

#### 3.2.1 연구비 집행 추이 (Line Chart)

**시각화 요소:**
- **차트 타입:** Line Chart (Recharts `<LineChart>`)
- **X축:** 집행 일자 (월별 또는 분기별 집계)
- **Y축:** 누적 잔액 또는 집행 금액 (억원 단위)
- **라인:** 파란색 실선, 데이터 포인트에 점 마커
- **그리드:** 수평 그리드 라인 (시인성 향상)

**상단 Metric Card:**
- "현재 연구비 잔액: 15.3억원"
- 전년 대비 증감: "+2.1억원 (↑ 15.8%)"

**인터랙션:**
- 호버 시 Tooltip 표시:
  - "2024년 3월: 잔액 15.3억원, 집행 1.2억원"

**엣지케이스:**
- **데이터 포인트 1개:** 단일 점만 표시, "추가 데이터 업로드 시 추이를 확인할 수 있습니다" 안내
- **급격한 변화 (이상치):** 해당 포인트 강조 표시, 관리자에게 알림 (선택적)

---

#### 3.2.2 학과별 학생 현황 (Stacked Bar Chart)

**시각화 요소:**
- **차트 타입:** Stacked Bar Chart (Recharts `<BarChart>`)
- **X축:** 학과명 (가로 스크롤 가능)
- **Y축:** 학생 수
- **스택:** 과정별 (학사/석사/박사) 또는 학년별
- **색상:** 과정별로 구분된 색상 팔레트

**범례:**
- 과정 구분 표시 (학사: 파랑, 석사: 초록, 박사: 주황)

**인터랙션:**
- 호버 시 Tooltip:
  - "컴퓨터공학과"
  - "학사: 120명, 석사: 35명, 박사: 12명"
  - "총: 167명"

**엣지케이스:**
- **학과 수 많음 (10개 이상):**
  - 차트 넓이 자동 확장
  - 가로 스크롤 바 표시
  - 또는 페이지네이션 (상위 10개 학과 우선 표시)

- **특정 학과 데이터 없음:** 해당 학과 바 표시하지 않거나 0으로 표시

---

#### 3.2.3 논문 실적 (Doughnut Chart)

**시각화 요소:**
- **차트 타입:** Doughnut Chart (Recharts `<PieChart>` with innerRadius)
- **섹션:** 저널 등급별 (SCIE, KCI, 기타)
- **값:** 논문 수
- **색상:** 등급별 구분 (SCIE: 진한 파랑, KCI: 연한 파랑)

**중앙 Metric:**
- "총 논문 수: 156편"

**상단 Metric Card:**
- "평균 Impact Factor: 2.3"

**인터랙션:**
- 호버 시 Tooltip:
  - "SCIE: 89편 (57.1%)"
  - "평균 IF: 3.2"

**엣지케이스:**
- **단일 등급만 존재:** 전체 도넛이 하나의 색상, 100% 표시
- **Impact Factor 없는 논문:** 평균 계산 시 제외, 또는 "IF 정보 없음" 별도 표시

---

#### 3.2.4 학과 KPI 추이 (Dual-axis Line Chart)

**시각화 요소:**
- **차트 타입:** Line Chart with Dual Y-Axis
- **X축:** 평가 년도
- **Y축 (왼쪽):** 취업률 (%)
- **Y축 (오른쪽):** 기술이전 수입액 (억원)
- **라인:**
  - 취업률: 실선, 파란색
  - 수입액: 점선, 주황색

**범례:**
- "졸업생 취업률", "기술이전 수입액"

**인터랙션:**
- 호버 시 Tooltip:
  - "2023년"
  - "취업률: 78.5%"
  - "수입액: 12.3억원"

**엣지케이스:**
- **년도 데이터 누락:** 해당 년도에서 라인 끊김 또는 점선으로 연결
- **음수 값:** 발생하지 않아야 하지만, 발생 시 에러 로그 기록 및 0으로 처리

---

## 4. 대시보드 필터링 플로우

### 플로우 개요
사용자가 학과, 기간 등 필터 조건을 선택하여 특정 데이터만 조회하는 과정

### 진입점
- 메인 대시보드에서 필터 드롭다운 또는 필터 패널 접근

---

### 4.1 필터 조건 선택

#### 입력 (User Input)
- **학과 필터:** 드롭다운에서 학과 선택
  - 옵션: "전체 학과", "컴퓨터공학과", "전자공학과", ...
- **기간 필터:** 드롭다운에서 기간 선택
  - 옵션: "최근 1년", "최근 3년", "2024년", "2023년", ...
- **학적상태 필터 (학생 차트 전용, 선택적):**
  - 라디오 버튼: "전체", "재학", "졸업"
- **저널등급 필터 (논문 차트 전용, 선택적):**
  - 체크박스: "SCIE", "KCI", "전체"

#### 처리 (System Processing)

**단계 1: 프런트엔드 필터 상태 업데이트**
- React State에 선택된 필터 값 저장
- `[P1-MVP]` 간단한 디바운싱 (300ms)

**단계 2: `[POST-MVP]` URL 쿼리 파라미터 업데이트 (공유 링크)**
- MVP에서는 생략, 필터 상태는 세션 내에서만 유지

**단계 3: 필터링된 데이터 API 요청**
- 선택된 필터 조건을 쿼리 파라미터로 포함하여 API 재호출:
  - `GET /api/dashboard/research-funding/?department=컴퓨터공학과&year=2024`
  - `GET /api/dashboard/students/?department=컴퓨터공학과&status=enrolled`
  - 기타 차트도 동일

**단계 4: 백엔드 필터링 쿼리 실행**
- Django ORM에서 WHERE 절 추가:
  ```python
  queryset = ResearchProject.objects.filter(
      소속학과='컴퓨터공학과',
      집행일자__year=2024
  )
  ```
- 필터링된 데이터 집계 및 JSON 응답

**단계 5: 차트 리렌더링**
- 프런트엔드에서 새로운 데이터로 차트 업데이트
- Recharts 애니메이션 효과 (부드러운 전환)
- 로딩 스피너는 짧게 표시 (1초 미만)

#### 출력 (User Feedback)
- **성공 시:**
  - 차트가 필터 조건에 맞게 업데이트됨
  - 필터 드롭다운에 선택된 값 표시
  - 필터 초기화 버튼 활성화: "전체 보기"
  - `[POST-MVP]` 필터 칩/태그 UI (X 버튼으로 개별 제거)

- **필터 결과 없음:**
  - 차트 영역에 빈 상태 표시
  - 메시지: "선택한 조건에 해당하는 데이터가 없습니다."
  - 추천: "다른 필터 조건을 선택하거나 '전체 보기'를 클릭하세요."
  - 필터 초기화 버튼 강조

- **API 에러:**
  - 기존 차트 유지 (마지막 성공 데이터)
  - 에러 토스트 알림: "필터 적용 중 오류가 발생했습니다. 다시 시도하세요."

#### 엣지케이스
- **다중 필터 조합:**
  - 학과 + 기간 + 학적상태 동시 적용 시 AND 조건으로 처리
  - 필터 조합이 너무 좁아 결과 없을 경우 위 "필터 결과 없음" 처리

- **필터 빠른 변경:**
  - 디바운싱으로 불필요한 API 호출 방지
  - 사용자가 드롭다운에서 여러 옵션을 빠르게 클릭해도 마지막 선택만 적용

- **잘못된 필터 값 (URL 직접 수정 등):**
  - 백엔드에서 400 Bad Request 반환
  - 프런트엔드에서 필터 초기화 및 에러 토스트 표시

- **필터 적용 중 새로고침:**
  - URL 쿼리 파라미터에서 필터 상태 복원
  - 동일한 필터 조건으로 데이터 재로드

---

### 4.2 필터 초기화 `[P1-MVP]`

#### 입력 (User Input)
- "전체 보기" 또는 "초기화" 버튼 클릭

#### 처리 (System Processing)
- 모든 필터 상태를 기본값으로 리셋:
  - 학과: "전체 학과"
  - 기간: "최근 1년"
  - 기타: 기본값
- URL 쿼리 파라미터 제거
- 기본 필터 조건으로 API 재호출

#### 출력 (User Feedback)
- 차트가 전체 데이터로 복원됨
- 필터 드롭다운이 기본값으로 리셋
- "전체 보기" 버튼 비활성화

**[POST-MVP]** URL 기반 필터 공유 기능

---

## 5. 차트 인터랙션 플로우 `[P1-MVP]`

### 플로우 개요
MVP에서는 **기본 Tooltip만 구현**합니다. 확대/축소, 드릴다운, 내보내기 등 고급 기능은 POST-MVP로 미룹니다.

---

### 5.1 차트 요소 호버 (Tooltip) `[P1-MVP]`

#### 입력 (User Input)
- 마우스 커서를 차트의 데이터 포인트, 바, 섹션 등에 올림

#### 처리 (System Processing)
- Recharts의 기본 Tooltip 컴포넌트 활성화
- 해당 데이터 포인트의 상세 정보 추출
- 커스텀 Tooltip 템플릿에 데이터 바인딩

#### 출력 (User Feedback)
- 커서 근처에 Tooltip 팝업 표시
- **내용 예시:**
  - **연구비 차트:** "2024년 3월: 집행 1.2억원, 잔액 15.3억원"
  - **학생 차트:** "컴퓨터공학과 - 학사 3학년: 42명"
  - **논문 차트:** "SCIE: 89편 (57.1%), 평균 IF: 3.2"
  - **KPI 차트:** "2023년 - 취업률: 78.5%, 수입액: 12.3억원"
- 커서 이동 시 Tooltip 자동 업데이트
- 커서가 차트 밖으로 나가면 Tooltip 사라짐

#### 엣지케이스
- **모바일 터치:**
  - 데이터 포인트 탭하여 Tooltip 고정 표시
  - 다른 곳 탭하면 사라짐

- **Tooltip 겹침:**
  - 여러 데이터 포인트가 근접한 경우 가장 가까운 것만 표시

- **긴 텍스트:**
  - Tooltip 최대 너비 설정
  - 긴 텍스트는 줄바꿈 처리

**[POST-MVP 고급 기능]**
- 차트 확대/축소 (Zoom, Brush)
- 차트 클릭 드릴다운 (필터 자동 적용)
- 차트 데이터 내보내기 (CSV/PNG/PDF)

---

## 6. 데이터 갱신 플로우 `[P1-MVP]`

### 플로우 개요
MVP에서는 **수동 새로고침만 구현**합니다. 자동 폴링, 변경 비교 등은 POST-MVP 기능입니다.

---

### 6.1 수동 새로고침 `[P1-MVP]`

#### 입력 (User Input)
- 대시보드 헤더의 "새로고침" 버튼 클릭
- 또는 브라우저 새로고침 (F5, Cmd+R)

#### 처리 (System Processing)
- 프런트엔드 캐시된 데이터 클리어
- 현재 필터 조건으로 모든 차트 데이터 재요청
- API 호출 → 백엔드에서 최신 DB 데이터 조회 → 응답

#### 출력 (User Feedback)
- 로딩 인디케이터 표시 (스피너 또는 스켈레톤 UI)
- 데이터 로드 완료 시 차트 업데이트
- "데이터가 갱신되었습니다" 토스트 알림 (짧게 표시)

#### 엣지케이스
- **빠른 연속 새로고침:** 1초 이내 중복 클릭 무시 (간단한 디바운싱)

**[POST-MVP 고급 기능]**
- 자동 갱신 (30초 간격 폴링)
- 데이터 업데이트 타임스탬프 표시
- 이전 데이터와 비교 (스냅샷 기반)

---

## 7. 에러 처리 플로우 `[P0-MVP]`

### 플로우 개요
MVP에서는 **핵심 에러만 처리**합니다. 복잡한 에러 로깅, 자동 재시도, 감사 추적 등은 제외합니다.

---

### 7.1 파일 업로드 검증 에러 `[P0-MVP]`

#### 발생 시나리오
- 파일 크기 초과 (>10MB)
- 잘못된 파일 형식 (.pdf, .doc 등)
- 필수 컬럼 누락
- 데이터 타입 불일치
- 중복 PK

#### 처리 (System Processing)
- 프런트엔드 또는 백엔드 검증 단계에서 에러 감지
- 구체적인 에러 메시지 생성 (에러 타입, 파일명, 위반 규칙, 권장 조치)

#### 출력 (User Feedback)
- 에러 알림 표시:
  - **크기 초과:** "파일 'student_roster.xlsx'의 크기가 12.3MB로 제한(10MB)을 초과합니다. 데이터를 분할하거나 불필요한 행을 제거하세요."
  - **컬럼 누락:** "'research_project_data.csv'에서 필수 컬럼 [집행ID, 소속학과]가 누락되었습니다. Ecount 추출 시 모든 필수 컬럼이 포함되었는지 확인하세요."
  - **데이터 타입 오류:** "'publication_list.csv' 45번째 행의 'Impact Factor' 컬럼에 숫자가 아닌 값('N/A')이 있습니다. 숫자 또는 빈 칸으로 수정하세요."
- 에러가 발생한 파일 강조 표시
- "파일 다시 선택" 버튼

#### 복구 플로우
- 사용자가 파일 수정 후 재업로드

#### 엣지케이스
- **다중 에러:** 최대 5개까지 에러 메시지 표시, 초과 시 "외 X개 에러" 요약

---

### 7.2 데이터 처리 실패 (Parsing/DB 에러) `[P0-MVP]`

#### 발생 시나리오
- Pandas 파싱 예외 (손상된 CSV)
- 데이터베이스 트랜잭션 롤백
- 처리 타임아웃
- 메모리 부족

#### 처리 (System Processing)
- `excel_parser.py` 또는 `repositories.py`에서 예외 발생
- 작업 상태를 `"failed"`로 업데이트
- 기본 에러 메시지 생성

#### 출력 (User Feedback)
- 폴링 응답에서 `"failed"` 상태 감지
- 에러 알림 표시:
  - "데이터 처리 중 오류가 발생했습니다."
  - "'student_roster.csv' 파싱 실패"
  - "파일 형식을 확인하고 다시 시도하세요."
- "다시 시도" 버튼

---

### 7.3 API 연결 에러 `[P0-MVP]`

#### 발생 시나리오
- 백엔드 서버 다운
- 네트워크 타임아웃

#### 처리 (System Processing)
- 네트워크 에러 감지
- 간단한 재시도 (1회만)

#### 출력 (User Feedback)
- 에러 메시지:
  - "서버에 연결할 수 없습니다."
  - "네트워크 연결을 확인하세요."
- "재시도" 버튼

#### 복구 플로우
- 사용자가 "재시도" 버튼 클릭
- 실패한 API 요청 재실행

---

### 7.4 차트 렌더링 에러 `[P1-MVP]`

#### 발생 시나리오
- Recharts 렌더링 예외
- 차트 데이터 부족

#### 처리 (System Processing)
- React Error Boundary로 렌더링 에러 캐치
- 간단한 에러 메시지 표시

#### 출력 (User Feedback)
- 에러 메시지: "차트를 표시할 수 없습니다."
- "새로고침" 버튼

---

### 7.5 권한 부족 (403 Forbidden) `[P0-MVP]`

#### 발생 시나리오
- 비관리자가 업로드 API 접근 시도
- API Key 불일치 또는 만료

#### 처리 (System Processing)
- API Key 검증 실패
- HTTP 403 응답 반환

#### 출력 (User Feedback)
- 에러 메시지: "접근 권한이 없습니다. 관리자 전용 기능입니다."
- 메인 대시보드로 리디렉션

---

## 8. 필수 엣지케이스 `[P1-MVP]`

MVP에서는 **최소한의 엣지케이스만 처리**합니다. 복잡한 시나리오는 POST-MVP로 미룹니다.

---

### 8.1 동시 다중 관리자 업로드 `[P1-MVP]`

**시나리오:** 여러 관리자가 동시에 파일 업로드

**처리 방안:**
- 각 업로드는 독립적인 `job_id`로 관리
- 동일한 파일 타입 업로드 시: Last-Write-Wins (마지막 것만 적용)

**사용자 피드백:**
- 각 관리자는 자신의 업로드 상태만 추적

---

### 8.2 부분 데이터만 업로드된 상태 `[P1-MVP]`

**시나리오:** 4가지 파일 중 일부만 업로드됨

**처리 방안:**
- 존재하는 데이터는 정상 표시
- 없는 데이터 영역은 빈 상태 표시

**사용자 피드백:**
- 빈 차트 영역에 메시지: "논문 데이터가 없습니다. 관리자가 파일을 업로드하면 표시됩니다."

---

### 8.3 데이터 재업로드 (수정) `[P1-MVP]`

**시나리오:** 잘못된 데이터 발견 후 수정본 재업로드

**처리 방안:**
- 전체 교체 모드: 기존 데이터 삭제 후 신규 데이터 삽입

**사용자 피드백:**
- 확인 모달: "기존 데이터를 삭제하고 새 데이터로 교체합니다. 계속하시겠습니까?"
- "교체", "취소" 버튼

---

### 8.4 대용량 데이터 처리 `[P1-MVP]`

**시나리오:** 수천 건 이상의 레코드

**처리 방안:**
- 백엔드에서 기본 제한 (최대 10,000건)
- 초과 시 에러 메시지

**사용자 피드백:**
- "데이터가 너무 많습니다(최대 10,000건). 데이터를 분할하여 업로드하세요."

---

**[POST-MVP 고급 시나리오]**
- 데이터 스키마 버전 관리
- 구형 브라우저 호환성
- 모바일 반응형 최적화
- 오래된 데이터 경고 (30일 기준)
- 세션 타임아웃 복구
- 청크 업로드 재개

---

## MVP 범위 요약

### P0-MVP (필수 구현)
1. **관리자 데이터 업로드**
   - 4가지 CSV/Excel 파일 업로드
   - 기본 파일 검증 (크기, 형식, 필수 컬럼)
   - 비동기 백그라운드 처리
   - 작업 상태 폴링 (3초 간격)

2. **메인 대시보드 조회**
   - 4가지 핵심 차트 (연구비, 학생, 논문, KPI)
   - 기본 지표 카드

3. **필터링**
   - 학과, 기간 드롭다운 필터
   - 필터 초기화

4. **핵심 에러 처리**
   - 파일 업로드 검증 에러
   - 데이터 처리 실패
   - API 연결 에러
   - 권한 부족

### P1-MVP (중요하지만 간소화 가능)
- 차트 기본 Tooltip
- 수동 새로고침
- 간단한 디바운싱
- 기본 엣지케이스 (4개)

### POST-MVP (추후 고도화)
- 차트 확대/축소, 드릴다운, 내보내기
- 자동 갱신 (폴링)
- 데이터 변경 비교
- URL 기반 필터 공유
- 에러 로그 다운로드
- 부분 성공 처리
- 구형 브라우저 호환성
- 모바일 최적화
- 감사 추적

---

## 문서 변경 이력

| 버전 | 날짜 | 변경 사항 | 작성자 |
|------|------|-----------|--------|
| 1.0 | 2025-11-02 | 초기 유저플로우 문서 작성 | Userflow Writer Agent |
| 2.0 | 2025-11-02 | MVP 최적화 (오버엔지니어링 제거, CTO Mandate 반영) | Claude Code |

---

## 승인 및 검토

**작성자:** Userflow Writer Agent / Claude Code
**검토자:** CTO
**승인일:** 2025-11-02

본 유저플로우 문서는 **MVP 범위**에 맞춘 개발 가이드입니다. 첫 베타테스트에 필요한 최소 기능만 구현하며, POST-MVP 기능은 베타 피드백 후 우선순위를 재평가합니다.

**MVP 개발 우선순위:**
1. `[P0-MVP]` 태그 기능: 필수 구현 (블로커)
2. `[P1-MVP]` 태그 기능: 중요하지만 간소화 가능
3. `[POST-MVP]` 태그 기능: 추후 고도화 단계

---

**문서 끝**
</file>

</files>
